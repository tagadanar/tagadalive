include('../auto')

class AI {
	
	/*
	 * Premier exemple d'algo naif où je cherche uniquement à maximiser les dégats sur nearest enemy
	 * en exploitant uniquement les données de la MapDanger
	 * TODO n'ajoute pas de déplacement de repli à la fin de la combo !
	 * ne check pas le nombre de MP nécessaire entre les actions, qui peuvent être depuis plusieurs cases !
	 * @return combo contenant le tableau d'actions et les dommages estimés
	 */
	static Combo getSimpleOffensiveCombo(){
		Combo combo = Combo()
		integer tpleft = Fight.self.tp
		Item? inHand = Fight.self.getWeaponInHand()
		Entity enemy = Fight.getEntity(getNearestEnemy())
		for(Item item in Fight.self.offensiveItemsByTargets[enemy]!){
			real ratioDmg = MapDanger._map_entity_item_danger[Fight.self]![item]![enemy.cell]!
			real tmpdmg = Damages.getDamage(Fight.self, Fight.getEntity(getEntityOnCell(enemy.cell.id)), item, ratioDmg, null)
			var switchCost = item.isWeap && item != inHand ? 1 : 0
			if(tmpdmg > 0){
				while(item.cost+switchCost<=tpleft){
					tpleft-=item.cost+switchCost
					if(switchCost==1){ inHand = item; switchCost = 0 }
					combo.add(Action(item, Targets.getCellToUseItemOnCell(Fight.self, item, enemy.cell, [Fight.self.id])!, enemy.cell))
					if(item.haveCD) break
				}
			}
		}
		return combo
	}
	
	/* 
	 * Exploration des actions simple, recherche de move en 2 déplacements :
	 * - pour chaque cell accessible:
		* 	dans un combo j'ajoute la meilleure action par score jusqu'à épuisement
	 	*	puis je trouve une case de repli.
		*	je recommence un combo en ajoutant les actions que je peux me lancer sur moi mm
	 * je retourne le meilleure combo trouvé
	 */
	static Combo getPotentialCombo(){
		Map<Cell, Map<Item, Action>> mapBestAction = MapAction.getMapBestAction()
		Combo? bestCombo = null
		// all reachableCells
		//var arrayCombo = []
		for(Cell cell:integer mp in Fight.self.reachableCells){
			if(mp>Fight.self.mp) break
			if(!mapBestAction[cell]) mapBestAction[cell] = [:];
			// cas 1 : uniquement les items sur d'autres leeks:
						
			//when i handle move after combo
			Combo combo = Combo()
			integer tpleft = Fight.self.tp
			Item? inHand = Fight.self.getWeaponInHand()
			
			// tri par score des actions
			Array<Action> sortedAction = arraySort(mapValues(mapBestAction[cell]!), (Action a, Action b) => integer|real {
				return Sort.desc(a.score!, b.score!)
			}) as Array<Action>;
			
			// ajout du meilleur score sur la case jusqu'à épuisement des TP/CD
			for(Action action in sortedAction){
				integer switchCost = action.item.isWeap && action.item != inHand ? 1 : 0
				while(action.item.cost+switchCost<=tpleft){
					if(combo.add(action)){
						tpleft-=action.item.cost+switchCost
						if(switchCost==1){ inHand = action.item; switchCost = 0 }
					} else break
					if(action.item.haveCD) break
				}
			}
			// recherche d'une case de fin de tour
			combo.addFinalDanger(AI.findBestDanger(combo))

			if(!bestCombo || bestCombo!.getScore() < combo.getScore()){
				bestCombo = combo
			}
				
			// cas 2: en ajoutant les items que je peux selfcast
			
			//when i handle move after combo
			Combo combo2 = Combo()
			integer tpleft2 = Fight.self.tp
			Item? inHand2 = Fight.self.getWeaponInHand()
			
			// ajout des actions sur moi mm dans les meilleurs moves sur cette case
			if(mapBestAction[Fight.selfCell]){
				for(Item item: Action action in mapBestAction[Fight.selfCell]!){
					if(mapBestAction[cell]![item]){
						if(action.score > mapBestAction[cell]![item]!.score) mapBestAction[cell]![item] = action
					}else{
						mapBestAction[cell]![item] = action
					}
				}
			}
			// note : cette façon de faire en dessous "casse" les clés, le string() renvoie tjr le bon item, mais les champs sont null
			//mapBestAction[cell] += mapBestAction[Fight.selfCell]
			
			// tri par score des actions
			sortedAction = arraySort(mapValues(mapBestAction[cell]!), (Action a, Action b) => integer|real {
				return Sort.desc(a.score!, b.score!)
			}) as Array<Action>;
			
			// ajout du meilleur score sur la case jusqu'à épuisement des TP/CD
			for(Item item:Action action in mapBestAction[cell]!){
				integer switchCost = item.isWeap && item != inHand2 ? 1 : 0
				while(item.cost+switchCost<=tpleft2){
					if(combo2.add(action)){
						tpleft2-=item.cost+switchCost
						if(switchCost==1){ inHand2 = item; switchCost = 0 }
					} else break
					if(item.haveCD) break
				}
			}
			// recherche d'une case de fin de tour
			combo2.addFinalDanger(AI.findBestDanger(combo2))

			if(!bestCombo || bestCombo!.getScore() < combo2.getScore()){
				bestCombo = combo2
			}	
				
		}

		return bestCombo!
	}
	
	/*
	 * Premier exemple d'algo naif de recherche de case de fin de tour
	 * je minimise les dégats, puis à danger équivalent je choisi la case la plus proche de l'adversaire
	 */
	static Danger findBestDanger(Combo combo){
		Consequences consequences = combo.getCurrentConsequences()		
		Cell shouldGetCloseTo = Fight.getEntity(getNearestEnemy()).cell
		Danger? bestDanger = null
		// depuis la case @from, avec les mp restant
		integer currentMP = combo.getCurrentMP()
		Map<Cell, integer> reachableCells = combo.getCurrentReachableCells()
		for(Cell cell:integer mp in reachableCells){
			if(mp > currentMP) break
			Danger danger = MapDanger.getCellDanger(cell, consequences)
			if(!bestDanger || bestDanger!.dmg > danger.dmg) {
				bestDanger = danger
			} else if(bestDanger!.dmg == danger.dmg){
				// en cas de danger équivalent, je m'approche le plus possible de l'adv
				if(getCellDistance(bestDanger!.cell.id, shouldGetCloseTo.id) > getCellDistance(danger.cell.id, shouldGetCloseTo.id)){
					bestDanger = danger
				}
			}
		}
		return bestDanger!
	}

	/*
	 * Recherche de case de fin de tour avancé, prenant en compte de multiples problématiques
	 */
	static findBestPosition(Combo combo){
		var reachableCells = combo.getCurrentReachableCells()
		
		// TODO
	}
}