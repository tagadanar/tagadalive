class AI {
	
	/*
	 * @unused Legacy greedy algorithm - replaced by getMCTSCombo()
	 * Premier exemple d'algo naif où je cherche uniquement à maximiser les dégats sur nearest enemy
	 * en exploitant uniquement les données de la MapDanger
	 */
	static Combo getSimpleOffensiveCombo(){
		Combo combo = Combo()
		integer tpleft = Fight.self.tp
		Item? inHand = Fight.self.getWeaponInHand()
		Entity enemy = Fight.getEntity(getNearestEnemy())
		for(Item item in Fight.self.offensiveItemsByTargets[enemy]!){
			real ratioDmg = MapDanger._map_entity_item_danger[Fight.self]![item]![enemy.cell]!
			real tmpdmg = Damages.getDamage(Fight.self, Fight.getEntity(getEntityOnCell(enemy.cell.id)), item, ratioDmg, null)
			var switchCost = item.isWeap && item != inHand ? 1 : 0
			if(tmpdmg > 0){
				while(item.cost+switchCost<=tpleft){
					tpleft-=item.cost+switchCost
					if(switchCost==1){ inHand = item; switchCost = 0 }
					combo.add(Action(item, Targets.getCellToUseItemOnCell(Fight.self, item, enemy.cell, [Fight.self.id])!, enemy.cell))
					if(item.haveCD) break
				}
			}
		}
		return combo
	}
	
	/*
	 * @unused Legacy greedy algorithm - replaced by getMCTSCombo()
	 * Exploration des actions simple, recherche de move en 2 déplacements
	 */
	static Combo getPotentialCombo(){
		Map<Cell, Map<Item, Action>> mapBestAction = MapAction.getMapBestAction()
		Combo? bestCombo = null
		// all reachableCells
		//var arrayCombo = []
		for(Cell cell:integer mp in Fight.self.reachableCells){
			if(mp>Fight.self.mp) break
			if(!mapBestAction[cell]) mapBestAction[cell] = [:];
			// cas 1 : uniquement les items sur d'autres leeks:
						
			//when i handle move after combo
			Combo combo = Combo()
			integer tpleft = Fight.self.tp
			Item? inHand = Fight.self.getWeaponInHand()
			
			// tri par score des actions
			Array<Action> sortedAction = arraySort(mapValues(mapBestAction[cell]!), (Action a, Action b) => integer|real {
				return Sort.desc(a.score!, b.score!)
			}) as Array<Action>;
			
			// ajout du meilleur score sur la case jusqu'à épuisement des TP/CD
			for(Action action in sortedAction){
				integer switchCost = action.item.isWeap && action.item != inHand ? 1 : 0
				while(action.item.cost+switchCost<=tpleft){
					if(combo.add(action)){
						tpleft-=action.item.cost+switchCost
						if(switchCost==1){ inHand = action.item; switchCost = 0 }
					} else break
					if(action.item.haveCD) break
				}
			}
			// recherche d'une case de fin de tour
			combo.addFinalPosition(AI.findBestPosition(combo))

			if(!bestCombo || bestCombo!.getScore() < combo.getScore()){
				bestCombo = combo
			}
				
			// cas 2: en ajoutant les items que je peux selfcast
			
			//when i handle move after combo
			Combo combo2 = Combo()
			integer tpleft2 = Fight.self.tp
			Item? inHand2 = Fight.self.getWeaponInHand()
			
			// ajout des actions sur moi mm dans les meilleurs moves sur cette case
			if(mapBestAction[Fight.selfCell]){
				for(Item item: Action action in mapBestAction[Fight.selfCell]!){
					if(mapBestAction[cell]![item]){
						if(action.score > mapBestAction[cell]![item]!.score) mapBestAction[cell]![item] = action
					}else{
						mapBestAction[cell]![item] = action
					}
				}
			}
			// note : cette façon de faire en dessous "casse" les clés, le string() renvoie tjr le bon item, mais les champs sont null
			//mapBestAction[cell] += mapBestAction[Fight.selfCell]
			
			// tri par score des actions
			sortedAction = arraySort(mapValues(mapBestAction[cell]!), (Action a, Action b) => integer|real {
				return Sort.desc(a.score!, b.score!)
			}) as Array<Action>;
			
			// ajout du meilleur score sur la case jusqu'à épuisement des TP/CD
			for(Item item:Action action in mapBestAction[cell]!){
				integer switchCost = item.isWeap && item != inHand2 ? 1 : 0
				while(item.cost+switchCost<=tpleft2){
					if(combo2.add(action)){
						tpleft2-=item.cost+switchCost
						if(switchCost==1){ inHand2 = item; switchCost = 0 }
					} else break
					if(item.haveCD) break
				}
			}
			// recherche d'une case de fin de tour
			combo2.addFinalPosition(AI.findBestPosition(combo2))

			if(!bestCombo || bestCombo!.getScore() < combo2.getScore()){
				bestCombo = combo2
			}	
				
		}

		return bestCombo!
	}
	
	/*
	 * Find best end-of-turn position using full positioning score:
	 * - Danger (damage we could receive)
	 * - Life-based scaling (more cautious when low HP)
	 * - Proximity to other enemies
	 * - Gravity (ideal distances to allies/enemies)
	 * - Tactical bonuses (lock, COVID, CAC range)
	 * - Shield value
	 * - MP efficiency
	 */
	static Position findBestPosition(Combo combo){
		Consequences consequences = combo.getCurrentConsequences()
		Cell currentCell = combo.getCurrentCell()
		integer currentMP = combo.getCurrentMP()

		return MapPosition.findBestPosition(currentCell, currentMP, consequences)
	}

	/*
	 * MCTS-based combo search
	 * Explores action sequences using Monte Carlo Tree Search instead of greedy selection
	 * Keeps position enumeration (hybrid approach) but uses MCTS within each position
	 * ALWAYS returns a combo - never falls back to greedy
	 */
	static Combo getMCTSCombo() {
		Benchmark.start("AI.getMCTSCombo")

		Map<Cell, Map<Item, Action>> mapBestAction = MapAction.getMapBestAction()
		Combo? bestCombo = null
		integer positionsExplored = 0

		// For each reachable position
		for (Cell cell : integer mp in Fight.self.reachableCells) {
			if (mp > Fight.self.mp) break

			// Check operation budget - stop exploring new positions if low
			if (MCTS.shouldStop() && bestCombo != null) {
				debug("MCTS: Budget low, " + positionsExplored + " pos explored")
				break
			}

			positionsExplored++

			// Get actions for this cell (may be empty)
			Map<Item, Action> cellActions = mapBestAction[cell] ? clone(mapBestAction[cell]!, 1) as Map<Item, Action> : [:]

			// Merge self-cast actions
			if (mapBestAction[Fight.selfCell]) {
				for (Item item : Action action in mapBestAction[Fight.selfCell]!) {
					if (!cellActions[item] || action.score! > cellActions[item]!.score!) {
						cellActions[item] = action
					}
				}
			}

			// Run MCTS from this position (always returns a combo now)
			Combo combo = MCTS.search(
				cell,
				cellActions,
				Fight.self.tp,
				Fight.self.mp - mp,
				Fight.self.getWeaponInHand()
			)

			if (!bestCombo || bestCombo!.getScore()! < combo.getScore()!) {
				bestCombo = combo
			}
		}

		Benchmark.stop("AI.getMCTSCombo")

		// Should never be null now, but safety check
		if (bestCombo == null) {
			debugE("MCTS: No combo found - this should not happen!")
			// Emergency: just return current position
			Combo emergency = Combo()
			emergency.addFinalPosition(MCTS.findBestPositionFromCell(Fight.self.cell, Fight.self.mp, Consequences()))
			return emergency
		}

		// Build path string: action1(score)→action2(score)→move(cell: breakdown)
		string path = ""
		for (Action a in bestCombo!.actions) {
			if (path != "") path += "→"
			path += a.item.name + "(" + round(a.score!) + ")"
		}
		if (bestCombo!.finalPosition) {
			if (path != "") path += "→"
			Position p = bestCombo!.finalPosition!
			path += "move(" + p.cell.id + ": "
			path += round(p.score) + "="
			path += round(-p.dmg) + "d"
			path += (p.proximityScore >= 0 ? "+" : "") + round(p.proximityScore) + "p"
			path += (p.gravityScore >= 0 ? "+" : "") + round(p.gravityScore) + "g"
			path += (p.tacticalScore >= 0 ? "+" : "") + round(p.tacticalScore) + "t"
			path += ")"
		}
		if (path == "") path = "stay"

		debug("MCTS: " + positionsExplored + " pos, " + MCTS.lastIterations + " iter, score=" + round(bestCombo!.getScore()!) + " | " + path)
		return bestCombo!
	}
}