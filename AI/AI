/*
 * AI - Main entry point and utilities for combo search
 *
 * Algorithm selection: set AI.mode in main before calling AI.getCombo()
 * Example: AI.mode = AI.MODE_UNIFIED_MCTS
 *
 * See AI/Algorithms/ for algorithm implementations:
 *   - PTS: Fast greedy target-first
 *   - MCTS: Monte Carlo Tree Search
 *   - BeamSearch: Beam search multi-path
 *   - UnifiedMCTS: Single tree with cells as first-level
 *   - CellMCTS: Cell-centric with mid-combo movement (MoveNodes)
 *   - OpportunityMCTS: Opportunity-centric tree (implicit movement)
 *   - Hybrid: Combines PTS with other algorithms
 *
 * All MCTS variants use CalibratedPTS for seeding and position estimation.
 */
class AI {
	// === Algorithm Modes ===
	static integer MODE_PTS = 0             // Priority Target Simulation (fast, greedy)
	static integer MODE_MCTS = 1            // Monte Carlo Tree Search (thorough, slower)
	static integer MODE_BEAM = 2            // Beam Search (balanced speed/quality)
	static integer MODE_HYBRID = 3          // PTS seeds MCTS at one cell
	static integer MODE_HYBRID_GUIDED = 4   // PTS guides MCTS cell order
	static integer MODE_HYBRID_BEAM = 5     // PTS guides Beam Search cell order
	static integer MODE_UNIFIED_MCTS = 6    // Unified MCTS with cell selection in tree
	static integer MODE_CELL_MCTS = 7       // Cell-centric MCTS with mid-combo movement
	static integer MODE_OPPORTUNITY_MCTS = 8 // Opportunity-centric MCTS (recommended)
	static integer MODE_COMBO_EXPLORER = 9   // Multi-phase combo exploration

	// Current mode (default value, can be overridden in main)
	static integer mode = AI.MODE_UNIFIED_MCTS

	// === Calibration Control ===
	// Set to true to skip CalibratedPTS entirely (pure MCTS mode)
	// When true: no PTS baseline, no seeding, MCTS-only result
	static boolean SKIP_CALIBRATION = false

	// Default mpValue when calibration is skipped (position score per MP)
	// Used by CellMCTS/OpportunityMCTS for movement cost estimation
	static real DEFAULT_MP_VALUE = 50.0

	/*
	 * Get readable name for a mode (for debugging)
	 */
	static string getModeName(integer m) {
		if (m == AI.MODE_PTS) return "PTS"
		if (m == AI.MODE_MCTS) return "MCTS"
		if (m == AI.MODE_BEAM) return "BEAM"
		if (m == AI.MODE_HYBRID) return "HYBRID"
		if (m == AI.MODE_HYBRID_GUIDED) return "HYBRID_GUIDED"
		if (m == AI.MODE_HYBRID_BEAM) return "HYBRID_BEAM"
		if (m == AI.MODE_UNIFIED_MCTS) return "UNIFIED_MCTS"
		if (m == AI.MODE_CELL_MCTS) return "CELL_MCTS"
		if (m == AI.MODE_OPPORTUNITY_MCTS) return "OPP_MCTS"
		if (m == AI.MODE_COMBO_EXPLORER) return "EXPLORER"
		return "UNKNOWN"
	}

	/*
	 * Main entry point: get the best combo using the selected algorithm.
	 */
	static Combo getCombo() {
		if (AI.mode == AI.MODE_PTS) {
			Benchmark.setAlgo("PTS", "PTS")
			Combo ptsCombo = PTS.buildCombo()
			Benchmark.setChosen(ptsCombo.getScore()!, count(ptsCombo.actions), "PTS:" + PTS.buildComboDesc(ptsCombo))
			return ptsCombo
		}
		if (AI.mode == AI.MODE_MCTS) {
			Benchmark.setAlgo("MCTS", "MCTS")
			return Hybrid.runMCTSFull()
		}
		if (AI.mode == AI.MODE_BEAM) {
			Benchmark.setAlgo("BEAM", "BEAM")
			return Hybrid.runBeamFull()
		}
		if (AI.mode == AI.MODE_HYBRID) {
			return Hybrid.getMCTSSeeded()
		}
		if (AI.mode == AI.MODE_HYBRID_GUIDED) {
			return Hybrid.getMCTSGuided()
		}
		if (AI.mode == AI.MODE_HYBRID_BEAM) {
			return Hybrid.getBeamGuided()
		}
		if (AI.mode == AI.MODE_CELL_MCTS) {
			return CellMCTS.run()
		}
		if (AI.mode == AI.MODE_OPPORTUNITY_MCTS) {
			return OpportunityMCTS.run()
		}
		if (AI.mode == AI.MODE_COMBO_EXPLORER) {
			Benchmark.setAlgo("EXPLORER", "EXPLORER")
			Combo combo = ComboExplorer.explore()
			Benchmark.setChosen(combo.getScore()!, count(combo.actions), "EXP:" + ComboExplorer.buildComboDesc(combo))
			return combo
		}
		// MODE_UNIFIED_MCTS (default)
		return UnifiedMCTS.run()
	}

	/*
	 * Find best end-of-turn position for a combo.
	 * Used by all algorithms after action selection.
	 */
	static Position findBestPosition(Combo combo) {
		Consequences consequences = combo.getCurrentConsequences()
		Cell currentCell = combo.getCurrentCell()
		integer currentMP = combo.getCurrentMP()
		return MapPosition.findBestPosition(currentCell, currentMP, consequences)
	}
}
