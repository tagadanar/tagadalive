/*
 * ActionKnapsack - Bounded Knapsack for Action Selection
 *
 * Optimizes action selection within a TP budget, handling:
 * - Weapon switch costs (state tracks current weapon)
 * - Item usage limits (maxUse per item)
 * - DP-based selection for optimal total score
 *
 * Used by ComboExplorer for better TP allocation than greedy selection.
 */

// ════════════════════════════════════════════════════════════════
// KNAPSACK ITEM WRAPPER
// ════════════════════════════════════════════════════════════════

class KnapsackItem {
	Action action
	integer baseCost       // Base TP cost (without switch)
	real score
	integer weaponIdx      // -1 for chips, 0+ for weapons

	constructor(Action action, integer baseCost, real score, integer weaponIdx) {
		this.action = action
		this.baseCost = baseCost
		this.score = score
		this.weaponIdx = weaponIdx
	}
}

// ════════════════════════════════════════════════════════════════
// MAIN KNAPSACK SOLVER
// ════════════════════════════════════════════════════════════════

class ActionKnapsack {
	// Weapon index mapping
	static Array<Item> weaponList = []
	static Map<Item, integer> weaponToIdx = [:]
	static integer CHIP = -1  // Chips don't change weapon state

	/*
	 * Select actions maximizing score within TP budget
	 * Handles weapon switch costs and usage limits
	 *
	 * @param pool Available actions to choose from
	 * @param maxTP Maximum TP to spend
	 * @param currentWeapon Currently equipped weapon
	 * @return Array of selected actions (caller should sort by priority for execution)
	 */
	static Array<Action> solve(Array<Action> pool, integer maxTP, Item? currentWeapon, Map<Item, integer>? prefixUses) {
		if (count(pool) == 0 || maxTP <= 0) return []

		// Build weapon index map
		ActionKnapsack.buildWeaponMap(pool, currentWeapon)
		integer numWeapons = count(ActionKnapsack.weaponList)

		// Expand actions (respecting maxUse, minus prefix uses)
		Array<KnapsackItem> items = ActionKnapsack.expandActions(pool, prefixUses)
		if (count(items) == 0) return []

		// Starting weapon index (-1 if no weapon or chip-only)
		integer startWeaponIdx = ActionKnapsack.CHIP
		if (currentWeapon != null && ActionKnapsack.weaponToIdx[currentWeapon!] != null) {
			startWeaponIdx = ActionKnapsack.weaponToIdx[currentWeapon!]!
		}

		// DP: dp[tp][w] = max score using exactly tp, with weapon w equipped
		// w = -1 means no weapon equipped yet (or only chips used)
		integer wStates = numWeapons + 1  // +1 for "no weapon" state
		integer wOffset = 1               // Index offset: actual idx = w + wOffset

		// dp[tp * wStates + (w + wOffset)] = score
		integer stateCount = (maxTP + 1) * wStates
		Array<real> dp = []

		for (integer i = 0; i < stateCount; i++) {
			push(dp, -999999.0)
		}

		// Initial state: 0 TP spent, starting weapon
		integer initState = 0 * wStates + (startWeaponIdx + wOffset)
		dp[initState] = 0.0

		// Save dp snapshot before each item for correct backtracking.
		// The 1D DP computes correct optimal values, but parent-pointer
		// backtracking can corrupt when later items overwrite intermediate
		// states. Snapshots allow item-by-item reconstruction instead.
		Array<Array<real>> snapshots = [clone(dp) as Array<real>]

		// Process each item
		for (integer itemIdx = 0; itemIdx < count(items); itemIdx++) {
			KnapsackItem ki = items[itemIdx]

			// Process in reverse TP order (0/1 knapsack style)
			for (integer tp = maxTP; tp >= 0; tp--) {
				for (integer w = -1; w < numWeapons; w++) {
					integer fromState = tp * wStates + (w + wOffset)
					if (dp[fromState] < -999998.0) continue  // Unreachable

					// Calculate actual cost
					integer cost = ki.baseCost
					integer newW = w

					if (ki.weaponIdx != ActionKnapsack.CHIP) {
						// It's a weapon action
						if (ki.weaponIdx != w) {
							cost += 1  // Switch cost
						}
						newW = ki.weaponIdx
					}
					// Chips don't change weapon state

					integer newTP = tp + cost
					if (newTP > maxTP) continue

					integer toState = newTP * wStates + (newW + wOffset)
					real newScore = dp[fromState] + ki.score

					if (newScore > dp[toState]) {
						dp[toState] = newScore
					}
				}
			}

			push(snapshots, clone(dp) as Array<real>)
		}

		// Find best final state
		integer bestState = -1
		real bestScore = -999999.0
		for (integer tp = 0; tp <= maxTP; tp++) {
			for (integer w = -1; w < numWeapons; w++) {
				integer state = tp * wStates + (w + wOffset)
				if (dp[state] > bestScore) {
					bestScore = dp[state]
					bestState = state
				}
			}
		}

		if (bestState == -1 || bestScore <= 0) return []

		// Backtrack using snapshots: compare dp before/after each item
		Array<Action> selected = []
		integer currentState = bestState

		for (integer i = count(items) - 1; i >= 0; i--) {
			// If dp value at currentState didn't change when item i was processed,
			// then item i was NOT used to reach this state
			if (snapshots[i + 1][currentState] <= snapshots[i][currentState] + 0.001) continue

			// Item i was used — find the source state
			push(selected, items[i].action)
			KnapsackItem ki = items[i]
			integer currentTP = currentState / wStates
			integer currentW = (currentState % wStates) - wOffset

			if (ki.weaponIdx == ActionKnapsack.CHIP) {
				// Chip: weapon unchanged, just subtract cost
				integer fromTP = currentTP - ki.baseCost
				currentState = fromTP * wStates + (currentW + wOffset)
			} else {
				// Weapon: try all possible previous weapon states
				for (integer prevW = -1; prevW < numWeapons; prevW++) {
					integer switchCost = (prevW != ki.weaponIdx) ? 1 : 0
					integer fromTP = currentTP - ki.baseCost - switchCost
					if (fromTP < 0) continue
					integer fromState = fromTP * wStates + (prevW + wOffset)
					if (snapshots[i][fromState] > -999998.0 &&
						abs(snapshots[i][fromState] + ki.score - snapshots[i + 1][currentState]) < 0.001) {
						currentState = fromState
						break
					}
				}
			}
		}

		return selected
	}

	/*
	 * Build weapon index mapping from action pool
	 */
	static void buildWeaponMap(Array<Action> pool, Item? currentWeapon) {
		ActionKnapsack.weaponList = []
		ActionKnapsack.weaponToIdx = [:]

		// Add current weapon first (index 0)
		if (currentWeapon != null && currentWeapon!.isWeap) {
			push(ActionKnapsack.weaponList, currentWeapon!)
			ActionKnapsack.weaponToIdx[currentWeapon!] = 0
		}

		// Add other weapons from pool
		for (Action a in pool) {
			if (a.item.isWeap && ActionKnapsack.weaponToIdx[a.item] == null) {
				ActionKnapsack.weaponToIdx[a.item] = count(ActionKnapsack.weaponList)
				push(ActionKnapsack.weaponList, a.item)
			}
		}
	}

	/*
	 * Expand actions respecting maxUse limits
	 * Each "virtual item" represents one use of an action
	 *
	 * For repeatable items (no cooldown, maxUse > 1), creates multiple virtual copies
	 * so the knapsack can optimize TP allocation. Example: Spark (maxUse=5) gets 5 copies,
	 * allowing knapsack to compare "4 Sparks vs 1 Meteorite".
	 *
	 * Note: All copies share the same static score. Dynamic changes (target dies) are
	 * handled by ComboBuilder.tryAddAction and greedy fallback.
	 */
	static Array<KnapsackItem> expandActions(Array<Action> pool, Map<Item, integer>? prefixUses) {
		Array<KnapsackItem> items = []
		Map<Item, integer> useCounts = [:]

		// Initialize with prefix uses (items already consumed before knapsack)
		if (prefixUses != null) {
			for (Item pi : integer pu in prefixUses!) {
				useCounts[pi] = pu
			}
		}

		// Sort by score descending (best uses first)
		pool = arraySort(pool, (Action a, Action b) => integer|real {
			return Sort.desc(a.score!, b.score!)
		}) as Array<Action>

		for (Action a in pool) {
			// Note: score > 0 filtering done upstream in MapCellScore
			Item item = a.item
			integer used = useCounts[item] != null ? useCounts[item]! : 0
			integer remaining = item.maxUse - used
			if (remaining <= 0) continue

			// Virtual copies for repeatable items (no cooldown, maxUse > 1)
			integer copies = 1
			if (!item.haveCD && item.maxUse > 1) {
				copies = remaining
			}

			integer weaponIdx = ActionKnapsack.CHIP
			if (item.isWeap) {
				weaponIdx = ActionKnapsack.weaponToIdx[item]!
			}

			// Create copies
			for (integer i = 0; i < copies; i++) {
				push(items, KnapsackItem(a, item.cost, a.score!, weaponIdx))
			}
			useCounts[item] = used + copies
		}

		return items
	}
}
