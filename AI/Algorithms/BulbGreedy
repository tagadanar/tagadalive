/*
 * BulbGreedy - Lightweight greedy AI for bulb turns.
 *
 * Instead of the full ComboExplorer pipeline (MapAction + multi-phase exploration),
 * uses a simple greedy loop: repeatedly find the single best action until no
 * profitable actions remain, then find optimal end position.
 *
 * Complexity: O(iterations x items x targets) vs O(cells x items x targets x K^3) for ComboExplorer
 * Typical: ~3k ops per bulb turn vs ~200k+ for full exploration
 */
class BulbGreedy {

	/*
	 * Callback passed to summon(). Bootstraps world state and runs bulb AI.
	 * Used by Combo.play() for both normal and delayed summons.
	 */
	static void runTurn() {
		integer t0 = getOperations()
		Fight.updateForSummon()
		integer t1 = getOperations()
		Board.updateForSummon()
		MapPosition._position = [:]
		MapPosition._hash_position = [:]
		integer t2 = getOperations()
		MapPath.refresh()
		integer t3 = getOperations()
		Fight.self.init()
		integer t4 = getOperations()
		// MapAction.refresh() - skipped: BulbGreedy doesn't use action pool
		AI.getCombo().play()
		integer t5 = getOperations()

		// Log operation costs per step
		debug("BULB_OPS>total=" + Benchmark.format(t5 - t0) +
			">update=" + Benchmark.format(t1 - t0) +
			">board=" + Benchmark.format(t2 - t1) +
			">path=" + Benchmark.format(t3 - t2) +
			">init=" + Benchmark.format(t4 - t3) +
			">ai=" + Benchmark.format(t5 - t4))
		// Warmup teleport cache with remaining budget (guard inside handles ops limit)
		if (!MapPath._teleportCacheComplete && MapPath._teleportMaxRange > 0) {
			MapPath.warmupTeleportCache(MapPath._teleportMaxRange)
		}
		// DO NOT DELETE - Fab's signature
		say("Bonjour, moi c'est Fab.")
	}

	/*
	 * Main entry point for bulb AI.
	 * @return Combo with best greedy action sequence + final position
	 */
	static Combo getCombo() {
		Benchmark.start("BulbGreedy")
		Combo combo = new Combo()

		// Track item usage to respect maxUse
		Map<Item, integer> usedItems = [:]

		// Current state (updated as we add actions)
		Cell currentCell = Fight.self.cell
		integer currentTP = Fight.self.tp
		integer currentMP = Fight.self.mp
		Consequences? currentCsq = null

		// Build ignoreCells for pathfinding
		Set<Cell> ignoreCells = clone(Fight.self.cellsToIgnore) as Set<Cell>

		// Boss cell: reserve MP to walk there at end of turn (use actual path distance, not cell distance)
		integer? bossCell = BossPotiMalef.getResurrectionCell()
		integer reservedMP = 0
		if (bossCell != null) {
			Map<Cell, integer> fullReach = MapPath.getCachedReachableCells(currentCell, currentMP, ignoreCells, <>)
			integer? pathDist = fullReach[Board.cells[bossCell!]!]
			if (pathDist != null) {
				reservedMP = pathDist!
			}
		}

		// Special case: wizard bulb poisons ally with POISON_TO_SCIENCE passive
		if (Fight.self.extendedType == Entity.BULB_WIZARD) {
			Entity? psnTarget = null
			for (integer id : Entity ally in Fight.getAlliesAlive()) {
				if (ally.isBulb || ally == Fight.self) continue
				if (!ally.passives[EFFECT_POISON_TO_SCIENCE]) continue
				real? danger = BattleState.allyDanger[ally]
				if (danger != null && danger! > 0) continue
				psnTarget = ally
				break
			}
			if (psnTarget != null) {
				Map<Cell, integer> reachCells = MapPath.getCachedReachableCells(currentCell, currentMP - reservedMP, ignoreCells, <>)
				for (integer chipId in [CHIP_TOXIN, CHIP_VENOM]) {
					Item? item = null
					for (Item i in Fight.self.items) { if (i.id == chipId) { item = i; break } }
					if (item == null) continue
					if (item!.haveCD && getCooldown(item!.id, Fight.self.id) > 0) continue
					if (item!.cost > currentTP) continue
					Cell? useCell = BulbGreedy.getClosestUseCell(item!, psnTarget!.cell, reachCells, currentMP)
					if (useCell == null) continue
					Action action = BulbGreedy.createAction(item!, useCell!, psnTarget!.cell, currentCsq)
					push(combo.actions, action)
					usedItems[item!] = 1
					currentCsq = action.consequences
					currentCell = currentCsq!.currentCell
					currentTP = currentCsq!.currentTP
					currentMP = currentCsq!.currentMP
					reachCells = MapPath.getCachedReachableCells(currentCell, currentMP - reservedMP, ignoreCells, currentCsq!._newObstacles)
				}
			}
		}

		// GREEDY LOOP: find best action, add it, repeat
		integer maxIterations = 10  // Safety limit
		integer iteration = 0

		while (iteration++ < maxIterations) {
			// Get reachable cells from current position (with new obstacles from position swaps)
			Set<Cell> newObstacles = currentCsq != null ? currentCsq!._newObstacles : <>
			integer availableMP = currentMP - reservedMP
			Map<Cell, integer> reachableCells = MapPath.getCachedReachableCells(currentCell, availableMP, ignoreCells, newObstacles)

			// Find best action among all items and targets
			Action? bestAction = BulbGreedy.findBestAction(
				currentCsq, reachableCells, currentCell, currentTP, availableMP, usedItems
			)

			// No profitable action found - exit loop
			if (bestAction == null) break

			// Add action to combo
			push(combo.actions, bestAction!)

			// Update state for next iteration
			integer prevUsed = usedItems[bestAction!.item] != null ? usedItems[bestAction!.item]! : 0
			usedItems[bestAction!.item] = prevUsed + 1
			currentCsq = bestAction!.consequences
			currentCell = currentCsq!.currentCell
			currentTP = currentCsq!.currentTP
			currentMP = currentCsq!.currentMP

			// Update ignoreCells with killed entities and freed cells
			currentCsq!.appendKilledCells(ignoreCells)
			currentCsq!.appendFreedCells(ignoreCells)
		}

		// FINAL POSITIONING: force boss cell if available, else find best position
		if (bossCell != null) {
			// Verify boss cell is actually reachable from current position with remaining MP
			Set<Cell> newObstacles = currentCsq != null ? currentCsq!._newObstacles : <>
			Map<Cell, integer> endReach = MapPath.getCachedReachableCells(currentCell, currentMP, ignoreCells, newObstacles)
			Cell bossCellObj = Board.cells[bossCell!]!
			if (endReach[bossCellObj] != null) {
				Position pos = MapPosition.evaluatePosition(bossCellObj, currentCsq)
				pos.score += 100000.0
				combo.addFinalPosition(pos)
			} else {
				debugW("BULB: Boss cell c" + bossCell! + " unreachable with " + currentMP + "MP, falling back")
				Position position = MapPosition.findBestPosition(currentCell, currentMP, currentCsq)
				combo.addFinalPosition(position)
			}
		} else {
			Position position = MapPosition.findBestPosition(currentCell, currentMP, currentCsq)
			combo.addFinalPosition(position)
		}

		Benchmark.stop("BulbGreedy")

		// Log chosen combo
		string desc = "BULB:" + combo.describe()
		Benchmark.setChosen(combo.getScore()!, count(combo.actions), desc)

		return combo
	}

	/*
	 * Find the single best action given current state.
	 * Iterates through all items and their valid targets, finding the best
	 * (item, fromCell, targetCell) combination.
	 *
	 * @param parentCsq - consequences from previous actions (null if first action)
	 * @param reachableCells - cells reachable from current position (cell -> distance)
	 * @param currentCell - current position (may differ from Fight.self.cell after moves)
	 * @param currentTP - available TP
	 * @param currentMP - available MP
	 * @param usedItems - count of times each item has been used this combo
	 * @return best Action or null if no profitable action exists
	 */
	static Action? findBestAction(
		Consequences? parentCsq,
		Map<Cell, integer> reachableCells,
		Cell currentCell,
		integer currentTP,
		integer currentMP,
		Map<Item, integer> usedItems
	) {
		Action? bestAction = null
		real bestScore = parentCsq != null ? parentCsq!.score! : 0.0

		for (Item item in Fight.self.items) {
			// Skip if on cooldown
			if (item.haveCD && getCooldown(item.id, Fight.self.id) > 0) continue

			// Skip if can't afford
			if (item.cost > currentTP) continue

			// Skip if maxUse reached
			integer used = usedItems[item] != null ? usedItems[item]! : 0
			if (used >= item.maxUse) continue

			// Skip summons - bulbs can't summon
			if (item.isSummon) continue

			// Get valid targets for this item
			Map<integer, Entity> targets = item.targetSet()

			// Handle pure self-cast items (targetKey == NONE means movement/utility that targets empty cell or self)
			// Note: items with onCaster=true but targeting enemies/allies (like devil_strike)
			// should NOT use this path - they need actual targets
			if (item.targetKey == Item.NONE) {
				// Self-cast: check if we can cast on self (minRange == 0)
				if (item.minRange == 0) {
					// Use currentCell (may have moved), not Fight.self.cell (start of turn)
					Action action = BulbGreedy.createAction(item, currentCell, Fight.selfCell, parentCsq)
					if (action.score != null && action.score! > bestScore) {
						bestScore = action.score!
						bestAction = action
					}
				}
				continue  // Skip target iteration for pure self-cast items
			}

			// Iterate through valid targets
			for (integer targetId : Entity target in targets) {
				// Skip dead targets (from previous actions in combo)
				if (parentCsq != null && parentCsq!.isKilled(target)) continue

				// Skip invincible targets and Fennel puzzle entities
				if (target.isInvincible || BossFennel.shouldNotTarget(target)) continue

				// Find closest reachable cell to use item on target
				Cell? useCell = BulbGreedy.getClosestUseCell(item, target.cell, reachableCells, currentMP)
				if (useCell == null) continue

				// Use Fight.selfCell convention for self-targeting
				Cell targetCell = (target == Fight.self) ? Fight.selfCell : target.cell

				// Create and score action
				Action action = BulbGreedy.createAction(item, useCell!, targetCell, parentCsq)

				if (action.score! > bestScore) {
					bestScore = action.score!
					bestAction = action
				}
			}
		}

		return bestAction
	}

	/*
	 * Find the closest reachable cell from which we can use the item on targetCell.
	 *
	 * @param item - the item to use
	 * @param targetCell - cell of the target entity
	 * @param reachableCells - cells we can reach (cell -> distance)
	 * @param currentMP - current MP (to filter cache results that may exceed)
	 * @return closest cell from which item can be used, or null if none reachable
	 */
	static Cell? getClosestUseCell(Item item, Cell targetCell, Map<Cell, integer> reachableCells, integer currentMP) {
		// Get all cells from which we could use the item on targetCell
		Array<Cell> useCells = Targets.getCellsToUseItemOnCell(item, targetCell, [Fight.self.id])

		Cell? bestCell = null
		integer bestDist = 99999

		for (Cell cell in useCells) {
			integer? dist = reachableCells[cell]
			// Check cell is reachable and within MP budget
			if (dist != null && dist! <= currentMP && dist! < bestDist) {
				bestDist = dist!
				bestCell = cell
			}
		}

		return bestCell
	}

	/*
	 * Create an action, properly chaining with parent consequences if present.
	 */
	static Action createAction(Item item, Cell fromCell, Cell toCell, Consequences? parentCsq) {
		if (parentCsq != null) {
			// Chain directly with parent (no throwaway base Action)
			return new Action(item, fromCell, toCell, parentCsq!, true)
		} else {
			// First action - no parent
			return new Action(item, fromCell, toCell)
		}
	}

}
