/*
 * CalibratedPTS - PTS with MP budget exploration
 *
 * Builds combos for each movement budget level (0, 1, 2, ..., maxMP)
 * Provides:
 * - Calibration curve: MP spent -> (actionScore, positionScore)
 * - Seeding combos for MCTS algorithms
 * - Estimated position value per MP
 *
 * This replaces the single PTS.buildCombo() call with a full exploration
 * of the action vs position tradeoff.
 */

/*
 * Calibration data point
 */
class CalibrationPoint {
	integer budgetRequested    // MP budget we asked for
	integer movementUsed       // Actual MP used for movement
	real actionScore           // Sum of action scores
	real positionScore         // Final position score
	real totalScore            // actionScore + positionScore
	Cell endCell               // Where combo ends
	Combo combo                // The actual combo

	constructor(integer budget, integer used, real actions, real position, Cell endCell, Combo combo) {
		this.budgetRequested = budget
		this.movementUsed = used
		this.actionScore = actions
		this.positionScore = position
		this.totalScore = actions + position
		this.endCell = endCell
		this.combo = combo
	}
}


class CalibratedPTS {
	// Calibration results
	static Array<CalibrationPoint> curve = []
	static real mpValue = 0.0  // Position value per MP saved
	static Combo? bestCombo = null
	static real bestScore = 0.0

	// Statistics
	static integer lastCalibrationPoints = 0
	static string lastBestBudget = ""

	/*
	 * Run full calibration: test each MP budget, find optimal tradeoff
	 */
	static void calibrate() {
		Benchmark.start("CalibratedPTS.calibrate")

		CalibratedPTS.curve = []
		CalibratedPTS.bestCombo = null
		CalibratedPTS.bestScore = -999999.0

		integer maxMP = Fight.self.mp

		for (integer budget = 0; budget <= maxMP; budget++) {
			CalibrationPoint? point = CalibratedPTS.buildWithBudget(budget)
			if (point != null) {
				push(CalibratedPTS.curve, point!)

				if (point!.totalScore > CalibratedPTS.bestScore) {
					CalibratedPTS.bestScore = point!.totalScore
					CalibratedPTS.bestCombo = point!.combo
					CalibratedPTS.lastBestBudget = "MP" + budget
				}
			}
		}

		CalibratedPTS.lastCalibrationPoints = count(CalibratedPTS.curve)
		CalibratedPTS.computeMPValue()

		// Log calibration results
		Benchmark.setPTS(CalibratedPTS.lastCalibrationPoints,
			CalibratedPTS.bestCombo != null ? count(CalibratedPTS.bestCombo!.actions) : 0,
			CalibratedPTS.bestScore)

		// Log calibration-specific stats
		Benchmark.setCalibration(CalibratedPTS.lastBestBudget, CalibratedPTS.mpValue,
			CalibratedPTS.lastCalibrationPoints)

		// Log top calibration combos for the Combos tab
		CalibratedPTS.logCalibrationCombos()

		Benchmark.stop("CalibratedPTS.calibrate")
	}

	/*
	 * Build best combo with given movement budget
	 */
	static CalibrationPoint? buildWithBudget(integer maxMovementMP) {
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]
		Map<Item, integer> cooldowns = [:]

		// MP to reserve for final positioning
		integer reserveMP = max(0, Fight.self.mp - maxMovementMP)

		Array<Opportunity> sorted = MapOpportunity.getSortedOpportunities()

		// Greedy combo building with movement constraint
		boolean foundAction = true
		while (foundAction) {
			foundAction = false

			// Get current state from combo's consequences (this is the source of truth)
			Consequences currentCsq = combo.getCurrentConsequences()
			Cell currentCell = currentCsq.currentCell

			// MP available for movement = actual MP minus reserve for positioning
			integer budgetForMove = max(0, currentCsq.currentMP - reserveMP)

			// Build ignoreCells: allies (from Fight.self) + killed entities (from simulation)
			Array<Cell> ignoreCells = clone(Fight.self.cellsToIgnore) as Array<Cell>
			for (Entity e : Entity _ in currentCsq._killed) {
				push(ignoreCells, e.cell)
			}

			// Compute reachable cells with actual budget and proper ignoreCells
			Map<Cell, integer> reachable = MapPath.getCachedReachableCells(currentCell, budgetForMove, ignoreCells)

			for (Opportunity opp in sorted) {
				// Standard checks (uses csq.currentWeapon for switch cost)
				if (!opp.canExecute(currentCsq.currentTP, usesThisTurn, cooldowns, currentCsq)) {
					continue
				}

				// Find cell within remaining movement budget
				Cell? execCell = CalibratedPTS.findCellWithinBudget(opp, reachable, currentCell, budgetForMove)
				if (execCell == null) continue

				// Get pre-computed action (avoids spurious warnings from Fight.self)
				Action? action = opp.attackActions[execCell!]
				if (action == null) continue

				if (count(combo.actions) == 0) {
					if (action!.score! <= 0) continue
					push(combo.actions, action!)
				} else {
					if (!combo.add(action!)) continue
				}

				usesThisTurn[opp.item] = (usesThisTurn[opp.item] != null ? usesThisTurn[opp.item]! : 0) + 1
				if (opp.item.haveCD) {
					cooldowns[opp.item] = opp.item.cdDuration
				}

				foundAction = true
				break
			}
		}

		// Get final state from consequences
		Consequences finalCsq = combo.getCurrentConsequences()
		Cell endCell = finalCsq.currentCell
		integer remainingMP = finalCsq.currentMP
		integer movementUsed = Fight.self.mp - remainingMP

		// Evaluate final position with actual remaining MP
		Position pos = MapPosition.findBestPosition(endCell, remainingMP, finalCsq)
		combo.addFinalPosition(pos)

		// Build calibration point
		real actionScore = 0.0
		for (Action a in combo.actions) {
			actionScore += a.score!
		}

		return CalibrationPoint(
			maxMovementMP,
			movementUsed,
			actionScore,
			pos.score,
			endCell,
			combo
		)
	}

	/*
	 * Find best cell for opportunity within reachable cells
	 * @param opp - the opportunity to check
	 * @param reachable - map of reachable cells with their MP costs
	 * @param currentCell - current position (for self-cast check)
	 * @param budget - max MP to spend on movement (cache may return superset)
	 */
	static Cell? findCellWithinBudget(Opportunity opp, Map<Cell, integer> reachable, Cell currentCell, integer budget) {
		if (opp.isSelfCast) return Fight.selfCell

		Cell? best = null
		real bestScore = -999999.0

		for (Cell cell : real score in opp.attackScores) {
			// Check if cell is reachable within budget (cache may return superset)
			if (cell != currentCell) {
				integer? dist = reachable[cell]
				if (dist == null || dist! > budget) continue
			}

			if (score > bestScore) {
				bestScore = score
				best = cell
			}
		}

		return best
	}

	/*
	 * Compute estimated position value per MP from calibration curve
	 */
	static void computeMPValue() {
		if (count(CalibratedPTS.curve) < 2) {
			CalibratedPTS.mpValue = 0.0
			return
		}

		// Compare endpoints: low movement vs high movement
		CalibrationPoint first = CalibratedPTS.curve[0]  // 0 movement budget
		CalibrationPoint last = CalibratedPTS.curve[count(CalibratedPTS.curve) - 1]  // max movement

		real positionDelta = first.positionScore - last.positionScore
		integer mpDelta = last.movementUsed - first.movementUsed

		if (mpDelta > 0) {
			CalibratedPTS.mpValue = positionDelta / mpDelta
		} else {
			CalibratedPTS.mpValue = 0.0
		}
	}

	/*
	 * Estimate position value for given remaining MP
	 * Used by MCTS algorithms to evaluate nodes without full position search
	 */
	static real estimatePositionValue(integer remainingMP) {
		integer mpUsed = Fight.self.mp - remainingMP

		// Find closest calibration point
		for (CalibrationPoint p in CalibratedPTS.curve) {
			if (p.movementUsed >= mpUsed) {
				return p.positionScore
			}
		}

		// Fallback: extrapolate using mpValue
		if (count(CalibratedPTS.curve) > 0) {
			CalibrationPoint last = CalibratedPTS.curve[count(CalibratedPTS.curve) - 1]
			integer extraMP = mpUsed - last.movementUsed
			return max(0.0, last.positionScore - extraMP * CalibratedPTS.mpValue)
		}

		return 0.0
	}

	/*
	 * Get all calibration combos for seeding MCTS
	 */
	static Array<Combo> getSeedingCombos() {
		Array<Combo> combos = []
		for (CalibrationPoint p in CalibratedPTS.curve) {
			if (count(p.combo.actions) > 0) {
				push(combos, p.combo)
			}
		}
		return combos
	}

	/*
	 * Get the best combo found during calibration
	 */
	static Combo getBestCombo() {
		if (CalibratedPTS.bestCombo != null) {
			return CalibratedPTS.bestCombo!
		}
		// Fallback: empty combo with position
		Combo fallback = Combo()
		fallback.addFinalPosition(MapPosition.findBestPosition(
			Fight.self.cell, Fight.self.mp, Consequences()))
		return fallback
	}

	/*
	 * Build description for debugging
	 */
	static string buildComboDesc(Combo combo) {
		string desc = ""
		for (Action a in combo.actions) {
			if (desc != "") desc += "->"
			desc += a.item.name + "(" + round(a.score!) + ")"
		}
		if (combo.finalPosition) {
			if (desc != "") desc += "->"
			desc += "mv(" + combo.finalPosition!.cell.id + ")"
		}
		if (desc == "") desc = "stay"
		return desc
	}

	/*
	 * Log calibration combos to Benchmark for the Combos tab
	 * Logs up to 5 best combos from different budgets
	 */
	static void logCalibrationCombos() {
		// Sort by total score descending, then by budget ascending (lower MP first when tied)
		Array<CalibrationPoint> sorted = arraySort(CalibratedPTS.curve, (CalibrationPoint a, CalibrationPoint b) => integer|real {
			if (a.totalScore != b.totalScore) return b.totalScore - a.totalScore
			return b.budgetRequested - a.budgetRequested
		}) as Array<CalibrationPoint>

		integer logged = 0
		for (CalibrationPoint p in sorted) {
			if (logged >= 5) break
			if (count(p.combo.actions) == 0 && p.positionScore <= 0) continue

			string desc = "CAL[MP" + p.budgetRequested + "]:" + CalibratedPTS.buildComboDesc(p.combo)
			Benchmark.addCombo(p.totalScore, count(p.combo.actions), desc, p.positionScore, p.actionScore)
			logged++
		}
	}
}
