/*
 * ComboBuilder - Unified combo construction
 *
 * Centralizes all combo-building logic to avoid duplication across phases.
 * All public methods take ExplorationContext as first parameter for:
 * - Initial resources (TP, MP, weapon)
 * - Reachability maps
 * - Cells to ignore in pathfinding
 *
 * Provides specialized methods for different exploration strategies:
 * - buildAtCell: Single cell, no MP buffs
 * - buildAtCellBuffed: Single cell with auto MP buffs
 * - buildForTarget: Kill focus with optional Liberation
 * - buildForAlly: Support focus
 * - buildAcrossCells: Multi-cell sequences
 *
 * All methods handle: knapsack selection, priority sorting, greedy fallback,
 * and final position calculation.
 */

class ComboBuilder {

	// ════════════════════════════════════════════════════════════
	// PUBLIC SPECIALIZED METHODS
	// ════════════════════════════════════════════════════════════

	/*
	 * Build combo at a single cell (no MP buffs needed).
	 * Used by: phaseStay, phaseSingleCell (1a)
	 *
	 * @param ctx Exploration context with initial resources
	 * @param cell Target cell to execute actions from
	 * @param reserveMP MP to reserve for defensive positioning
	 * @return Combo with actions + final position
	 */
	static Combo buildAtCell(ExplorationContext ctx, Cell cell, integer reserveMP) {
		Array<Action> pool = MapCellScore.getActionsForCell(cell)
		return ComboBuilder._buildCore(
			ctx,
			pool,
			ctx.initialTP,
			ctx.initialWeapon,
			reserveMP,
			null,   // stopWhenKilled
			true    // restrictToCell
		)
	}

	/*
	 * Build combo at an extended-range cell (requires MP buffs).
	 * Automatically calculates minimal MP buffs needed.
	 * Used by: phaseSingleCell (1b)
	 *
	 * @param ctx Exploration context with initial resources
	 * @param cell Target cell beyond normal MP range
	 * @param distanceToCell Distance from current position to cell
	 * @return Combo with buffs + actions + position, or null if unreachable
	 */
	static Combo? buildAtCellBuffed(ExplorationContext ctx, Cell cell, integer distanceToCell) {
		integer baseMP = ctx.initialMP

		if (distanceToCell <= baseMP) {
			// No buff needed, use regular method
			return ComboBuilder.buildAtCell(ctx, cell, 0)
		}

		integer neededBuff = distanceToCell - baseMP

		// Calculate minimal buffs
		Array<Action>? buffs = ComboBuilder._calculateMPBuffs(neededBuff, ctx.initialTP)
		if (buffs == null) return null

		// Start combo with buffs
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]
		ComboBuilder._applyBuffs(combo, buffs!, usesThisTurn)

		// Get state after buffs
		Consequences csq = combo.getCurrentConsequences()
		integer remainingTP = csq.currentTP
		Item? weapon = csq.currentWeapon

		// Reserve MP: buffedMP - distanceToCell
		integer reserveMP = csq.currentMP - distanceToCell

		// Get actions for target cell (exclude buffs already used)
		Array<Action> pool = MapCellScore.getActionsForCell(cell)
		pool = ComboBuilder._excludeUsed(pool, usesThisTurn)

		// Build rest of combo
		ComboBuilder._buildCoreInto(
			ctx,
			combo,
			usesThisTurn,
			pool,
			remainingTP,
			weapon,
			reserveMP,
			null,   // stopWhenKilled
			true    // restrictToCell
		)

		return combo
	}

	/*
	 * Build combo focused on killing a specific target.
	 * Optionally prepends Liberation to strip defenses.
	 * Stops adding target-specific actions when target dies, then expands to full pool.
	 * Used by: tryKillTarget
	 *
	 * @param ctx Exploration context with initial resources
	 * @param target Enemy to focus damage on
	 * @param liberation Optional Liberation chip to use first
	 * @param useMPBuff Whether to use MP buffs for extended reach
	 * @return Combo, or null if no useful actions found
	 */
	static Combo? buildForTarget(ExplorationContext ctx, Entity target, Item? liberation, boolean useMPBuff) {
		integer baseMP = ctx.initialMP
		integer baseTP = ctx.initialTP

		// Get all actions that can damage this target
		Array<Action> damageActions = MapCellScore.getActionsDamagingTarget(target)
		if (count(damageActions) == 0 && liberation == null) return null

		// Filter by reach (or calculate buffs)
		Array<Action> mpBuffActions = []
		if (useMPBuff && ctx.maxMPBuff > 0) {
			integer maxDist = ComboBuilder._getMaxDistNeeded(ctx, damageActions)
			if (maxDist > baseMP) {
				Array<Action>? buffs = ComboBuilder._calculateMPBuffs(maxDist - baseMP, baseTP)
				if (buffs == null) return null
				mpBuffActions = buffs!
			}
		} else {
			// Filter to current reach only
			damageActions = ComboBuilder._filterByReach(ctx, damageActions, false)
		}

		// Start combo
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		// Apply MP buffs first
		ComboBuilder._applyBuffs(combo, mpBuffActions, usesThisTurn)

		// Apply Liberation if provided
		if (liberation != null) {
			Consequences csq = combo.getCurrentConsequences()
			Action? libAction = ComboBuilder._findLiberationAction(ctx, liberation!, target, csq)
			if (libAction != null) {
				combo.add(libAction!)
				usesThisTurn[liberation!] = 1
			}
		}

		// Get state after buffs/liberation
		Consequences csq = combo.getCurrentConsequences()

		// Exclude buffs from damage pool
		damageActions = ComboBuilder._excludeUsed(damageActions, usesThisTurn)

		// Select with knapsack
		Array<Action> selected = ActionKnapsack.solve(damageActions, csq.currentTP, csq.currentWeapon)
		selected = MapCellScore.sortByPriority(selected)

		// Add selected actions (stop when target dies)
		for (Action action in selected) {
			if (combo.getCurrentConsequences().isKilled(target)) break
			ComboBuilder.tryAddAction(ctx, combo, action, usesThisTurn, 0)
		}

		// Greedy fallback with pool expansion on kill
		csq = combo.getCurrentConsequences()
		if (csq.currentTP > 0) {
			Array<Action> fallbackPool
			if (csq.isKilled(target)) {
				// Target dead -> expand to ALL actions
				fallbackPool = ComboBuilder._getAllActions()
			} else {
				// Target alive -> stick to damage actions
				fallbackPool = damageActions
			}
			fallbackPool = ComboBuilder._excludeUsed(fallbackPool, usesThisTurn)
			ComboBuilder._greedyFallback(ctx, combo, fallbackPool, usesThisTurn, false)
		}

		// Final position
		ComboBuilder._addFinalPosition(combo)

		return count(combo.actions) > 0 ? combo : null
	}

	/*
	 * Build combo focused on supporting a specific ally.
	 * Used by: trySupportAlly
	 *
	 * @param ctx Exploration context with initial resources
	 * @param ally Ally to focus support on
	 * @param useMPBuff Whether to use MP buffs for extended reach
	 * @return Combo, or null if no useful actions found
	 */
	static Combo? buildForAlly(ExplorationContext ctx, Entity ally, boolean useMPBuff) {
		integer baseMP = ctx.initialMP
		integer baseTP = ctx.initialTP

		// Get all actions that help this ally
		Array<Action> helpActions = MapCellScore.getActionsHelpingAlly(ally)
		if (count(helpActions) == 0) return null

		// Filter by reach (or calculate buffs)
		Array<Action> mpBuffActions = []
		if (useMPBuff && ctx.maxMPBuff > 0) {
			integer maxDist = ComboBuilder._getMaxDistNeeded(ctx, helpActions)
			if (maxDist > baseMP) {
				Array<Action>? buffs = ComboBuilder._calculateMPBuffs(maxDist - baseMP, baseTP)
				if (buffs == null) return null
				mpBuffActions = buffs!
			}
		} else {
			helpActions = ComboBuilder._filterByReach(ctx, helpActions, false)
		}

		// Start combo
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		// Apply MP buffs
		ComboBuilder._applyBuffs(combo, mpBuffActions, usesThisTurn)

		// Get state after buffs
		Consequences csq = combo.getCurrentConsequences()

		// Exclude buffs from help pool
		helpActions = ComboBuilder._excludeUsed(helpActions, usesThisTurn)

		// Build core
		ComboBuilder._buildCoreInto(
			ctx,
			combo,
			usesThisTurn,
			helpActions,
			csq.currentTP,
			csq.currentWeapon,
			0,      // reserveMP
			null,   // stopWhenKilled
			false   // restrictToCell
		)

		return count(combo.actions) > 0 ? combo : null
	}

	/*
	 * Build combo across multiple cells in sequence.
	 * Automatically partitions actions and calculates MP buffs if needed.
	 * Used by: tryPairOrder, tryTripletOrder
	 *
	 * @param ctx Exploration context with initial resources
	 * @param sequence Array of cells to visit in order
	 * @param useMPBuff Whether to use MP buffs for extended reach
	 * @return Combo, or null if path is unreachable
	 */
	static Combo? buildAcrossCells(ExplorationContext ctx, Array<Cell> sequence, boolean useMPBuff) {
		if (count(sequence) == 0) return null

		integer baseMP = ctx.initialMP
		integer baseTP = ctx.initialTP
		integer maxMPBuff = ctx.maxMPBuff
		Set<Cell> ignoreCells = clone(ctx.cellsToIgnore) as Set<Cell>

		// Calculate total distance needed
		integer totalDistance = ComboBuilder._calculatePathDistance(sequence, ignoreCells, baseMP + maxMPBuff)
		if (totalDistance < 0) return null  // Path impossible even with max buffs

		// Calculate needed buff
		integer neededBuff = max(0, totalDistance - baseMP)

		// Get minimal buffs if needed
		Array<Action> mpBuffActions = []
		integer effectiveTP = baseTP
		Item? effectiveWeapon = ctx.initialWeapon

		if (neededBuff > 0) {
			if (!useMPBuff) return null  // Need buffs but not allowed
			Array<Action>? buffs = ComboBuilder._calculateMPBuffs(neededBuff, baseTP)
			if (buffs == null) return null
			mpBuffActions = buffs!

			// Adjust effective TP/weapon
			for (Action buff in mpBuffActions) {
				effectiveTP -= buff.item.cost
				effectiveWeapon = buff.consequences.currentWeapon
			}
		}

		// Pool actions from all cells (deduplicated)
		Array<Action> combined = ComboBuilder._poolActionsFromCells(sequence, mpBuffActions)
		if (count(combined) == 0 && count(mpBuffActions) == 0) return null

		// Use knapsack
		Array<Action> selected = ActionKnapsack.solve(combined, effectiveTP, effectiveWeapon)
		if (count(selected) == 0 && count(mpBuffActions) == 0) return null

		// Partition by cell
		Map<Cell, Array<Action>> cellActionMap = ComboBuilder._partitionByCell(selected, sequence)

		// Prepend MP buffs to first cell
		Cell firstCell = sequence[0]
		for (integer i = count(mpBuffActions) - 1; i >= 0; i--) {
			unshift(cellActionMap[firstCell]!, mpBuffActions[i])
		}

		// Sort each cell's actions by priority
		for (Cell cell in sequence) {
			cellActionMap[cell] = MapCellScore.sortByPriority(cellActionMap[cell]!)
		}

		// Build combo following sequence
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		for (Cell cell in sequence) {
			Array<Action>? actions = cellActionMap[cell]
			if (actions == null) continue

			for (Action action in actions!) {
				ComboBuilder.tryAddAction(ctx, combo, action, usesThisTurn, 0)
			}
		}

		// Final position
		ComboBuilder._addFinalPosition(combo)

		return combo
	}

	/*
	 * Build combo with inversion as first-class strategy.
	 * Delegates to unified buildWithSwap.
	 */
	static Combo? buildWithInversion(ExplorationContext ctx, MovementCandidate candidate) {
		if (Fight.inversionItem == null) return null
		return ComboBuilder._buildWithSwap(ctx, candidate, true)
	}

	/*
	 * Build combo with repotting (swap with allied bulb) as first-class strategy.
	 * Delegates to unified buildWithSwap.
	 */
	static Combo? buildWithRepotting(ExplorationContext ctx, MovementCandidate candidate) {
		if (Fight.repottingItem == null) return null
		return ComboBuilder._buildWithSwap(ctx, candidate, false)
	}

	/*
	 * Unified swap combo builder for inversion and repotting.
	 * Follows buildAcrossCells pattern: select best cells, single knapsack, execute in path order.
	 *
	 * @param ctx Exploration context with initial resources
	 * @param candidate Movement candidate (swap type)
	 * @param useScoreBonus If true, add candidate.score and check threshold (inversion)
	 * @return Combo with swap, or null if not worthwhile
	 */
	static Combo? _buildWithSwap(ExplorationContext ctx, MovementCandidate candidate, boolean useScoreBonus) {
		Item swapItem = candidate.item
		Cell startCell = Fight.self.cell
		Cell castCell = candidate.fromCell
		Cell newSelfCell = candidate.selfNewCell  // Where we land after swap

		integer swapCost = swapItem.cost
		integer mpToCast = candidate.mpCost

		// Check basic feasibility
		if (ctx.initialTP < swapCost) return null

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 1: Calculate MP buffs and resources
		// ═══════════════════════════════════════════════════════════════════════════

		integer neededMPBuff = max(0, mpToCast - ctx.initialMP)
		Array<Action> mpBuffActions = []
		integer mpBuffTPCost = 0

		if (neededMPBuff > 0) {
			if (mpToCast > ctx.initialMP + ctx.maxMPBuff) return null
			Array<Action>? buffs = ComboBuilder._calculateMPBuffs(neededMPBuff, ctx.initialTP - swapCost)
			if (buffs == null) return null
			mpBuffActions = buffs!
			for (Action buff in mpBuffActions) {
				mpBuffTPCost += buff.item.cost
			}
		}

		integer totalAvailableTP = ctx.initialTP - mpBuffTPCost - swapCost
		integer postMP = ctx.initialMP + ComboBuilder._sumMPGain(mpBuffActions) - mpToCast

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 2: Select best cells with MP-valid path
		// ═══════════════════════════════════════════════════════════════════════════

		// For inversion: includeAllySupport based on target type
		// For repotting: never include ally support (target IS the ally bulb)
		boolean includeAllySupport = useScoreBonus && candidate.target.isFriend

		Array<Action> postPool = MapTactical.getPostSwapPool(
			candidate.target,
			candidate.selfNewCell,
			candidate.targetNewCell,
			candidate.item,
			postMP,
			includeAllySupport
		)

		// Group actions by fromCell and compute cell scores
		Map<Cell, Array<Action>> cellActions = [:]
		Map<Cell, real> cellScores = [:]
		Cell targetNewCell = castCell  // Swapped entity ends up here

		for (Action a in postPool) {
			Cell fromCell = a.from
			if (fromCell == Fight.selfCell) fromCell = newSelfCell
			if (cellActions[fromCell] == null) {
				cellActions[fromCell] = []
				cellScores[fromCell] = 0
			}
			push(cellActions[fromCell]!, a)
			if (a.score != null) cellScores[fromCell] += a.score!
		}

		// Sort cells by score descending
		Array<Cell> sortedCells = []
		for (Cell c : real score in cellScores) {
			push(sortedCells, c)
		}
		sortedCells = arraySort(sortedCells, (Cell a, Cell b) -> integer {
			return Sort.desc(cellScores[a]!, cellScores[b]!)
		}) as Array<Cell>

		// Compute reachability from newSelfCell
		Set<Cell> newObstacles = <targetNewCell>
		Map<Cell, integer> reachableFromNew = MapPath.getCachedReachableCells(
			newSelfCell, postMP, Fight.self.cellsToIgnore, newObstacles)

		// Get all valid cell sequences for the first valid pair (both orderings if both valid)
		Array<Array<Cell>> validSequences = ComboBuilder._getValidCellSequences(
			sortedCells, cellScores, newSelfCell, postMP, reachableFromNew, newObstacles)

		if (count(validSequences) == 0) {
			validSequences = [[newSelfCell]]
		}

		// Build combo for each valid sequence, keep the best
		Combo? bestCombo = null
		for (Array<Cell> selectedCells in validSequences) {
			Combo? combo = ComboBuilder._buildSwapComboForSequence(
				ctx, candidate, selectedCells, cellActions,
				mpBuffActions, totalAvailableTP,
				startCell, castCell, newSelfCell,
				swapItem, swapCost, mpToCast, useScoreBonus)

			if (combo != null) {
				if (bestCombo == null || combo!.getScore()! > bestCombo!.getScore()!) {
					bestCombo = combo
				}
			}
		}

		return bestCombo
	}

	/*
	 * Build swap combo for a specific cell sequence.
	 * Unified helper for inversion and repotting.
	 */
	static Combo? _buildSwapComboForSequence(
		ExplorationContext ctx,
		MovementCandidate candidate,
		Array<Cell> selectedCells,
		Map<Cell, Array<Action>> cellActions,
		Array<Action> mpBuffActions,
		integer totalAvailableTP,
		Cell startCell,
		Cell castCell,
		Cell newSelfCell,
		Item swapItem,
		integer swapCost,
		integer mpToCast,
		boolean useScoreBonus
	) {
		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 3: Pool actions from selected cells, single knapsack
		// ═══════════════════════════════════════════════════════════════════════════

		Array<Action> combinedPool = []
		Map<integer, boolean> seenKeys = [:]
		for (Cell cell in selectedCells) {
			Array<Action>? actions = cellActions[cell]
			if (actions == null) continue
			for (Action a in actions!) {
				integer key = ComboBuilder.actionKey(a)
				if (!seenKeys[key]) {
					push(combinedPool, a)
					seenKeys[key] = true
				}
			}
		}

		Array<Action> selectedPost = ActionKnapsack.solve(combinedPool, totalAvailableTP, ctx.initialWeapon)
		integer postTPUsed = ComboBuilder._sumTPCost(selectedPost, ctx.initialWeapon)

		// Pre-swap pool (actions at start cell)
		Array<Action> prePool = []
		Array<Action> startActions = MapCellScore.getActionsForCell(startCell)
		for (Action a in startActions) {
			if (a.score != null && a.score! > 0) {
				push(prePool, a)
			}
		}

		integer preTP = totalAvailableTP - postTPUsed
		Array<Action> selectedPre = []
		if (preTP > 0) {
			Map<Item, integer> postUsage = ComboBuilder._countUsage(selectedPost)
			Array<Action> filteredPre = ComboBuilder._filterByUsage(prePool, postUsage)
			selectedPre = ActionKnapsack.solve(filteredPre, preTP, ctx.initialWeapon)
		}

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 4: Partition selected actions back to cells
		// ═══════════════════════════════════════════════════════════════════════════

		Map<Cell, Array<Action>> partitioned = [:]
		for (Cell cell in selectedCells) {
			partitioned[cell] = []
		}

		for (Action a in selectedPost) {
			Cell fromCell = a.from
			if (fromCell == Fight.selfCell) fromCell = newSelfCell
			if (partitioned[fromCell] != null) {
				push(partitioned[fromCell]!, a)
			} else {
				push(partitioned[selectedCells[0]]!, a)
			}
		}

		for (Cell cell in selectedCells) {
			partitioned[cell] = MapCellScore.sortByPriority(partitioned[cell]!)
		}

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 5: Build combo in sequence order
		// ═══════════════════════════════════════════════════════════════════════════

		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		// 0. MP buffs first
		ComboBuilder._applyBuffs(combo, mpBuffActions, usesThisTurn)

		Consequences buffedCsq = combo.getCurrentConsequences()
		if (buffedCsq.currentMP < mpToCast) return null

		// 1. Pre-actions (sorted by priority)
		selectedPre = MapCellScore.sortByPriority(selectedPre)
		for (Action a in selectedPre) {
			ComboBuilder._tryAddActionWithReserve(combo, a, usesThisTurn, swapCost)
		}

		// 2. Swap action
		Consequences priorCsq = combo.getCurrentConsequences()
		if (priorCsq.currentMP < mpToCast) return null

		Action swapAction = Action(swapItem, castCell, candidate.targetCell)
		swapAction.movementCandidate = candidate

		Action actualizedSwap = Action(swapAction, priorCsq)

		// Score handling differs: inversion adds candidate.score, repotting doesn't
		if (useScoreBonus) {
			actualizedSwap.consequences.score += candidate.score
			actualizedSwap.score = actualizedSwap.consequences.getScore()
			if (actualizedSwap.score! <= priorCsq.score!) return null
		}

		push(combo.actions, actualizedSwap)
		usesThisTurn[swapItem] = 1

		// 3. Post-actions in sequence order
		for (Cell cell in selectedCells) {
			Array<Action>? actions = partitioned[cell]
			if (actions == null) continue

			for (Action a in actions!) {
				ComboBuilder._tryAddActionWithReserve(combo, a, usesThisTurn, 0)
			}
		}

		// Final position
		Consequences finalCsq = combo.getCurrentConsequences()
		Position pos = MapPosition.findBestPosition(finalCsq.currentCell, finalCsq.currentMP, finalCsq)
		combo.addFinalPosition(pos)

		return combo
	}

	/*
	 * Build combo with simple attract (grapple only) as first-class strategy.
	 * Delegates to unified _buildWithMove.
	 */
	static Combo? buildWithAttract(ExplorationContext ctx, MovementCandidate candidate) {
		if (Fight.grappleItem == null) return null
		return ComboBuilder._buildWithMove(ctx, candidate)
	}

	/*
	 * Build combo with simple push (boxing glove only) as first-class strategy.
	 * Delegates to unified _buildWithMove.
	 */
	static Combo? buildWithPush(ExplorationContext ctx, MovementCandidate candidate) {
		if (Fight.boxingGloveItem == null) return null
		return ComboBuilder._buildWithMove(ctx, candidate)
	}

	/*
	 * Unified move combo builder for attract (grapple) and push (boxing glove).
	 * Unlike swap, we stay at cast position - only target moves.
	 *
	 * Flow:
	 * 1. Calculate MP buffs to reach cast position
	 * 2. Execute: [buffs] → move action
	 * 3. Fill remaining TP with actions from post-move pool
	 * 4. Final positioning
	 *
	 * @param ctx Exploration context with initial resources
	 * @param candidate Movement candidate (attract or push type)
	 * @return Combo, or null if not feasible
	 */
	static Combo? _buildWithMove(ExplorationContext ctx, MovementCandidate candidate) {
		Item moveItem = candidate.item
		Cell castCell = candidate.fromCell  // Where we cast from (and stay)

		integer moveCost = moveItem.cost
		integer mpToCast = candidate.mpCost

		// Check basic feasibility
		if (ctx.initialTP < moveCost) return null

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 1: Calculate MP buffs
		// ═══════════════════════════════════════════════════════════════════════════

		integer neededMPBuff = max(0, mpToCast - ctx.initialMP)
		Array<Action> mpBuffActions = []
		integer mpBuffTPCost = 0

		if (neededMPBuff > 0) {
			if (mpToCast > ctx.initialMP + ctx.maxMPBuff) return null
			Array<Action>? buffs = ComboBuilder._calculateMPBuffs(neededMPBuff, ctx.initialTP - moveCost)
			if (buffs == null) return null
			mpBuffActions = buffs!
			for (Action buff in mpBuffActions) {
				mpBuffTPCost += buff.item.cost
			}
		}

		integer remainingTP = ctx.initialTP - mpBuffTPCost - moveCost
		integer remainingMP = ctx.initialMP + ComboBuilder._sumMPGain(mpBuffActions) - mpToCast

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 2: Get post-move pool
		// ═══════════════════════════════════════════════════════════════════════════

		Array<Action> postPool = MapTactical.getPostMovePool(
			candidate.target,
			candidate.selfNewCell,
			candidate.targetNewCell,
			candidate.item,
			remainingMP,
			candidate.target.isFriend
		)

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 3: Build combo
		// ═══════════════════════════════════════════════════════════════════════════

		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		// 0. MP buffs first
		ComboBuilder._applyBuffs(combo, mpBuffActions, usesThisTurn)

		// 1. Move action - target destination cell
		// LOS is validated in MapTactical candidate generation
		Consequences priorCsq = combo.getCurrentConsequences()
		Action moveAction = Action(moveItem, castCell, candidate.targetNewCell)
		moveAction.movementCandidate = candidate
		moveAction.overrideTargets = <candidate.target>

		Action actualizedMove = Action(moveAction, priorCsq)
		actualizedMove.consequences.score += candidate.score
		actualizedMove.score = actualizedMove.consequences.getScore()

		if (actualizedMove.score! <= priorCsq.score!) return null
		push(combo.actions, actualizedMove)
		usesThisTurn[moveItem] = 1

		// Update position: we moved to castCell
		Consequences postMoveCsq = combo.getCurrentConsequences()
		postMoveCsq.currentCell = castCell
		postMoveCsq.currentMP = remainingMP

		// 2. Post-move actions from pool
		Array<Action> selected = ActionKnapsack.solve(postPool, remainingTP, postMoveCsq.currentWeapon)
		selected = MapCellScore.sortByPriority(selected)
		for (Action a in selected) {
			ComboBuilder._tryAddActionWithReserve(combo, a, usesThisTurn, 0)
		}

		// Final position
		Consequences finalCsq = combo.getCurrentConsequences()
		Position pos = MapPosition.findBestPosition(finalCsq.currentCell, finalCsq.currentMP, finalCsq)
		combo.addFinalPosition(pos)

		return combo
	}

	/*
	 * Build combo with attract-push (grapple + boxing glove) as first-class strategy.
	 * Executes tactical sequence then fills remaining TP with actions.
	 *
	 * Flow:
	 * 1. Calculate MP buffs to reach grapple position
	 * 2. Execute: [buffs] → grapple → move to boxing position → boxing
	 * 3. Fill remaining TP with actions from final position
	 * 4. Final positioning
	 *
	 * @param ctx Exploration context with initial resources
	 * @param candidate AttractPush combo candidate
	 * @return Combo, or null if not feasible
	 */
	static Combo? buildWithAttractPush(ExplorationContext ctx, AttractPushCandidate candidate) {
		if (Fight.grappleItem == null || Fight.boxingGloveItem == null) return null

		Item grappleItem = candidate.grappleItem
		Item boxingItem = candidate.boxingItem

		integer comboTPCost = candidate.totalTP
		integer comboMPCost = candidate.totalMP

		// Check basic feasibility
		if (ctx.initialTP < comboTPCost) return null
		if (ctx.initialMP + ctx.maxMPBuff < comboMPCost) return null

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 1: Calculate MP buffs
		// ═══════════════════════════════════════════════════════════════════════════

		integer neededMPBuff = max(0, comboMPCost - ctx.initialMP)
		Array<Action> mpBuffActions = []
		integer mpBuffTPCost = 0

		if (neededMPBuff > 0) {
			Array<Action>? buffs = ComboBuilder._calculateMPBuffs(neededMPBuff, ctx.initialTP - comboTPCost)
			if (buffs == null) return null
			mpBuffActions = buffs!
			for (Action buff in mpBuffActions) {
				mpBuffTPCost += buff.item.cost
			}
		}

		integer remainingTP = ctx.initialTP - mpBuffTPCost - comboTPCost
		integer remainingMP = ctx.initialMP + ComboBuilder._sumMPGain(mpBuffActions) - comboMPCost

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 2: Build combo with tactical sequence
		// ═══════════════════════════════════════════════════════════════════════════

		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		// 0. MP buffs
		ComboBuilder._applyBuffs(combo, mpBuffActions, usesThisTurn)

		// 1. Grapple action - target destination cell (where enemy lands after pull)
		// LOS to enemy is validated in MapTactical candidate generation
		Consequences priorCsq = combo.getCurrentConsequences()
		Action grappleAction = Action(grappleItem, candidate.grappleFromCell, candidate.afterGrappleCell)
		// Create MovementCandidate for grapple (score=0, combo score goes on boxing)
		MovementCandidate grappleMC = MovementCandidate.forAttract(
			grappleItem, candidate.grappleFromCell, candidate.target,
			candidate.afterGrappleCell, 0, 0)  // MP already accounted, score on boxing
		grappleAction.movementCandidate = grappleMC
		grappleAction.overrideTargets = <candidate.target>

		Action actualizedGrapple = Action(grappleAction, priorCsq)
		push(combo.actions, actualizedGrapple)
		usesThisTurn[grappleItem] = 1

		// 2. Boxing action - target destination cell (where entity lands after push)
		// LOS to destination is validated in MapTactical candidate generation
		priorCsq = combo.getCurrentConsequences()
		// Update position: we moved from grappleFromCell to boxingFromCell (costs transitionMP)
		priorCsq.currentCell = candidate.boxingFromCell
		priorCsq.currentMP = remainingMP  // transitionMP already deducted in comboMPCost

		Action boxingAction = Action(boxingItem, candidate.boxingFromCell, candidate.finalCell)
		// Create MovementCandidate for boxing with the combo score
		MovementCandidate boxingMC = MovementCandidate.forPush(
			boxingItem, candidate.boxingFromCell, candidate.target,
			candidate.finalCell, 0, candidate.score)  // Full combo score here
		boxingAction.movementCandidate = boxingMC
		boxingAction.overrideTargets = <candidate.target>

		Action actualizedBoxing = Action(boxingAction, priorCsq)
		push(combo.actions, actualizedBoxing)
		usesThisTurn[boxingItem] = 1

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 3: Fill remaining TP with actions from final position
		// ═══════════════════════════════════════════════════════════════════════════

		// Use proper post-pool with simulated enemy position
		// After combo: we are at boxingFromCell, enemy is at finalCell
		Array<Action> postPool = MapTactical.getPostMovePool(
			candidate.target,
			candidate.boxingFromCell,  // where we are
			candidate.finalCell,       // where enemy ends up
			boxingItem,
			remainingMP,
			false  // enemy target, no ally support
		)

		// Knapsack and add
		Consequences postCsq = combo.getCurrentConsequences()
		if (remainingTP > 0 && count(postPool) > 0) {
			Array<Action> selected = ActionKnapsack.solve(postPool, remainingTP, postCsq.currentWeapon)
			selected = MapCellScore.sortByPriority(selected)
			for (Action a in selected) {
				ComboBuilder._tryAddActionWithReserve(combo, a, usesThisTurn, 0)
			}
		}

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 4: Final position
		// ═══════════════════════════════════════════════════════════════════════════

		Consequences finalCsq = combo.getCurrentConsequences()
		Position pos = MapPosition.findBestPosition(finalCsq.currentCell, finalCsq.currentMP, finalCsq)
		combo.addFinalPosition(pos)

		return combo
	}

	/*
	 * Build combo with pull-inversion-push (grapple + inversion + boxing) as first-class strategy.
	 * Executes 3-action tactical sequence then fills remaining TP.
	 *
	 * Flow:
	 * 1. Calculate MP buffs to reach grapple position
	 * 2. Execute: [buffs] → grapple → inversion → move 1 → boxing
	 * 3. Fill remaining TP with actions from final position
	 * 4. Final positioning
	 *
	 * @param ctx Exploration context with initial resources
	 * @param candidate PullInversionPush combo candidate
	 * @return Combo, or null if not feasible
	 */
	static Combo? buildWithPullInvPush(ExplorationContext ctx, PullInversionPushCandidate candidate) {
		if (Fight.grappleItem == null || Fight.inversionItem == null || Fight.boxingGloveItem == null) return null

		Item grappleItem = candidate.grappleItem
		Item inversionItem = candidate.inversionItem
		Item boxingItem = candidate.boxingItem

		integer comboTPCost = candidate.totalTP
		integer comboMPCost = candidate.totalMP

		// Check basic feasibility
		if (ctx.initialTP < comboTPCost) return null
		if (ctx.initialMP + ctx.maxMPBuff < comboMPCost) return null

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 1: Calculate MP buffs
		// ═══════════════════════════════════════════════════════════════════════════

		integer neededMPBuff = max(0, comboMPCost - ctx.initialMP)
		Array<Action> mpBuffActions = []
		integer mpBuffTPCost = 0

		if (neededMPBuff > 0) {
			Array<Action>? buffs = ComboBuilder._calculateMPBuffs(neededMPBuff, ctx.initialTP - comboTPCost)
			if (buffs == null) return null
			mpBuffActions = buffs!
			for (Action buff in mpBuffActions) {
				mpBuffTPCost += buff.item.cost
			}
		}

		integer remainingTP = ctx.initialTP - mpBuffTPCost - comboTPCost
		integer remainingMP = ctx.initialMP + ComboBuilder._sumMPGain(mpBuffActions) - comboMPCost

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 2: Build combo with tactical sequence
		// ═══════════════════════════════════════════════════════════════════════════

		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		// 0. MP buffs
		ComboBuilder._applyBuffs(combo, mpBuffActions, usesThisTurn)

		// 1. Grapple action - target destination cell (where enemy lands after pull)
		// LOS to enemy is validated in MapTactical candidate generation
		Consequences priorCsq = combo.getCurrentConsequences()
		Action grappleAction = Action(grappleItem, candidate.grappleFromCell, candidate.afterGrappleCell)
		// Create MovementCandidate for grapple (score=0, combo score goes on boxing)
		MovementCandidate grappleMC = MovementCandidate.forAttract(
			grappleItem, candidate.grappleFromCell, candidate.target,
			candidate.afterGrappleCell, 0, 0)
		grappleAction.movementCandidate = grappleMC
		grappleAction.overrideTargets = <candidate.target>

		Action actualizedGrapple = Action(grappleAction, priorCsq)
		push(combo.actions, actualizedGrapple)
		usesThisTurn[grappleItem] = 1

		// 2. Inversion action (swap with enemy at afterGrappleCell)
		priorCsq = combo.getCurrentConsequences()
		Action inversionAction = Action(inversionItem, candidate.grappleFromCell, candidate.afterGrappleCell)
		// Create MovementCandidate for inversion (score=0, combo score goes on boxing)
		MovementCandidate invMC = MovementCandidate.forInversion(
			inversionItem, candidate.grappleFromCell, candidate.target, 0, 0)
		inversionAction.movementCandidate = invMC
		inversionAction.overrideTargets = <candidate.target>

		Action actualizedInv = Action(inversionAction, priorCsq)
		push(combo.actions, actualizedInv)
		usesThisTurn[inversionItem] = 1

		// 3. Boxing action - target destination cell (where entity lands after push)
		// LOS to destination is validated in MapTactical candidate generation
		priorCsq = combo.getCurrentConsequences()
		// After inversion we're at afterGrappleCell, move 1 cell back to pushFromCell for minRange 2
		priorCsq.currentCell = candidate.pushFromCell
		priorCsq.currentMP = remainingMP  // transitionMP already deducted in comboMPCost

		Action boxingAction = Action(boxingItem, candidate.pushFromCell, candidate.finalCell)
		// Create MovementCandidate for boxing with the combo score
		MovementCandidate boxingMC = MovementCandidate.forPush(
			boxingItem, candidate.pushFromCell, candidate.target,
			candidate.finalCell, 0, candidate.score)  // Full combo score here
		boxingAction.movementCandidate = boxingMC
		boxingAction.overrideTargets = <candidate.target>

		Action actualizedBoxing = Action(boxingAction, priorCsq)
		push(combo.actions, actualizedBoxing)
		usesThisTurn[boxingItem] = 1

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 3: Fill remaining TP with actions from final position
		// ═══════════════════════════════════════════════════════════════════════════

		// Use proper post-pool with simulated enemy position
		// After combo: we are at pushFromCell, enemy is at finalCell
		Array<Action> postPool = MapTactical.getPostMovePool(
			candidate.target,
			candidate.pushFromCell,  // where we are
			candidate.finalCell,     // where enemy ends up
			boxingItem,
			remainingMP,
			false  // enemy target, no ally support
		)

		// Knapsack and add
		Consequences postCsq = combo.getCurrentConsequences()
		if (remainingTP > 0 && count(postPool) > 0) {
			Array<Action> selected = ActionKnapsack.solve(postPool, remainingTP, postCsq.currentWeapon)
			selected = MapCellScore.sortByPriority(selected)
			for (Action a in selected) {
				ComboBuilder._tryAddActionWithReserve(combo, a, usesThisTurn, 0)
			}
		}

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 4: Final position
		// ═══════════════════════════════════════════════════════════════════════════

		Consequences finalCsq = combo.getCurrentConsequences()
		Position pos = MapPosition.findBestPosition(finalCsq.currentCell, finalCsq.currentMP, finalCsq)
		combo.addFinalPosition(pos)

		return combo
	}

	/*
	 * Get all valid cell sequences for the first valid pair.
	 * Returns both orderings if both are MP-valid, otherwise just the valid one.
	 * Falls back to single cell if no pair works.
	 *
	 * @param sortedCells Cells sorted by score descending
	 * @param cellScores Score per cell
	 * @param newSelfCell Where we start after inversion
	 * @param availableMP MP available after inversion
	 * @param reachableFromNew Reachability map from newSelfCell
	 * @param obstacles Obstacles for pathfinding (swapped entity position)
	 * @return Array of valid cell sequences (1-2 sequences, each with 1-2 cells)
	 */
	static Array<Array<Cell>> _getValidCellSequences(
		Array<Cell> sortedCells,
		Map<Cell, real> cellScores,
		Cell newSelfCell,
		integer availableMP,
		Map<Cell, integer> reachableFromNew,
		Set<Cell> obstacles
	) {
		integer n = count(sortedCells)
		if (n == 0) return []

		// Try pairs: best+2nd, best+3rd, 2nd+3rd, etc.
		// For the first pair with at least one valid ordering, return all valid orderings
		for (integer i = 0; i < min(n, 5); i++) {
			for (integer j = i + 1; j < min(n, 5); j++) {
				Cell cellA = sortedCells[i]
				Cell cellB = sortedCells[j]

				// Check both orderings for this pair
				Array<Cell>? seqAB = ComboBuilder._tryPairOrder(
					cellA, cellB, newSelfCell, availableMP, reachableFromNew, obstacles)
				Array<Cell>? seqBA = ComboBuilder._tryPairOrder(
					cellB, cellA, newSelfCell, availableMP, reachableFromNew, obstacles)

				// If at least one ordering is valid, return all valid orderings for THIS pair
				if (seqAB != null || seqBA != null) {
					Array<Array<Cell>> result = []
					if (seqAB != null) push(result, seqAB!)
					if (seqBA != null) push(result, seqBA!)
					return result
				}
			}
		}

		// No valid pair - use single best reachable cell
		for (Cell cell in sortedCells) {
			if (cell == newSelfCell) return [[cell]]
			integer? dist = reachableFromNew[cell]
			if (dist != null && dist! <= availableMP) return [[cell]]
		}

		// Nothing reachable - just stay at newSelfCell
		return [[newSelfCell]]
	}

	/*
	 * Try a specific pair ordering: first -> second
	 * Returns the sequence if MP-valid, null otherwise.
	 */
	static Array<Cell>? _tryPairOrder(
		Cell first,
		Cell second,
		Cell newSelfCell,
		integer availableMP,
		Map<Cell, integer> reachableFromNew,
		Set<Cell> obstacles
	) {
		// Cost to reach first cell
		integer costToFirst = 0
		if (first != newSelfCell) {
			integer? dist = reachableFromNew[first]
			if (dist == null || dist! > availableMP) return null
			costToFirst = dist!
		}

		// MP remaining after reaching first cell
		integer mpAfterFirst = availableMP - costToFirst

		// Cost to reach second cell from first
		if (second == first) return [first]  // Same cell, just use single

		Map<Cell, integer> reachableFromFirst = MapPath.getCachedReachableCells(
			first, mpAfterFirst, Fight.self.cellsToIgnore, obstacles)

		integer? costToSecond = reachableFromFirst[second]
		if (costToSecond == null || costToSecond! > mpAfterFirst) return null

		// Valid path!
		return [first, second]
	}

	/*
	 * Sum TP cost of actions, accounting for weapon switches.
	 */
	static integer _sumTPCost(Array<Action> actions, Item? startWeapon) {
		integer total = 0
		Item? currentWeapon = startWeapon
		for (Action a in actions) {
			if (a.item.isWeap && a.item != currentWeapon) {
				total += 1  // Weapon switch cost
				currentWeapon = a.item
			}
			total += a.item.cost
		}
		return total
	}

	/*
	 * Sum MP gain from buff actions.
	 * Each buff action's consequences is computed independently (base + that buff's gain),
	 * so we sum individual gains (each is consequences.currentMP - baseMP).
	 */
	static integer _sumMPGain(Array<Action> buffs) {
		integer baseMP = Fight.self.mp
		integer totalGain = 0
		for (Action a in buffs) {
			totalGain += a.consequences.currentMP - baseMP
		}
		return totalGain
	}

	/*
	 * Count item usage in an action array.
	 */
	static Map<Item, integer> _countUsage(Array<Action> actions) {
		Map<Item, integer> usage = [:]
		for (Action a in actions) {
			integer count = usage[a.item] != null ? usage[a.item]! : 0
			usage[a.item] = count + 1
		}
		return usage
	}

	/*
	 * Filter actions by remaining usage (after some items already used).
	 */
	static Array<Action> _filterByUsage(Array<Action> pool, Map<Item, integer> usedCounts) {
		Array<Action> filtered = []
		Map<Item, integer> remaining = [:]
		for (Action a in pool) {
			integer used = usedCounts[a.item] != null ? usedCounts[a.item]! : 0
			integer seen = remaining[a.item] != null ? remaining[a.item]! : 0
			if (used + seen < a.item.maxUse) {
				push(filtered, a)
				remaining[a.item] = seen + 1
			}
		}
		return filtered
	}

	/*
	 * Sum scores of actions in an array.
	 */
	static real _sumActionScores(Array<Action> actions) {
		real total = 0
		for (Action a in actions) {
			if (a.score != null) total += a.score!
		}
		return total
	}

	/*
	 * Try to add action with reserved TP (for inversion actions that must leave room for inversion chip)
	 */
	static boolean _tryAddActionWithReserve(Combo combo, Action action, Map<Item, integer> usesThisTurn, integer reserveTP) {
		integer uses = usesThisTurn[action.item] != null ? usesThisTurn[action.item]! : 0
		if (uses >= action.item.maxUse) return false

		Consequences csq = combo.getCurrentConsequences()
		integer switchCost = (action.item.isWeap && action.item != csq.currentWeapon) ? 1 : 0
		// Check we have enough TP for action + reserved TP (for inversion)
		if (csq.currentTP < action.item.cost + switchCost + reserveTP) return false

		// Check reachability (like _tryAddActionImpl)
		if (action.from != Fight.selfCell && action.from != csq.currentCell) {
			Set<Cell> ignoreCells = clone(Fight.self.cellsToIgnore) as Set<Cell>
			csq.appendKilledCells(ignoreCells)
			csq.appendFreedCells(ignoreCells)
			Map<Cell, integer> reachable = MapPath.getCachedReachableCells(
				csq.currentCell, csq.currentMP, ignoreCells, csq._newObstacles)
			if (reachable[action.from] == null || reachable[action.from]! > csq.currentMP) return false
		}

		boolean added = combo.add(action)
		if (added) {
			usesThisTurn[action.item] = uses + 1
		}
		return added
	}

	// ════════════════════════════════════════════════════════════
	// PRIVATE CORE METHODS
	// ════════════════════════════════════════════════════════════

	/*
	 * Core combo building: knapsack -> sort -> add -> greedy -> position.
	 * Creates a new combo from scratch.
	 */
	static Combo _buildCore(
		ExplorationContext ctx,
		Array<Action> pool,
		integer availableTP,
		Item? currentWeapon,
		integer reserveMP,
		Entity? stopWhenKilled,
		boolean restrictToCell
	) {
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		ComboBuilder._buildCoreInto(
			ctx, combo, usesThisTurn, pool, availableTP, currentWeapon,
			reserveMP, stopWhenKilled, restrictToCell
		)

		return combo
	}

	/*
	 * Core combo building into an existing combo.
	 * Allows prepending buffs/liberation before core logic.
	 */
	static void _buildCoreInto(
		ExplorationContext ctx,
		Combo combo,
		Map<Item, integer> usesThisTurn,
		Array<Action> pool,
		integer availableTP,
		Item? currentWeapon,
		integer reserveMP,
		Entity? stopWhenKilled,
		boolean restrictToCell
	) {
		// Knapsack selection
		Array<Action> selected = ActionKnapsack.solve(pool, availableTP, currentWeapon)
		selected = MapCellScore.sortByPriority(selected)

		// Add selected actions
		for (Action action in selected) {
			if (stopWhenKilled != null && combo.getCurrentConsequences().isKilled(stopWhenKilled!)) break

			boolean added = ComboBuilder.tryAddAction(ctx, combo, action, usesThisTurn, reserveMP)

			// If summon was added, expand pool with bulb buff actions
			if (added && action.item.isSummon) {
				ComboBuilder._expandWithBulbBuffs(ctx, combo, action.to, usesThisTurn, reserveMP)
			}
		}

		// Greedy fallback
		Consequences csq = combo.getCurrentConsequences()
		if (csq.currentTP > 0) {
			Array<Action> remaining = ComboBuilder._excludeUsed(pool, usesThisTurn)
			ComboBuilder._greedyFallback(ctx, combo, remaining, usesThisTurn, restrictToCell)
		}

		// Final position
		ComboBuilder._addFinalPosition(combo)
	}

	/*
	 * Expand combo with buff actions for a newly summoned bulb.
	 * Called after a summon action is successfully added.
	 */
	static void _expandWithBulbBuffs(
		ExplorationContext ctx,
		Combo combo,
		Cell bulbCell,
		Map<Item, integer> usesThisTurn,
		integer reserveMP
	) {
		Consequences csq = combo.getCurrentConsequences()

		// Check if a pendingBulb exists at this cell
		if (csq.pendingBulbs[bulbCell] == null) return;

		// Build ignoreCells: base + killed entities
		Set<Cell> ignoreCells = ComboBuilder.buildIgnoreCells(ctx, csq)

		// Generate buff actions for the newly created pendingBulb
		Array<Action> buffActions = MapAction.getBulbBuffActions(
			bulbCell,
			csq.currentCell,
			csq.currentMP,
			csq.currentTP,
			usesThisTurn,
			ignoreCells
		)

		if (count(buffActions) == 0) return;

		// Sort by score (greedy selection of best buffs)
		buffActions = MapCellScore.sortByScore(buffActions)

		// Try each buff
		for (Action buffAction in buffActions) {
			ComboBuilder.tryAddAction(ctx, combo, buffAction, usesThisTurn, reserveMP)
		}
	}


	/*
	 * Apply MP buff actions to combo.
	 */
	static void _applyBuffs(Combo combo, Array<Action> buffs, Map<Item, integer> usesThisTurn) {
		for (Action buff in buffs) {
			combo.add(buff)
			usesThisTurn[buff.item] = 1
		}
	}

	/*
	 * Greedy fallback: fill remaining TP from pool.
	 * Loops on repeatable items until maxUse reached.
	 */
	static void _greedyFallback(
		ExplorationContext ctx,
		Combo combo,
		Array<Action> pool,
		Map<Item, integer> usesThisTurn,
		boolean restrictToCell
	) {
		// Filter if restricting to cell
		Array<Action> filtered = []
		Consequences csq = combo.getCurrentConsequences()

		for (Action a in pool) {
			if (a.score <= 0) continue
			if (restrictToCell && a.from != Fight.selfCell && a.from != csq.currentCell) continue
			push(filtered, a)
		}

		// Sort by score for greedy fill
		filtered = MapCellScore.sortByScore(filtered)

		// Try to fill - loop on each action until it fails
		for (Action action in filtered) {
			boolean added = ComboBuilder.tryAddAction(ctx, combo, action, usesThisTurn, 0)

			// If summon was added, expand with bulb buff actions
			if (added && action.item.isSummon) {
				ComboBuilder._expandWithBulbBuffs(ctx, combo, action.to, usesThisTurn, 0)
			}

			// Continue looping for repeatable items
			while (added && ComboBuilder.tryAddAction(ctx, combo, action, usesThisTurn, 0)) {}
		}
	}

	/*
	 * Add final position to combo.
	 */
	static void _addFinalPosition(Combo combo) {
		Consequences csq = combo.getCurrentConsequences()
		Position pos = MapPosition.findBestPosition(csq.currentCell, csq.currentMP, csq)
		combo.addFinalPosition(pos)
	}

	// ════════════════════════════════════════════════════════════
	// PRIVATE HELPERS
	// ════════════════════════════════════════════════════════════

	/*
	 * Filter actions to only those reachable with current/extended MP.
	 */
	static Array<Action> _filterByReach(ExplorationContext ctx, Array<Action> actions, boolean useExtended) {
		integer baseMP = ctx.initialMP
		integer maxReach = useExtended ? baseMP + ctx.maxMPBuff : baseMP
		Map<Cell, integer> reachable = useExtended
			? ctx.extendedReachableCells
			: ctx.reachableCells

		Array<Action> filtered = []
		for (Action a in actions) {
			if (a.from == Fight.selfCell) {
				push(filtered, a)
			} else {
				integer? dist = reachable[a.from]
				if (dist != null && dist! <= maxReach) {
					push(filtered, a)
				}
			}
		}
		return filtered
	}

	/*
	 * Find maximum distance needed to reach any action's from-cell.
	 */
	static integer _getMaxDistNeeded(ExplorationContext ctx, Array<Action> actions) {
		integer maxDist = 0
		Map<Cell, integer> reachable = ctx.extendedReachableCells

		for (Action a in actions) {
			if (a.from == Fight.selfCell) continue
			integer? dist = reachable[a.from]
			if (dist != null && dist! > maxDist) {
				maxDist = dist!
			}
		}
		return maxDist
	}

	/*
	 * Calculate minimal MP buffs needed for given extra MP.
	 * Greedy by efficiency (MP/TP).
	 * Returns null if impossible.
	 * Note: Uses Fight.self.effects to check active buffs (entity state, not context).
	 */
	static Array<Action>? _calculateMPBuffs(integer neededMP, integer availableTP) {
		if (neededMP <= 0) return []

		// Build set of already-active MP buff chips
		Map<integer, boolean> activeBuffChips = [:]
		for (EntityEffect e in Fight.self.effects) {
			if (e.type == EFFECT_BUFF_MP || e.type == EFFECT_RAW_BUFF_MP) {
				activeBuffChips[e.item.id] = true
			}
		}

		// Collect MP buff actions directly from entity items (not selfCastActions)
		// This matches computeMaxMPBuff() logic to avoid mismatch
		Array<Action> allBuffs = []
		real sncMultiplier = 1 + Fight.self.snc / 100.0

		for (Item item in Fight.self.items) {
			// Skip if not self-castable
			if (item.minRange > 0) continue
			// Skip if on cooldown
			if (item.haveCD && getCooldown(item.id, Fight.self.id) > 0) continue
			// Skip if can't afford
			if (item.cost > availableTP) continue
			// Skip if already active
			if (activeBuffChips[item.id]) continue

			// Check for MP buff effect and compute gain
			integer mpGain = 0
			for (ItemEffect effect in item.effects) {
				if (effect.type == EFFECT_RAW_BUFF_MP) {
					mpGain = round(effect.avg)
					break
				} else if (effect.type == EFFECT_BUFF_MP) {
					mpGain = round(effect.avg * sncMultiplier)
					break
				}
			}
			if (mpGain <= 0) continue

			// Create self-cast action for this buff
			Action buffAction = Action(item, Fight.selfCell, Fight.selfCell)
			push(allBuffs, buffAction)
		}

		if (count(allBuffs) == 0) return null

		// Sort by efficiency (MP gain / TP cost) descending
		integer baseMP = Fight.self.mp
		allBuffs = arraySort(allBuffs, (Action a, Action b) => integer|real {
			integer gainA = a.consequences.currentMP - baseMP
			integer gainB = b.consequences.currentMP - baseMP
			real effA = gainA / a.item.cost
			real effB = gainB / b.item.cost
			return Sort.desc(effA, effB)
		}) as Array<Action>

		// Greedy selection
		Array<Action> selected = []
		integer totalGain = 0
		integer tpSpent = 0

		for (Action a in allBuffs) {
			if (totalGain >= neededMP) break
			if (tpSpent + a.item.cost > availableTP) continue

			integer gain = a.consequences.currentMP - baseMP
			push(selected, a)
			totalGain += gain
			tpSpent += a.item.cost
		}

		return totalGain >= neededMP ? selected : null
	}

	/*
	 * Calculate total path distance for a sequence of cells.
	 * Returns -1 if any leg is unreachable.
	 */
	static integer _calculatePathDistance(Array<Cell> sequence, Set<Cell> ignoreCells, integer maxMP) {
		if (count(sequence) == 0) return 0

		integer totalDist = 0
		Cell current = Fight.self.cell
		integer remainingMP = maxMP

		for (Cell target in sequence) {
			Map<Cell, integer> reachable
			if (current == Fight.self.cell) {
				reachable = Fight.self.extendedReachableCells
			} else {
				reachable = MapPath.getCachedReachableCells(current, remainingMP, ignoreCells)
			}

			integer? dist = reachable[target]
			if (dist == null) return -1  // Unreachable

			totalDist += dist!
			remainingMP -= dist!
			if (remainingMP < 0) return -1
			current = target
		}

		return totalDist
	}

	/*
	 * Pool actions from multiple cells, deduplicated.
	 */
	static Array<Action> _poolActionsFromCells(Array<Cell> cells, Array<Action> excludeBuffs) {
		Array<Action> combined = []
		Map<integer, boolean> seen = [:]

		// Build exclude set
		Map<integer, boolean> excludeKeys = [:]
		for (Action buff in excludeBuffs) {
			excludeKeys[ComboBuilder.actionKey(buff)] = true
		}

		for (Cell cell in cells) {
			Array<Action> cellActions = MapCellScore.getActionsForCell(cell)
			for (Action a in cellActions) {
				integer key = ComboBuilder.actionKey(a)
				if (excludeKeys[key]) continue
				if (!seen[key]) {
					push(combined, a)
					seen[key] = true
				}
			}
		}

		return combined
	}

	/*
	 * Partition actions by their from-cell.
	 */
	static Map<Cell, Array<Action>> _partitionByCell(Array<Action> actions, Array<Cell> cells) {
		Map<Cell, Array<Action>> result = [:]

		// Initialize empty arrays for each cell
		for (Cell cell in cells) {
			result[cell] = []
		}

		Cell firstCell = cells[0]

		for (Action action in actions) {
			if (action.from == Fight.selfCell) {
				// Self-cast goes to first cell
				push(result[firstCell]!, action)
			} else if (result[action.from] != null) {
				push(result[action.from]!, action)
			}
			// Actions from other cells are skipped (shouldn't happen)
		}

		return result
	}

	/*
	 * Get ALL actions from all cells (for fallback expansion).
	 * Note: cellActions and selfCastActions are already filtered (score > 0)
	 * in MapCellScore.refresh(), so no need to re-check here.
	 */
	static Array<Action> _getAllActions() {
		Array<Action> all = []

		for (Cell cell : Array<Action> actions in MapCellScore.cellActions) {
			for (Action a in actions) {
				push(all, a)
			}
		}

		// Add self-cast
		for (Action a in MapCellScore.selfCastActions) {
			push(all, a)
		}

		return all
	}

	/*
	 * Exclude already-used items from pool.
	 */
	static Array<Action> _excludeUsed(Array<Action> pool, Map<Item, integer> usesThisTurn) {
		Array<Action> filtered = []
		for (Action a in pool) {
			integer uses = usesThisTurn[a.item] != null ? usesThisTurn[a.item]! : 0
			if (uses < a.item.maxUse) {
				push(filtered, a)
			}
		}
		return filtered
	}

	/*
	 * Find Liberation action targeting specific entity.
	 */
	static Action? _findLiberationAction(ExplorationContext ctx, Item liberationItem, Entity target, Consequences csq) {
		Map<Cell, Map<Item, Action>> bestActions = MapAction.getMapBestAction()

		for (Cell cell : Map<Item, Action> itemActions in bestActions) {
			Action? action = itemActions[liberationItem]
			if (action == null) continue

			if (action!.to != target.cell) continue

			// Check reachability (cache may have cells beyond MP, must verify distance)
			if (action!.from != Fight.selfCell) {
				Set<Cell> ignoreCells = ComboBuilder.buildIgnoreCells(ctx, csq)
				Map<Cell, integer> reachable = MapPath.getCachedReachableCells(
					csq.currentCell, csq.currentMP, ignoreCells, csq._newObstacles)
				integer? dist = reachable[action!.from]
				if (dist == null || dist! > csq.currentMP) continue
			}

			return action
		}
		return null
	}

	// ════════════════════════════════════════════════════════════
	// PUBLIC HELPERS (used by other modules)
	// ════════════════════════════════════════════════════════════

	/*
	 * Build ignoreCells array for pathfinding: base cells + killed entities + freed cells
	 */
	static Set<Cell> buildIgnoreCells(ExplorationContext ctx, Consequences csq) {
		Set<Cell> ignoreCells = clone(ctx.cellsToIgnore) as Set<Cell>
		csq.appendKilledCells(ignoreCells)
		csq.appendFreedCells(ignoreCells)
		return ignoreCells
	}

	/*
	 * Try to add an action to a combo, checking all preconditions.
	 * Handles: usage limits, TP cost, weapon switch, reachability with reserveMP.
	 * Updates usesThisTurn map if action was added.
	 *
	 * @param ctx Exploration context with initial resources
	 * @param combo The combo to add to
	 * @param action The action to try adding
	 * @param usesThisTurn Map tracking item usage counts this turn
	 * @param reserveMP MP to reserve for defense (subtracted from available MP)
	 * @return true if action was added, false otherwise
	 */
	static boolean tryAddAction(ExplorationContext ctx, Combo combo, Action action, Map<Item, integer> usesThisTurn, integer reserveMP) {
		return ComboBuilder._tryAddActionImpl(combo, action, usesThisTurn, reserveMP, ctx.cellsToIgnore)
	}

	/*
	 * Try to add an action to a combo (without exploration context).
	 * For use by external modules like MapSummon that build combos outside exploration.
	 * Uses Fight.self.cellsToIgnore for pathfinding.
	 */
	static boolean tryAddAction(Combo combo, Action action, Map<Item, integer> usesThisTurn, integer reserveMP) {
		return ComboBuilder._tryAddActionImpl(combo, action, usesThisTurn, reserveMP, Fight.self.cellsToIgnore)
	}

	/*
	 * Internal implementation of tryAddAction.
	 */
	static boolean _tryAddActionImpl(Combo combo, Action action, Map<Item, integer> usesThisTurn, integer reserveMP, Set<Cell> baseCellsToIgnore) {
		// Check usage limit
		integer uses = usesThisTurn[action.item] != null ? usesThisTurn[action.item]! : 0
		if (uses >= action.item.maxUse) return false

		// Get current state
		Consequences csq = combo.getCurrentConsequences()

		// Check if action was invalidated by inversion (targets moved)
		if (csq.invalidatedActions != null && setContains(csq.invalidatedActions!, action)) return false

		// Check TP (including weapon switch cost)
		integer switchCost = (action.item.isWeap && action.item != csq.currentWeapon) ? 1 : 0
		if (csq.currentTP < action.item.cost + switchCost) return false

		// Check reachability
		if (action.from != Fight.selfCell) {
			// Build ignore cells: base + killed entities + freed cells (COW-aware)
			Set<Cell> ignoreCells = clone(baseCellsToIgnore) as Set<Cell>
			csq.appendKilledCells(ignoreCells)
			csq.appendFreedCells(ignoreCells)
			integer effectiveMP = max(0, csq.currentMP - reserveMP)
			Map<Cell, integer> reachable = MapPath.getCachedReachableCells(
				csq.currentCell, effectiveMP, ignoreCells, csq._newObstacles)
			if (reachable[action.from] == null || reachable[action.from]! > effectiveMP) return false
		}

		// Try to add
		boolean added = combo.add(action)
		if (added) {
			usesThisTurn[action.item] = uses + 1
		}
		return added
	}

	/*
	 * Unique key for action (for deduplication)
	 */
	static integer actionKey(Action a) {
		return a.item.id * 10000000 + a.from.id * 10000 + a.to.id
	}
}
