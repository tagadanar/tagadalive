/*
 * ComboBuilder - Unified combo construction
 *
 * Centralizes all combo-building logic to avoid duplication across phases.
 * All public methods take ExplorationContext as first parameter for:
 * - Initial resources (TP, MP, weapon)
 * - Reachability maps
 * - Cells to ignore in pathfinding
 *
 * Provides specialized methods for different exploration strategies:
 * - buildAtCell: Single cell, no MP buffs
 * - buildAtCellBuffed: Single cell with auto MP buffs
 * - buildForTarget: Kill focus with optional Liberation
 * - buildForAlly: Support focus
 * - buildAcrossCells: Multi-cell sequences
 *
 * All methods handle: knapsack selection, priority sorting, greedy fallback,
 * and final position calculation.
 */

class ComboBuilder {

	// ════════════════════════════════════════════════════════════
	// PUBLIC SPECIALIZED METHODS
	// ════════════════════════════════════════════════════════════

	/*
	 * Build combo at a single cell (no MP buffs needed).
	 * Used by: phaseStay, phaseSingleCell (1a)
	 *
	 * @param ctx Exploration context with initial resources
	 * @param cell Target cell to execute actions from
	 * @param reserveMP MP to reserve for defensive positioning
	 * @return Combo with actions + final position
	 */
	static Combo buildAtCell(ExplorationContext ctx, Cell cell, integer reserveMP) {
		Array<Action> pool = MapCellScore.getActionsForCell(cell)
		return ComboBuilder._buildCore(
			ctx,
			pool,
			ctx.initialTP,
			ctx.initialWeapon,
			reserveMP,
			null,   // stopWhenKilled
			true    // restrictToCell
		)
	}

	/*
	 * Build combo at an extended-range cell (requires MP buffs).
	 * Automatically calculates minimal MP buffs needed.
	 * Used by: phaseSingleCell (1b)
	 *
	 * @param ctx Exploration context with initial resources
	 * @param cell Target cell beyond normal MP range
	 * @param distanceToCell Distance from current position to cell
	 * @return Combo with buffs + actions + position, or null if unreachable
	 */
	static Combo? buildAtCellBuffed(ExplorationContext ctx, Cell cell, integer distanceToCell) {
		integer baseMP = ctx.initialMP

		if (distanceToCell <= baseMP) {
			// No buff needed, use regular method
			return ComboBuilder.buildAtCell(ctx, cell, 0)
		}

		integer neededBuff = distanceToCell - baseMP

		// Calculate minimal buffs
		Array<Action>? buffs = ComboBuilder._calculateMPBuffs(neededBuff, ctx.initialTP)
		if (buffs == null) return null

		// Start combo with buffs
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]
		ComboBuilder._applyBuffs(combo, buffs!, usesThisTurn)

		// Get state after buffs
		Consequences csq = combo.getCurrentConsequences()
		integer remainingTP = csq.currentTP
		Item? weapon = csq.currentWeapon

		// Reserve MP: buffedMP - distanceToCell
		integer reserveMP = csq.currentMP - distanceToCell

		// Get actions for target cell (exclude buffs already used)
		Array<Action> pool = MapCellScore.getActionsForCell(cell)
		pool = ComboBuilder._excludeUsed(pool, usesThisTurn)

		// Build rest of combo
		ComboBuilder._buildCoreInto(
			ctx,
			combo,
			usesThisTurn,
			pool,
			remainingTP,
			weapon,
			reserveMP,
			null,   // stopWhenKilled
			true    // restrictToCell
		)

		return combo
	}

	/*
	 * Build combo focused on killing a specific target.
	 * Optionally prepends Liberation to strip defenses.
	 * Stops adding target-specific actions when target dies, then expands to full pool.
	 * Used by: tryKillTarget
	 *
	 * @param ctx Exploration context with initial resources
	 * @param target Enemy to focus damage on
	 * @param liberation Optional Liberation chip to use first
	 * @param useMPBuff Whether to use MP buffs for extended reach
	 * @return Combo, or null if no useful actions found
	 */
	static Combo? buildForTarget(ExplorationContext ctx, Entity target, Item? liberation, boolean useMPBuff) {
		integer baseMP = ctx.initialMP
		integer baseTP = ctx.initialTP

		// Get all actions that can damage this target
		Array<Action> damageActions = MapCellScore.getActionsDamagingTarget(target)
		if (count(damageActions) == 0 && liberation == null) return null

		// Filter by reach (or calculate buffs)
		Array<Action> mpBuffActions = []
		if (useMPBuff && ctx.maxMPBuff > 0) {
			integer maxDist = ComboBuilder._getMaxDistNeeded(ctx, damageActions)
			if (maxDist > baseMP) {
				Array<Action>? buffs = ComboBuilder._calculateMPBuffs(maxDist - baseMP, baseTP)
				if (buffs == null) return null
				mpBuffActions = buffs!
			}
		} else {
			// Filter to current reach only
			damageActions = ComboBuilder._filterByReach(ctx, damageActions, false)
		}

		// Start combo
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		// Apply MP buffs first
		ComboBuilder._applyBuffs(combo, mpBuffActions, usesThisTurn)

		// Apply Liberation if provided
		if (liberation != null) {
			Consequences csq = combo.getCurrentConsequences()
			Action? libAction = ComboBuilder._findLiberationAction(ctx, liberation!, target, csq)
			if (libAction != null) {
				combo.add(libAction!)
				usesThisTurn[liberation!] = 1
			}
		}

		// Get state after buffs/liberation
		Consequences csq = combo.getCurrentConsequences()

		// Exclude buffs from damage pool
		damageActions = ComboBuilder._excludeUsed(damageActions, usesThisTurn)

		// Select with knapsack
		Array<Action> selected = ActionKnapsack.solve(damageActions, csq.currentTP, csq.currentWeapon)
		selected = MapCellScore.sortByPriority(selected)

		// Add selected actions (stop when target dies)
		for (Action action in selected) {
			if (combo.getCurrentConsequences().isKilled(target)) break
			ComboBuilder.tryAddAction(ctx, combo, action, usesThisTurn, 0)
		}

		// Greedy fallback with pool expansion on kill
		csq = combo.getCurrentConsequences()
		if (csq.currentTP > 0) {
			Array<Action> fallbackPool
			if (csq.isKilled(target)) {
				// Target dead -> expand to ALL actions
				fallbackPool = ComboBuilder._getAllActions()
			} else {
				// Target alive -> stick to damage actions
				fallbackPool = damageActions
			}
			fallbackPool = ComboBuilder._excludeUsed(fallbackPool, usesThisTurn)
			ComboBuilder._greedyFallback(ctx, combo, fallbackPool, usesThisTurn, false)
		}

		// Final position
		ComboBuilder._addFinalPosition(combo)

		return count(combo.actions) > 0 ? combo : null
	}

	/*
	 * Build combo focused on supporting a specific ally.
	 * Used by: trySupportAlly
	 *
	 * @param ctx Exploration context with initial resources
	 * @param ally Ally to focus support on
	 * @param useMPBuff Whether to use MP buffs for extended reach
	 * @return Combo, or null if no useful actions found
	 */
	static Combo? buildForAlly(ExplorationContext ctx, Entity ally, boolean useMPBuff) {
		integer baseMP = ctx.initialMP
		integer baseTP = ctx.initialTP

		// Get all actions that help this ally
		Array<Action> helpActions = MapCellScore.getActionsHelpingAlly(ally)
		if (count(helpActions) == 0) return null

		// Filter by reach (or calculate buffs)
		Array<Action> mpBuffActions = []
		if (useMPBuff && ctx.maxMPBuff > 0) {
			integer maxDist = ComboBuilder._getMaxDistNeeded(ctx, helpActions)
			if (maxDist > baseMP) {
				Array<Action>? buffs = ComboBuilder._calculateMPBuffs(maxDist - baseMP, baseTP)
				if (buffs == null) return null
				mpBuffActions = buffs!
			}
		} else {
			helpActions = ComboBuilder._filterByReach(ctx, helpActions, false)
		}

		// Start combo
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		// Apply MP buffs
		ComboBuilder._applyBuffs(combo, mpBuffActions, usesThisTurn)

		// Get state after buffs
		Consequences csq = combo.getCurrentConsequences()

		// Exclude buffs from help pool
		helpActions = ComboBuilder._excludeUsed(helpActions, usesThisTurn)

		// Build core
		ComboBuilder._buildCoreInto(
			ctx,
			combo,
			usesThisTurn,
			helpActions,
			csq.currentTP,
			csq.currentWeapon,
			0,      // reserveMP
			null,   // stopWhenKilled
			false   // restrictToCell
		)

		return count(combo.actions) > 0 ? combo : null
	}

	/*
	 * Build combo across multiple cells in sequence.
	 * Automatically partitions actions and calculates MP buffs if needed.
	 * Used by: tryPairOrder, tryTripletOrder
	 *
	 * @param ctx Exploration context with initial resources
	 * @param sequence Array of cells to visit in order
	 * @param useMPBuff Whether to use MP buffs for extended reach
	 * @return Combo, or null if path is unreachable
	 */
	static Combo? buildAcrossCells(ExplorationContext ctx, Array<Cell> sequence, boolean useMPBuff) {
		if (count(sequence) == 0) return null

		integer baseMP = ctx.initialMP
		integer baseTP = ctx.initialTP
		integer maxMPBuff = ctx.maxMPBuff
		Set<Cell> ignoreCells = clone(ctx.cellsToIgnore) as Set<Cell>

		// Calculate total distance needed
		integer totalDistance = ComboBuilder._calculatePathDistance(sequence, ignoreCells, baseMP + maxMPBuff)
		if (totalDistance < 0) return null  // Path impossible even with max buffs

		// Calculate needed buff
		integer neededBuff = max(0, totalDistance - baseMP)

		// Get minimal buffs if needed
		Array<Action> mpBuffActions = []
		integer effectiveTP = baseTP
		Item? effectiveWeapon = ctx.initialWeapon

		if (neededBuff > 0) {
			if (!useMPBuff) return null  // Need buffs but not allowed
			Array<Action>? buffs = ComboBuilder._calculateMPBuffs(neededBuff, baseTP)
			if (buffs == null) return null
			mpBuffActions = buffs!

			// Adjust effective TP/weapon
			for (Action buff in mpBuffActions) {
				effectiveTP -= buff.item.cost
				effectiveWeapon = buff.consequences.currentWeapon
			}
		}

		// Pool actions from all cells (deduplicated)
		Array<Action> combined = ComboBuilder._poolActionsFromCells(sequence, mpBuffActions)
		if (count(combined) == 0 && count(mpBuffActions) == 0) return null

		// Use knapsack
		Array<Action> selected = ActionKnapsack.solve(combined, effectiveTP, effectiveWeapon)
		if (count(selected) == 0 && count(mpBuffActions) == 0) return null

		// Partition by cell
		Map<Cell, Array<Action>> cellActionMap = ComboBuilder._partitionByCell(selected, sequence)

		// Prepend MP buffs to first cell
		Cell firstCell = sequence[0]
		for (integer i = count(mpBuffActions) - 1; i >= 0; i--) {
			unshift(cellActionMap[firstCell]!, mpBuffActions[i])
		}

		// Sort each cell's actions by priority
		for (Cell cell in sequence) {
			cellActionMap[cell] = MapCellScore.sortByPriority(cellActionMap[cell]!)
		}

		// Build combo following sequence
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		for (Cell cell in sequence) {
			Array<Action>? actions = cellActionMap[cell]
			if (actions == null) continue

			for (Action action in actions!) {
				ComboBuilder.tryAddAction(ctx, combo, action, usesThisTurn, 0)
			}
		}

		// Final position
		ComboBuilder._addFinalPosition(combo)

		return combo
	}

	/*
	 * Build combo with inversion as first-class strategy.
	 * Simplified design: greedy pre-actions, then phase-2-style post-inversion cell selection.
	 *
	 * @param ctx Exploration context with initial resources
	 * @param candidate Inversion candidate to use
	 * @return Combo with inversion, or null if not worthwhile
	 */
	static Combo? buildWithInversion(ExplorationContext ctx, InversionCandidate candidate) {
		if (Fight.inversionItem == null) return null

		Item invItem = Fight.inversionItem!
		Cell startCell = Fight.self.cell
		Cell invCastCell = candidate.fromCell
		Cell newSelfCell = candidate.targetCell  // Where we land after swap

		integer invCost = invItem.cost
		integer mpToInvCast = candidate.mpCost

		// Check basic feasibility
		if (ctx.initialTP < invCost) return null

		// Calculate MP buff needed to reach inversion cast cell
		integer neededMPBuff = max(0, mpToInvCast - ctx.initialMP)
		Array<Action> mpBuffActions = []
		integer mpBuffTPCost = 0

		if (neededMPBuff > 0) {
			// Check if reachable even with max buffs
			if (mpToInvCast > ctx.initialMP + ctx.maxMPBuff) return null

			// Calculate minimal MP buffs (reserve TP for inversion)
			Array<Action>? buffs = ComboBuilder._calculateMPBuffs(neededMPBuff, ctx.initialTP - invCost)
			if (buffs == null) return null
			mpBuffActions = buffs!

			// Sum TP cost of buffs
			for (Action buff in mpBuffActions) {
				mpBuffTPCost += buff.item.cost
			}
		}

		// Total reserved TP = inversion + MP buffs
		integer reservedTP = invCost + mpBuffTPCost

		Set<Cell> ignoreCells = clone(ctx.cellsToIgnore) as Set<Cell>

		// === PRE-INVERSION: gather actions at start cell ===
		Array<Action> preSelfCast = []
		Array<Action> preStartCell = []

		Array<Action> startActions = MapCellScore.getActionsForCell(startCell)
		for (Action a in startActions) {
			if (a.score <= 0) continue
			if (a.from == Fight.selfCell) {
				push(preSelfCast, a)
			} else {
				push(preStartCell, a)
			}
		}

		preSelfCast = MapCellScore.sortByPriority(preSelfCast)
		preStartCell = MapCellScore.sortByPriority(preStartCell)

		// === BUILD COMBO ===
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		// 0. MP buffs first (needed to reach inversion cast cell)
		ComboBuilder._applyBuffs(combo, mpBuffActions, usesThisTurn)

		// Verify we have enough MP after buffs
		Consequences buffedCsq = combo.getCurrentConsequences()
		if (buffedCsq.currentMP < mpToInvCast) {
			return null  // Buffs didn't provide enough MP
		}

		// 1. Self-cast at start (reserve TP for inversion)
		for (Action a in preSelfCast) {
			ComboBuilder._tryAddActionWithReserve(combo, a, usesThisTurn, invCost)
		}

		// 2. Actions at startCell (reserve TP for inversion)
		for (Action a in preStartCell) {
			ComboBuilder._tryAddActionWithReserve(combo, a, usesThisTurn, invCost)
		}

		// 3. Inversion action - create with combo's current state
		Consequences priorCsq = combo.getCurrentConsequences()
		Action invAction = Action(invItem, invCastCell, candidate.targetCell)
		invAction.invCandidate = candidate

		// Actualize with current consequences and add tactical score
		Action actualizedInv = Action(invAction, priorCsq)
		actualizedInv.consequences.score += candidate.score
		actualizedInv.score = actualizedInv.consequences.getScore()

		if (actualizedInv.score! <= priorCsq.score!) {
			return null  // Inversion doesn't improve score
		}
		push(combo.actions, actualizedInv)
		usesThisTurn[invItem] = 1

		// === POST-INVERSION: cell selection via MapTactical ===
		Consequences csq = combo.getCurrentConsequences()
		integer postMP = csq.currentMP
		integer postTP = csq.currentTP

		// Compute reachable cells from new position (swapped entity blocks invCastCell)
		Set<Cell> postObstacles = <invCastCell>
		Map<Cell, integer> reachable = MapPath.getCachedReachableCells(
			newSelfCell, postMP, ignoreCells, postObstacles)

		// Get post-pool from MapTactical and group by fromCell
		Array<Action> postPool = MapTactical.getPostInversionPool(candidate, postTP, postMP, ignoreCells)
		Map<Cell, Array<Action>> postByCell = [:]
		for (Action a in postPool) {
			Cell fromCell = a.from
			if (fromCell == Fight.selfCell) fromCell = newSelfCell
			if (postByCell[fromCell] == null) postByCell[fromCell] = []
			push(postByCell[fromCell]!, a)
		}

		// Get merged cell scores from MapTactical
		PostInversionCellData cellData = MapTactical.getPostInversionCellScores(
			candidate, newSelfCell, reachable, postByCell)

		// Select best cells (pair if reachable, else single)
		Array<Cell> selectedCells = ComboBuilder._selectBestCellSequence(
			cellData, postMP, ignoreCells, postObstacles)

		// Add actions cell by cell in sequence (like buildAcrossCells)
		// This ensures combo moves to cell 1, executes cell 1's actions, then moves to cell 2, etc.
		// Mixing actions from different cells causes unreachable cell errors.
		if (count(selectedCells) > 0) {
			Map<integer, boolean> seen = [:]

			for (Cell cell in selectedCells) {
				Array<Action>? actions = cellData.actions[cell]
				if (actions == null) continue

				// Sort this cell's actions by priority before adding
				Array<Action> sorted = MapCellScore.sortByPriority(actions!)
				for (Action a in sorted) {
					integer hash = a.item.id * 10000 + a.to.id
					if (seen[hash]) continue
					seen[hash] = true
					ComboBuilder._tryAddActionWithReserve(combo, a, usesThisTurn, 0)
				}
			}
		}

		// Final position
		csq = combo.getCurrentConsequences()
		Position pos = MapPosition.findBestPosition(csq.currentCell, csq.currentMP, csq)
		combo.addFinalPosition(pos)

		return combo
	}

	/*
	 * Select best cell sequence from post-inversion cell data.
	 * Tries pairs first (top 3 by score), falls back to single best.
	 *
	 * @param cellData Cell scores and MP costs from MapTactical
	 * @param availableMP MP available after inversion
	 * @param ignoreCells Cells to ignore in pathfinding
	 * @param obstacles Additional obstacles (swapped entity position)
	 * @return Array of 1-2 cells to visit, empty if no valid cells
	 */
	static Array<Cell> _selectBestCellSequence(
		PostInversionCellData cellData,
		integer availableMP,
		Set<Cell> ignoreCells,
		Set<Cell> obstacles
	) {
		// Build sorted list of cells by score
		Array<Cell> sortedCells = []
		for (Cell c : real score in cellData.scores) {
			push(sortedCells, c)
		}

		if (count(sortedCells) == 0) return []

		sortedCells = arraySort(sortedCells, (Cell a, Cell b) -> integer {
			return Sort.desc(cellData.scores[a]!, cellData.scores[b]!)
		}) as Array<Cell>

		// Take top K (K=3)
		integer K = min(3, count(sortedCells))

		// Try pairs first
		if (K >= 2) {
			for (integer i = 0; i < K; i++) {
				for (integer j = i + 1; j < K; j++) {
					Cell c1 = sortedCells[i]
					Cell c2 = sortedCells[j]
					integer cost1 = cellData.mpCosts[c1]!

					// Check if we can reach c2 from c1
					integer mpAfterC1 = availableMP - cost1
					if (mpAfterC1 <= 0) continue

					Map<Cell, integer> fromC1 = MapPath.getCachedReachableCells(
						c1, mpAfterC1, ignoreCells, obstacles)

					if (fromC1[c2] != null) {
						return [c1, c2]
					}
				}
			}
		}

		// Fall back to single best cell
		return [sortedCells[0]]
	}

	/*
	 * Try to add action with reserved TP (for inversion actions that must leave room for inversion chip)
	 */
	static boolean _tryAddActionWithReserve(Combo combo, Action action, Map<Item, integer> usesThisTurn, integer reserveTP) {
		integer uses = usesThisTurn[action.item] != null ? usesThisTurn[action.item]! : 0
		if (uses >= action.item.maxUse) return false

		Consequences csq = combo.getCurrentConsequences()
		integer switchCost = (action.item.isWeap && action.item != csq.currentWeapon) ? 1 : 0
		// Check we have enough TP for action + reserved TP (for inversion)
		if (csq.currentTP < action.item.cost + switchCost + reserveTP) return false

		boolean added = combo.add(action)
		if (added) {
			usesThisTurn[action.item] = uses + 1
		}
		return added
	}

	// ════════════════════════════════════════════════════════════
	// PRIVATE CORE METHODS
	// ════════════════════════════════════════════════════════════

	/*
	 * Core combo building: knapsack -> sort -> add -> greedy -> position.
	 * Creates a new combo from scratch.
	 */
	static Combo _buildCore(
		ExplorationContext ctx,
		Array<Action> pool,
		integer availableTP,
		Item? currentWeapon,
		integer reserveMP,
		Entity? stopWhenKilled,
		boolean restrictToCell
	) {
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		ComboBuilder._buildCoreInto(
			ctx, combo, usesThisTurn, pool, availableTP, currentWeapon,
			reserveMP, stopWhenKilled, restrictToCell
		)

		return combo
	}

	/*
	 * Core combo building into an existing combo.
	 * Allows prepending buffs/liberation before core logic.
	 */
	static void _buildCoreInto(
		ExplorationContext ctx,
		Combo combo,
		Map<Item, integer> usesThisTurn,
		Array<Action> pool,
		integer availableTP,
		Item? currentWeapon,
		integer reserveMP,
		Entity? stopWhenKilled,
		boolean restrictToCell
	) {
		// Knapsack selection
		Array<Action> selected = ActionKnapsack.solve(pool, availableTP, currentWeapon)
		selected = MapCellScore.sortByPriority(selected)

		// Add selected actions
		for (Action action in selected) {
			if (stopWhenKilled != null && combo.getCurrentConsequences().isKilled(stopWhenKilled!)) break

			boolean added = ComboBuilder.tryAddAction(ctx, combo, action, usesThisTurn, reserveMP)

			// If summon was added, expand pool with bulb buff actions
			if (added && action.item.isSummon) {
				ComboBuilder._expandWithBulbBuffs(ctx, combo, action.to, usesThisTurn, reserveMP)
			}
		}

		// Greedy fallback
		Consequences csq = combo.getCurrentConsequences()
		if (csq.currentTP > 0) {
			Array<Action> remaining = ComboBuilder._excludeUsed(pool, usesThisTurn)
			ComboBuilder._greedyFallback(ctx, combo, remaining, usesThisTurn, restrictToCell)
		}

		// Final position
		ComboBuilder._addFinalPosition(combo)
	}

	/*
	 * Expand combo with buff actions for a newly summoned bulb.
	 * Called after a summon action is successfully added.
	 */
	static void _expandWithBulbBuffs(
		ExplorationContext ctx,
		Combo combo,
		Cell bulbCell,
		Map<Item, integer> usesThisTurn,
		integer reserveMP
	) {
		Consequences csq = combo.getCurrentConsequences()

		// Check if a pendingBulb exists at this cell
		if (csq.pendingBulbs[bulbCell] == null) return;

		// Build ignoreCells: base + killed entities
		Set<Cell> ignoreCells = ComboBuilder.buildIgnoreCells(ctx, csq)

		// Generate buff actions for the newly created pendingBulb
		Array<Action> buffActions = MapAction.getBulbBuffActions(
			bulbCell,
			csq.currentCell,
			csq.currentMP,
			csq.currentTP,
			usesThisTurn,
			ignoreCells
		)

		if (count(buffActions) == 0) return;

		// Sort by score (greedy selection of best buffs)
		buffActions = MapCellScore.sortByScore(buffActions)

		// Try each buff
		for (Action buffAction in buffActions) {
			ComboBuilder.tryAddAction(ctx, combo, buffAction, usesThisTurn, reserveMP)
		}
	}


	/*
	 * Apply MP buff actions to combo.
	 */
	static void _applyBuffs(Combo combo, Array<Action> buffs, Map<Item, integer> usesThisTurn) {
		for (Action buff in buffs) {
			combo.add(buff)
			usesThisTurn[buff.item] = 1
		}
	}

	/*
	 * Greedy fallback: fill remaining TP from pool.
	 * Loops on repeatable items until maxUse reached.
	 */
	static void _greedyFallback(
		ExplorationContext ctx,
		Combo combo,
		Array<Action> pool,
		Map<Item, integer> usesThisTurn,
		boolean restrictToCell
	) {
		// Filter if restricting to cell
		Array<Action> filtered = []
		Consequences csq = combo.getCurrentConsequences()

		for (Action a in pool) {
			if (a.score <= 0) continue
			if (restrictToCell && a.from != Fight.selfCell && a.from != csq.currentCell) continue
			push(filtered, a)
		}

		// Sort by score for greedy fill
		filtered = MapCellScore.sortByScore(filtered)

		// Try to fill - loop on each action until it fails
		for (Action action in filtered) {
			boolean added = ComboBuilder.tryAddAction(ctx, combo, action, usesThisTurn, 0)

			// If summon was added, expand with bulb buff actions
			if (added && action.item.isSummon) {
				ComboBuilder._expandWithBulbBuffs(ctx, combo, action.to, usesThisTurn, 0)
			}

			// Continue looping for repeatable items
			while (added && ComboBuilder.tryAddAction(ctx, combo, action, usesThisTurn, 0)) {}
		}
	}

	/*
	 * Add final position to combo.
	 */
	static void _addFinalPosition(Combo combo) {
		Consequences csq = combo.getCurrentConsequences()
		Position pos = MapPosition.findBestPosition(csq.currentCell, csq.currentMP, csq)
		combo.addFinalPosition(pos)
	}

	// ════════════════════════════════════════════════════════════
	// PRIVATE HELPERS
	// ════════════════════════════════════════════════════════════

	/*
	 * Filter actions to only those reachable with current/extended MP.
	 */
	static Array<Action> _filterByReach(ExplorationContext ctx, Array<Action> actions, boolean useExtended) {
		integer baseMP = ctx.initialMP
		integer maxReach = useExtended ? baseMP + ctx.maxMPBuff : baseMP
		Map<Cell, integer> reachable = useExtended
			? ctx.extendedReachableCells
			: ctx.reachableCells

		Array<Action> filtered = []
		for (Action a in actions) {
			if (a.from == Fight.selfCell) {
				push(filtered, a)
			} else {
				integer? dist = reachable[a.from]
				if (dist != null && dist! <= maxReach) {
					push(filtered, a)
				}
			}
		}
		return filtered
	}

	/*
	 * Find maximum distance needed to reach any action's from-cell.
	 */
	static integer _getMaxDistNeeded(ExplorationContext ctx, Array<Action> actions) {
		integer maxDist = 0
		Map<Cell, integer> reachable = ctx.extendedReachableCells

		for (Action a in actions) {
			if (a.from == Fight.selfCell) continue
			integer? dist = reachable[a.from]
			if (dist != null && dist! > maxDist) {
				maxDist = dist!
			}
		}
		return maxDist
	}

	/*
	 * Calculate minimal MP buffs needed for given extra MP.
	 * Greedy by efficiency (MP/TP).
	 * Returns null if impossible.
	 * Note: Uses Fight.self.effects to check active buffs (entity state, not context).
	 */
	static Array<Action>? _calculateMPBuffs(integer neededMP, integer availableTP) {
		if (neededMP <= 0) return []

		// Build set of already-active MP buff chips
		Map<integer, boolean> activeBuffChips = [:]
		for (EntityEffect e in Fight.self.effects) {
			if (e.type == EFFECT_BUFF_MP || e.type == EFFECT_RAW_BUFF_MP) {
				activeBuffChips[e.item.id] = true
			}
		}

		// Collect MP buff actions directly from entity items (not selfCastActions)
		// This matches computeMaxMPBuff() logic to avoid mismatch
		Array<Action> allBuffs = []
		real sncMultiplier = 1 + Fight.self.snc / 100.0

		for (Item item in Fight.self.items) {
			// Skip if not self-castable
			if (item.minRange > 0) continue
			// Skip if on cooldown
			if (item.haveCD && getCooldown(item.id, Fight.self.id) > 0) continue
			// Skip if can't afford
			if (item.cost > availableTP) continue
			// Skip if already active
			if (activeBuffChips[item.id]) continue

			// Check for MP buff effect and compute gain
			integer mpGain = 0
			for (ItemEffect effect in item.effects) {
				if (effect.type == EFFECT_RAW_BUFF_MP) {
					mpGain = round(effect.avg)
					break
				} else if (effect.type == EFFECT_BUFF_MP) {
					mpGain = round(effect.avg * sncMultiplier)
					break
				}
			}
			if (mpGain <= 0) continue

			// Create self-cast action for this buff
			Action buffAction = Action(item, Fight.selfCell, Fight.selfCell)
			push(allBuffs, buffAction)
		}

		if (count(allBuffs) == 0) return null

		// Sort by efficiency (MP gain / TP cost) descending
		integer baseMP = Fight.self.mp
		allBuffs = arraySort(allBuffs, (Action a, Action b) => integer|real {
			integer gainA = a.consequences.currentMP - baseMP
			integer gainB = b.consequences.currentMP - baseMP
			real effA = gainA / a.item.cost
			real effB = gainB / b.item.cost
			return Sort.desc(effA, effB)
		}) as Array<Action>

		// Greedy selection
		Array<Action> selected = []
		integer totalGain = 0
		integer tpSpent = 0

		for (Action a in allBuffs) {
			if (totalGain >= neededMP) break
			if (tpSpent + a.item.cost > availableTP) continue

			integer gain = a.consequences.currentMP - baseMP
			push(selected, a)
			totalGain += gain
			tpSpent += a.item.cost
		}

		return totalGain >= neededMP ? selected : null
	}

	/*
	 * Calculate total path distance for a sequence of cells.
	 * Returns -1 if any leg is unreachable.
	 */
	static integer _calculatePathDistance(Array<Cell> sequence, Set<Cell> ignoreCells, integer maxMP) {
		if (count(sequence) == 0) return 0

		integer totalDist = 0
		Cell current = Fight.self.cell
		integer remainingMP = maxMP

		for (Cell target in sequence) {
			Map<Cell, integer> reachable
			if (current == Fight.self.cell) {
				reachable = Fight.self.extendedReachableCells
			} else {
				reachable = MapPath.getCachedReachableCells(current, remainingMP, ignoreCells)
			}

			integer? dist = reachable[target]
			if (dist == null) return -1  // Unreachable

			totalDist += dist!
			remainingMP -= dist!
			if (remainingMP < 0) return -1
			current = target
		}

		return totalDist
	}

	/*
	 * Pool actions from multiple cells, deduplicated.
	 */
	static Array<Action> _poolActionsFromCells(Array<Cell> cells, Array<Action> excludeBuffs) {
		Array<Action> combined = []
		Map<integer, boolean> seen = [:]

		// Build exclude set
		Map<integer, boolean> excludeKeys = [:]
		for (Action buff in excludeBuffs) {
			excludeKeys[ComboBuilder.actionKey(buff)] = true
		}

		for (Cell cell in cells) {
			Array<Action> cellActions = MapCellScore.getActionsForCell(cell)
			for (Action a in cellActions) {
				integer key = ComboBuilder.actionKey(a)
				if (excludeKeys[key]) continue
				if (!seen[key]) {
					push(combined, a)
					seen[key] = true
				}
			}
		}

		return combined
	}

	/*
	 * Partition actions by their from-cell.
	 */
	static Map<Cell, Array<Action>> _partitionByCell(Array<Action> actions, Array<Cell> cells) {
		Map<Cell, Array<Action>> result = [:]

		// Initialize empty arrays for each cell
		for (Cell cell in cells) {
			result[cell] = []
		}

		Cell firstCell = cells[0]

		for (Action action in actions) {
			if (action.from == Fight.selfCell) {
				// Self-cast goes to first cell
				push(result[firstCell]!, action)
			} else if (result[action.from] != null) {
				push(result[action.from]!, action)
			}
			// Actions from other cells are skipped (shouldn't happen)
		}

		return result
	}

	/*
	 * Get ALL actions from all cells (for fallback expansion).
	 * Note: cellActions and selfCastActions are already filtered (score > 0)
	 * in MapCellScore.refresh(), so no need to re-check here.
	 */
	static Array<Action> _getAllActions() {
		Array<Action> all = []

		for (Cell cell : Array<Action> actions in MapCellScore.cellActions) {
			for (Action a in actions) {
				push(all, a)
			}
		}

		// Add self-cast
		for (Action a in MapCellScore.selfCastActions) {
			push(all, a)
		}

		return all
	}

	/*
	 * Exclude already-used items from pool.
	 */
	static Array<Action> _excludeUsed(Array<Action> pool, Map<Item, integer> usesThisTurn) {
		Array<Action> filtered = []
		for (Action a in pool) {
			integer uses = usesThisTurn[a.item] != null ? usesThisTurn[a.item]! : 0
			if (uses < a.item.maxUse) {
				push(filtered, a)
			}
		}
		return filtered
	}

	/*
	 * Find Liberation action targeting specific entity.
	 */
	static Action? _findLiberationAction(ExplorationContext ctx, Item liberationItem, Entity target, Consequences csq) {
		Map<Cell, Map<Item, Action>> bestActions = MapAction.getMapBestAction()

		for (Cell cell : Map<Item, Action> itemActions in bestActions) {
			Action? action = itemActions[liberationItem]
			if (action == null) continue

			if (action!.to != target.cell) continue

			// Check reachability (cache may have cells beyond MP, must verify distance)
			if (action!.from != Fight.selfCell) {
				Set<Cell> ignoreCells = ComboBuilder.buildIgnoreCells(ctx, csq)
				Map<Cell, integer> reachable = MapPath.getCachedReachableCells(
					csq.currentCell, csq.currentMP, ignoreCells, csq._newObstacles)
				integer? dist = reachable[action!.from]
				if (dist == null || dist! > csq.currentMP) continue
			}

			return action
		}
		return null
	}

	// ════════════════════════════════════════════════════════════
	// PUBLIC HELPERS (used by other modules)
	// ════════════════════════════════════════════════════════════

	/*
	 * Build ignoreCells array for pathfinding: base cells + killed entities + freed cells
	 */
	static Set<Cell> buildIgnoreCells(ExplorationContext ctx, Consequences csq) {
		Set<Cell> ignoreCells = clone(ctx.cellsToIgnore) as Set<Cell>
		csq.appendKilledCells(ignoreCells)
		csq.appendFreedCells(ignoreCells)
		return ignoreCells
	}

	/*
	 * Try to add an action to a combo, checking all preconditions.
	 * Handles: usage limits, TP cost, weapon switch, reachability with reserveMP.
	 * Updates usesThisTurn map if action was added.
	 *
	 * @param ctx Exploration context with initial resources
	 * @param combo The combo to add to
	 * @param action The action to try adding
	 * @param usesThisTurn Map tracking item usage counts this turn
	 * @param reserveMP MP to reserve for defense (subtracted from available MP)
	 * @return true if action was added, false otherwise
	 */
	static boolean tryAddAction(ExplorationContext ctx, Combo combo, Action action, Map<Item, integer> usesThisTurn, integer reserveMP) {
		return ComboBuilder._tryAddActionImpl(combo, action, usesThisTurn, reserveMP, ctx.cellsToIgnore)
	}

	/*
	 * Try to add an action to a combo (without exploration context).
	 * For use by external modules like MapSummon that build combos outside exploration.
	 * Uses Fight.self.cellsToIgnore for pathfinding.
	 */
	static boolean tryAddAction(Combo combo, Action action, Map<Item, integer> usesThisTurn, integer reserveMP) {
		return ComboBuilder._tryAddActionImpl(combo, action, usesThisTurn, reserveMP, Fight.self.cellsToIgnore)
	}

	/*
	 * Internal implementation of tryAddAction.
	 */
	static boolean _tryAddActionImpl(Combo combo, Action action, Map<Item, integer> usesThisTurn, integer reserveMP, Set<Cell> baseCellsToIgnore) {
		// Check usage limit
		integer uses = usesThisTurn[action.item] != null ? usesThisTurn[action.item]! : 0
		if (uses >= action.item.maxUse) return false

		// Get current state
		Consequences csq = combo.getCurrentConsequences()

		// Check if action was invalidated by inversion (targets moved)
		if (csq.invalidatedActions != null && setContains(csq.invalidatedActions!, action)) return false

		// Check TP (including weapon switch cost)
		integer switchCost = (action.item.isWeap && action.item != csq.currentWeapon) ? 1 : 0
		if (csq.currentTP < action.item.cost + switchCost) return false

		// Check reachability
		if (action.from != Fight.selfCell) {
			// Build ignore cells: base + killed entities + freed cells (COW-aware)
			Set<Cell> ignoreCells = clone(baseCellsToIgnore) as Set<Cell>
			csq.appendKilledCells(ignoreCells)
			csq.appendFreedCells(ignoreCells)
			integer effectiveMP = max(0, csq.currentMP - reserveMP)
			Map<Cell, integer> reachable = MapPath.getCachedReachableCells(
				csq.currentCell, effectiveMP, ignoreCells, csq._newObstacles)
			if (reachable[action.from] == null || reachable[action.from]! > effectiveMP) return false
		}

		// Try to add
		boolean added = combo.add(action)
		if (added) {
			usesThisTurn[action.item] = uses + 1
		}
		return added
	}

	/*
	 * Unique key for action (for deduplication)
	 */
	static integer actionKey(Action a) {
		return a.item.id * 10000000 + a.from.id * 10000 + a.to.id
	}
}
