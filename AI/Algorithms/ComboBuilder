/*
 * ComboBuilder - Unified combo construction
 *
 * Centralizes all combo-building logic to avoid duplication across phases.
 * All public methods take ExplorationContext as first parameter for:
 * - Initial resources (TP, MP, weapon)
 * - Reachability maps
 * - Cells to ignore in pathfinding
 *
 * Provides specialized methods for different exploration strategies:
 * - buildAtCell: Single cell, no MP buffs
 * - buildAtCellBuffed: Single cell with auto MP buffs
 * - buildForTargetPrefixed: Kill focus with prefix enumeration (Liberation, str buffs, Neutrino, MP buffs)
 * - buildForAlly: Support focus
 * - buildAcrossCells: Multi-cell sequences
 *
 * All methods handle: knapsack selection, priority sorting, greedy fallback,
 * and final position calculation.
 */

class ComboBuilder {

	// ════════════════════════════════════════════════════════════
	// PUBLIC SPECIALIZED METHODS
	// ════════════════════════════════════════════════════════════

	/*
	 * Build combo at a single cell (no MP buffs needed).
	 * Used by: phaseStay, phaseSingleCell (1a)
	 *
	 * @param ctx Exploration context with initial resources
	 * @param cell Target cell to execute actions from
	 * @param reserveMP MP to reserve for defensive positioning
	 * @return Combo with actions + final position
	 */
	static Combo buildAtCell(ExplorationContext ctx, Cell cell, integer reserveMP) {
		Array<Action> pool = MapCellScore.getActionsForCell(cell)
		return ComboBuilder._buildCore(
			ctx,
			pool,
			ctx.initialTP,
			ctx.initialWeapon,
			reserveMP,
			null,   // stopWhenKilled
			true    // restrictToCell
		)
	}

	/*
	 * Build combo at an extended-range cell (requires MP buffs).
	 * Automatically calculates minimal MP buffs needed.
	 * Used by: phaseSingleCell (1b)
	 *
	 * @param ctx Exploration context with initial resources
	 * @param cell Target cell beyond normal MP range
	 * @param distanceToCell Distance from current position to cell
	 * @return Combo with buffs + actions + position, or null if unreachable
	 */
	static Combo? buildAtCellBuffed(ExplorationContext ctx, Cell cell, integer distanceToCell) {
		integer baseMP = ctx.initialMP

		if (distanceToCell <= baseMP) {
			// No buff needed, use regular method
			return ComboBuilder.buildAtCell(ctx, cell, 0)
		}

		integer neededBuff = distanceToCell - baseMP

		// Calculate minimal buffs
		Array<Action>? buffs = ComboBuilder._calculateMPBuffs(neededBuff, ctx.initialTP)
		if (buffs == null) return null

		// Start combo with buffs
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]
		ComboBuilder._applyBuffs(combo, buffs!, usesThisTurn)

		// Get state after buffs
		Consequences csq = combo.getCurrentConsequences()
		integer remainingTP = csq.currentTP
		Item? weapon = csq.currentWeapon

		// Reserve MP: buffedMP - distanceToCell
		integer reserveMP = csq.currentMP - distanceToCell

		// Get actions for target cell (exclude buffs already used)
		Array<Action> pool = MapCellScore.getActionsForCell(cell)
		pool = ComboBuilder._excludeUsed(pool, usesThisTurn)

		// Build rest of combo
		ComboBuilder._buildCoreInto(
			ctx,
			combo,
			usesThisTurn,
			pool,
			remainingTP,
			weapon,
			reserveMP,
			null,   // stopWhenKilled
			true    // restrictToCell
		)

		return combo
	}

	/*
	 * Build combo at a single cell, forcing final position to targetCell.
	 * Used by: phaseConstrainedEnd (walk range)
	 */
	static Combo buildAtCellForcedEnd(
		ExplorationContext ctx, Cell actionCell, Cell targetCell,
		real scoreBonus, integer distActionToTarget
	) {
		Array<Action> pool = MapCellScore.getActionsForCell(actionCell)
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]
		ComboBuilder._buildCoreIntoNoPosition(ctx, combo, usesThisTurn, pool,
			ctx.initialTP, ctx.initialWeapon, distActionToTarget, null, true)
		if (!ComboBuilder._addForcedFinalPosition(combo, targetCell, scoreBonus)) {
			ComboBuilder._addFinalPosition(combo)
		}
		return combo
	}

	/*
	 * Build combo at an extended-range cell, forcing final position to targetCell.
	 * Returns null if MP buffs can't reach actionCell.
	 * Used by: phaseConstrainedEnd (extended range)
	 */
	static Combo? buildAtCellBuffedForcedEnd(
		ExplorationContext ctx, Cell actionCell, Cell targetCell,
		real scoreBonus, integer distToAction, integer distActionToTarget
	) {
		if (distToAction <= ctx.initialMP) {
			return ComboBuilder.buildAtCellForcedEnd(ctx, actionCell, targetCell,
				scoreBonus, distActionToTarget)
		}
		integer neededBuff = distToAction - ctx.initialMP
		Array<Action>? buffs = ComboBuilder._calculateMPBuffs(neededBuff, ctx.initialTP)
		if (buffs == null) return null

		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]
		ComboBuilder._applyBuffs(combo, buffs!, usesThisTurn)

		Consequences csq = combo.getCurrentConsequences()
		Array<Action> pool = MapCellScore.getActionsForCell(actionCell)
		pool = ComboBuilder._excludeUsed(pool, usesThisTurn)

		ComboBuilder._buildCoreIntoNoPosition(ctx, combo, usesThisTurn, pool,
			csq.currentTP, csq.currentWeapon, distActionToTarget, null, true)

		if (!ComboBuilder._addForcedFinalPosition(combo, targetCell, scoreBonus)) {
			ComboBuilder._addFinalPosition(combo)
		}
		return combo
	}

	/*
	 * Build combo focused on supporting a specific ally (canDie).
	 * Forces the best help action as prefix, then fills remaining TP from
	 * the general pool to maximize total score while saving the ally.
	 * Used by: trySupportAlly
	 *
	 * @param ctx Exploration context with initial resources
	 * @param ally Ally to focus support on
	 * @param useMPBuff Whether to use MP buffs for extended reach
	 * @return Combo, or null if no useful actions found
	 */
	static Combo? buildForAlly(ExplorationContext ctx, Entity ally, boolean useMPBuff) {
		integer baseMP = ctx.initialMP
		integer baseTP = ctx.initialTP

		// Get all actions that help this ally
		Array<Action> helpActions = MapCellScore.getActionsHelpingAlly(ally)
		if (count(helpActions) == 0) return null

		// Filter by reach (or calculate buffs)
		Array<Action> mpBuffActions = []
		if (useMPBuff && ctx.maxMPBuff > 0) {
			integer maxDist = ComboBuilder._getMaxDistNeeded(ctx, helpActions)
			if (maxDist > baseMP) {
				Array<Action>? buffs = ComboBuilder._calculateMPBuffs(maxDist - baseMP, baseTP)
				if (buffs == null) return null
				mpBuffActions = buffs!
			}
		} else {
			helpActions = ComboBuilder._filterByReachDistance(ctx, helpActions, ctx.initialMP)
		}

		if (count(helpActions) == 0) return null

		// Sort help actions by score descending
		helpActions = MapCellScore.sortByScore(helpActions)

		// Start combo
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		// Apply MP buffs
		ComboBuilder._applyBuffs(combo, mpBuffActions, usesThisTurn)
		helpActions = ComboBuilder._excludeUsed(helpActions, usesThisTurn)
		if (count(helpActions) == 0) return null

		// Add best help action (mandatory — save the ally)
		boolean added = ComboBuilder.tryAddAction(ctx, combo, helpActions[0], usesThisTurn, 0)
		if (!added) return null

		// Add more help actions while they score well (> 50% of best)
		real threshold = helpActions[0].score! * 0.5
		for (integer i = 1; i < count(helpActions); i++) {
			if (helpActions[i].score == null || helpActions[i].score! < threshold) break
			ComboBuilder.tryAddAction(ctx, combo, helpActions[i], usesThisTurn, 0)
		}

		// Fill remaining TP from general pool to maximize total score
		Consequences csq = combo.getCurrentConsequences()
		if (csq.currentTP > 0) {
			Array<Action> generalPool = ComboBuilder._getAllActions()
			generalPool = ComboBuilder._excludeUsed(generalPool, usesThisTurn)
			ComboBuilder._greedyFallback(ctx, combo, generalPool, usesThisTurn, false)
		}

		// Final position
		ComboBuilder._addFinalPosition(combo)

		return count(combo.actions) > 0 ? combo : null
	}

	/*
	 * Build combo focused on killing a specific target with prefix actions.
	 * Prefix order: MP buffs → Liberation → Str buffs → Neutrino → damage knapsack → greedy fallback.
	 * Used by: _exploreTargetEnemy
	 *
	 * @param ctx Exploration context with initial resources
	 * @param target Enemy to focus damage on
	 * @param damagePool Pre-filtered damage actions (by reach at this MP level)
	 * @param useLiberation Whether to prepend Liberation
	 * @param strBuffActions Str buff actions to prepend (0..N, sorted by efficiency)
	 * @param mpBuffActions MP buff actions to prepend (0..N)
	 * @param neutrinoCount Number of Neutrino uses to prepend (0..3, applies vuln before damage)
	 * @return Combo, or null if no useful actions found
	 */
	static Combo? buildForTargetPrefixed(
		ExplorationContext ctx,
		Entity target,
		Array<Action> damagePool,
		boolean useLiberation,
		Array<Action> strBuffActions,
		Array<Action> mpBuffActions,
		integer neutrinoCount
	) {
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		// 1. MP buffs first (need movement range before anything)
		ComboBuilder._applyBuffs(combo, mpBuffActions, usesThisTurn)

		// 2. Liberation (remove shields before damage)
		if (useLiberation) {
			Consequences csq = combo.getCurrentConsequences()
			Action? libAction = ComboBuilder._findLiberationAction(ctx, Fight.liberationItem!, target, csq)
			if (libAction != null) {
				combo.add(libAction!)
				usesThisTurn[Fight.liberationItem!] = 1
			} else {
				// Can't reach liberation cell at this MP level — redundant with no-lib variant
				return null
			}
		}

		// 3. Str buffs (increase damage for subsequent attacks)
		ComboBuilder._applyBuffs(combo, strBuffActions, usesThisTurn)

		// 4. Neutrino (apply vuln to target before damage)
		if (neutrinoCount > 0) {
			Consequences csq = combo.getCurrentConsequences()
			Action? neutrinoAction = ComboBuilder._findNeutrinoAction(ctx, Fight.neutrinoItem!, target, csq)
			if (neutrinoAction != null) {
				for (integer i = 0; i < neutrinoCount; i++) {
					combo.add(neutrinoAction!)
				}
				usesThisTurn[Fight.neutrinoItem!] = neutrinoCount
			} else {
				// Can't reach neutrino cell — redundant with no-neutrino variant
				return null
			}
		}

		// 5. State after all prefixes
		Consequences csq = combo.getCurrentConsequences()

		// 6. Exclude used items from damage pool
		damagePool = ComboBuilder._excludeUsed(damagePool, usesThisTurn)

		// 7. Knapsack selection (pass usesThisTurn so knapsack adjusts remaining copies)
		Array<Action> selected = ActionKnapsack.solve(damagePool, csq.currentTP, csq.currentWeapon, usesThisTurn)
		selected = MapCellScore.sortByPriority(selected)

		// 8. Add selected (stop when target dies)
		for (Action action in selected) {
			if (combo.getCurrentConsequences().isKilled(target)) break
			ComboBuilder.tryAddAction(ctx, combo, action, usesThisTurn, 0)
		}

		// 9. Greedy fallback with pool expansion on kill
		csq = combo.getCurrentConsequences()
		if (csq.currentTP > 0) {
			Array<Action> fallbackPool
			if (csq.isKilled(target)) {
				fallbackPool = ComboBuilder._getAllActions()
			} else {
				fallbackPool = damagePool
			}
			fallbackPool = ComboBuilder._excludeUsed(fallbackPool, usesThisTurn)
			ComboBuilder._greedyFallback(ctx, combo, fallbackPool, usesThisTurn, false)
		}

		// 10. Final position
		ComboBuilder._addFinalPosition(combo)

		return count(combo.actions) > 0 ? combo : null
	}

	/*
	 * Build combo across multiple cells in sequence.
	 * Automatically partitions actions and calculates MP buffs if needed.
	 * Used by: tryPairOrder, tryTripletOrder
	 *
	 * @param ctx Exploration context with initial resources
	 * @param sequence Array of cells to visit in order
	 * @param useMPBuff Whether to use MP buffs for extended reach
	 * @return Combo, or null if path is unreachable
	 */
	static Combo? buildAcrossCells(ExplorationContext ctx, Array<Cell> sequence, boolean useMPBuff) {
		if (count(sequence) == 0) return null

		integer baseMP = ctx.initialMP
		integer baseTP = ctx.initialTP
		integer maxMPBuff = ctx.maxMPBuff
		Set<Cell> ignoreCells = clone(ctx.cellsToIgnore) as Set<Cell>

		// Calculate total distance needed
		integer totalDistance = ComboBuilder._calculatePathDistance(sequence, ignoreCells, baseMP + maxMPBuff)
		if (totalDistance < 0) return null  // Path impossible even with max buffs

		// Calculate needed buff
		integer neededBuff = max(0, totalDistance - baseMP)

		// Get minimal buffs if needed
		Array<Action> mpBuffActions = []
		integer effectiveTP = baseTP
		Item? effectiveWeapon = ctx.initialWeapon

		if (neededBuff > 0) {
			if (!useMPBuff) return null  // Need buffs but not allowed
			Array<Action>? buffs = ComboBuilder._calculateMPBuffs(neededBuff, baseTP)
			if (buffs == null) return null
			mpBuffActions = buffs!

			// Adjust effective TP/weapon
			for (Action buff in mpBuffActions) {
				effectiveTP -= buff.item.cost
				effectiveWeapon = buff.consequences.currentWeapon
			}
		}

		// Pool actions from all cells (deduplicated)
		Array<Action> combined = ComboBuilder._poolActionsFromCells(sequence, mpBuffActions)
		if (count(combined) == 0 && count(mpBuffActions) == 0) return null

		// Use knapsack
		Array<Action> selected = ActionKnapsack.solve(combined, effectiveTP, effectiveWeapon, null)
		if (count(selected) == 0 && count(mpBuffActions) == 0) return null

		// Partition by cell
		Map<Cell, Array<Action>> cellActionMap = ComboBuilder._partitionByCell(selected, sequence)

		// Prepend MP buffs to first cell
		Cell firstCell = sequence[0]
		for (integer i = count(mpBuffActions) - 1; i >= 0; i--) {
			unshift(cellActionMap[firstCell]!, mpBuffActions[i])
		}

		// Sort each cell's actions by priority
		for (Cell cell in sequence) {
			cellActionMap[cell] = MapCellScore.sortByPriority(cellActionMap[cell]!)
		}

		// Build combo following sequence
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		for (Cell cell in sequence) {
			Array<Action>? actions = cellActionMap[cell]
			if (actions == null) continue

			for (Action action in actions!) {
				ComboBuilder.tryAddAction(ctx, combo, action, usesThisTurn, 0)
			}
		}

		// Final position
		ComboBuilder._addFinalPosition(combo)

		return combo
	}

	/*
	 * Build combo with inversion as first-class strategy.
	 * Delegates to unified buildWithSwap.
	 */
	static Combo? buildWithInversion(ExplorationContext ctx, MovementCandidate candidate) {
		if (Fight.inversionItem == null) return null
		return ComboBuilder._buildWithSwap(ctx, candidate, true)
	}

	/*
	 * Build combo with repotting (swap with allied bulb) as first-class strategy.
	 * Delegates to unified buildWithSwap.
	 */
	static Combo? buildWithRepotting(ExplorationContext ctx, MovementCandidate candidate) {
		if (Fight.repottingItem == null) return null
		return ComboBuilder._buildWithSwap(ctx, candidate, false)
	}

	/*
	 * Unified swap combo builder for inversion and repotting.
	 * Follows buildAcrossCells pattern: select best cells, single knapsack, execute in path order.
	 *
	 * @param ctx Exploration context with initial resources
	 * @param candidate Movement candidate (swap type)
	 * @param useScoreBonus If true, add candidate.score and check threshold (inversion)
	 * @return Combo with swap, or null if not worthwhile
	 */
	static Combo? _buildWithSwap(ExplorationContext ctx, MovementCandidate candidate, boolean useScoreBonus) {
		Item swapItem = candidate.item
		Cell startCell = Fight.self.cell
		Cell castCell = candidate.fromCell
		Cell newSelfCell = candidate.selfNewCell  // Where we land after swap

		integer swapCost = swapItem.cost
		integer mpToCast = candidate.mpCost

		// Check basic feasibility
		if (ctx.initialTP < swapCost) return null

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 1: Calculate MP buffs and resources
		// ═══════════════════════════════════════════════════════════════════════════

		Array<Action>? mpBuffResult = ComboBuilder._getMPBuffs(mpToCast, ctx.initialMP, ctx.maxMPBuff, ctx.initialTP - swapCost)
		if (mpBuffResult == null) return null
		Array<Action> mpBuffActions = mpBuffResult!
		integer mpBuffTPCost = ComboBuilder._sumBuffTPCost(mpBuffActions)

		integer totalAvailableTP = ctx.initialTP - mpBuffTPCost - swapCost
		integer postMP = ctx.initialMP + ComboBuilder._sumMPGain(mpBuffActions) - mpToCast

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 2: Select best cells with MP-valid path
		// ═══════════════════════════════════════════════════════════════════════════

		// For inversion: includeAllySupport based on target type
		// For repotting: never include ally support (target IS the ally bulb)
		boolean includeAllySupport = useScoreBonus && candidate.target.isFriend

		Array<Action> postPool = MapTactical.getPostSwapPool(
			candidate.target,
			candidate.selfNewCell,
			candidate.targetNewCell,
			candidate.item,
			postMP,
			includeAllySupport
		)

		// Group actions by cell, find valid movement sequences
		Map<Cell, Array<Action>> cellActions = [:]
		Array<Array<Cell>> validSequences = ComboBuilder._findCellSequences(
			postPool, newSelfCell, postMP, castCell, cellActions)

		// Build combo for each valid sequence, keep the best
		Combo? bestCombo = null
		for (Array<Cell> selectedCells in validSequences) {
			Combo? combo = ComboBuilder._buildSwapComboForSequence(
				ctx, candidate, selectedCells, cellActions,
				mpBuffActions, totalAvailableTP,
				startCell, castCell, newSelfCell,
				swapItem, swapCost, mpToCast, useScoreBonus)

			if (combo != null) {
				if (bestCombo == null || combo!.getScore()! > bestCombo!.getScore()!) {
					bestCombo = combo
				}
			}
		}

		return bestCombo
	}

	/*
	 * Build swap combo for a specific cell sequence.
	 * Unified helper for inversion and repotting.
	 */
	static Combo? _buildSwapComboForSequence(
		ExplorationContext ctx,
		MovementCandidate candidate,
		Array<Cell> selectedCells,
		Map<Cell, Array<Action>> cellActions,
		Array<Action> mpBuffActions,
		integer totalAvailableTP,
		Cell startCell,
		Cell castCell,
		Cell newSelfCell,
		Item swapItem,
		integer swapCost,
		integer mpToCast,
		boolean useScoreBonus
	) {
		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 3: Pool actions from selected cells, single knapsack
		// ═══════════════════════════════════════════════════════════════════════════

		Array<Action> combinedPool = ComboBuilder._poolFromCells(selectedCells, cellActions)
		Array<Action> selectedPost = ActionKnapsack.solve(combinedPool, totalAvailableTP, ctx.initialWeapon, null)
		integer postTPUsed = ComboBuilder._sumTPCost(selectedPost, ctx.initialWeapon)

		// Pre-swap pool (actions at start cell)
		Array<Action> prePool = []
		Array<Action> startActions = MapCellScore.getActionsForCell(startCell)
		for (Action a in startActions) {
			if (a.score != null && a.score! > 0) {
				push(prePool, a)
			}
		}

		integer preTP = totalAvailableTP - postTPUsed
		Array<Action> selectedPre = []
		if (preTP > 0) {
			Map<Item, integer> postUsage = ComboBuilder._countUsage(selectedPost)
			Array<Action> filteredPre = ComboBuilder._filterByUsage(prePool, postUsage)
			selectedPre = ActionKnapsack.solve(filteredPre, preTP, ctx.initialWeapon, null)
		}

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 4: Partition selected actions back to cells
		// ═══════════════════════════════════════════════════════════════════════════

		Map<Cell, Array<Action>> partitioned = ComboBuilder._partitionToCells(selectedPost, selectedCells, newSelfCell)

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 5: Build combo in sequence order
		// ═══════════════════════════════════════════════════════════════════════════

		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		// 0. MP buffs first
		ComboBuilder._applyBuffs(combo, mpBuffActions, usesThisTurn)

		Consequences buffedCsq = combo.getCurrentConsequences()
		if (buffedCsq.currentMP < mpToCast) return null

		// 1. Pre-actions (sorted by priority)
		selectedPre = MapCellScore.sortByPriority(selectedPre)
		for (Action a in selectedPre) {
			ComboBuilder._tryAddActionImpl(combo, a, usesThisTurn, 0, swapCost, Fight.self.cellsToIgnore)
		}

		// 2. Swap action
		Consequences priorCsq = combo.getCurrentConsequences()
		if (priorCsq.currentMP < mpToCast) return null

		Action swapAction = Action(swapItem, castCell, candidate.targetCell)
		swapAction.movementCandidate = candidate

		Action actualizedSwap = Action(swapAction, priorCsq)

		// Score handling differs: inversion adds candidate.score, repotting doesn't
		if (useScoreBonus) {
			actualizedSwap.consequences.score += candidate.score
			actualizedSwap.score = actualizedSwap.consequences.getScore()
			if (actualizedSwap.score! <= priorCsq.score!) return null
		}

		push(combo.actions, actualizedSwap)
		usesThisTurn[swapItem] = 1

		// 3. Post-actions in sequence order
		for (Cell cell in selectedCells) {
			Array<Action>? actions = partitioned[cell]
			if (actions == null) continue

			for (Action a in actions!) {
				ComboBuilder.tryAddAction(combo, a, usesThisTurn, 0)
			}
		}

		// Final position
		ComboBuilder._addFinalPosition(combo)

		return combo
	}

	/*
	 * Build combo with simple attract (grapple only) as first-class strategy.
	 * Delegates to unified _buildWithMove.
	 */
	static Combo? buildWithAttract(ExplorationContext ctx, MovementCandidate candidate) {
		if (Fight.grappleItem == null) return null
		return ComboBuilder._buildWithMove(ctx, candidate)
	}

	/*
	 * Build combo with simple push (boxing glove only) as first-class strategy.
	 * Delegates to unified _buildWithMove.
	 */
	static Combo? buildWithPush(ExplorationContext ctx, MovementCandidate candidate) {
		if (Fight.boxingGloveItem == null) return null
		return ComboBuilder._buildWithMove(ctx, candidate)
	}

	/*
	 * Unified move combo builder for attract (grapple) and push (boxing glove).
	 * Unlike swap, we stay at cast position - only target moves.
	 * Uses same cell-sequence pattern as _buildWithSwap for optimal ordering.
	 *
	 * Flow:
	 * 1. Calculate MP buffs to reach cast position
	 * 2. Get post-move pool and group by fromCell
	 * 3. Find valid cell sequences (optimal ordering)
	 * 4. Build combo for each sequence, keep the best
	 *
	 * @param ctx Exploration context with initial resources
	 * @param candidate Movement candidate (attract or push type)
	 * @return Combo, or null if not feasible
	 */
	static Combo? _buildWithMove(ExplorationContext ctx, MovementCandidate candidate) {
		Item moveItem = candidate.item
		Cell castCell = candidate.fromCell  // Where we cast from (and stay after move)

		integer moveCost = moveItem.cost
		integer mpToCast = candidate.mpCost

		// Check basic feasibility
		if (ctx.initialTP < moveCost) return null

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 1: Calculate MP buffs
		// ═══════════════════════════════════════════════════════════════════════════

		Array<Action>? mpBuffResult = ComboBuilder._getMPBuffs(mpToCast, ctx.initialMP, ctx.maxMPBuff, ctx.initialTP - moveCost)
		if (mpBuffResult == null) return null
		Array<Action> mpBuffActions = mpBuffResult!
		integer mpBuffTPCost = ComboBuilder._sumBuffTPCost(mpBuffActions)

		integer totalAvailableTP = ctx.initialTP - mpBuffTPCost - moveCost
		integer postMP = ctx.initialMP + ComboBuilder._sumMPGain(mpBuffActions) - mpToCast

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 2: Get post-move pool and group by fromCell
		// ═══════════════════════════════════════════════════════════════════════════

		Array<Action> postPool = MapTactical.getPostMovePool(
			candidate.target,
			candidate.selfNewCell,
			candidate.targetNewCell,
			candidate.item,
			postMP,
			candidate.target.isFriend
		)

		// Group actions by cell, find valid movement sequences
		Map<Cell, Array<Action>> cellActions = [:]
		Array<Array<Cell>> validSequences = ComboBuilder._findCellSequences(
			postPool, castCell, postMP, candidate.targetNewCell, cellActions)

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 3: Build combo for each valid sequence, keep the best
		// ═══════════════════════════════════════════════════════════════════════════

		Combo? bestCombo = null
		for (Array<Cell> selectedCells in validSequences) {
			Combo? combo = ComboBuilder._buildMoveComboForSequence(
				ctx, candidate, selectedCells, cellActions,
				mpBuffActions, totalAvailableTP,
				castCell, moveItem, moveCost, mpToCast)

			if (combo != null) {
				if (bestCombo == null || combo!.getScore()! > bestCombo!.getScore()!) {
					bestCombo = combo
				}
			}
		}

		return bestCombo
	}

	/*
	 * Build move combo for a specific cell sequence.
	 * Unified helper for attract (grapple) and push (boxing glove).
	 */
	static Combo? _buildMoveComboForSequence(
		ExplorationContext ctx,
		MovementCandidate candidate,
		Array<Cell> selectedCells,
		Map<Cell, Array<Action>> cellActions,
		Array<Action> mpBuffActions,
		integer totalAvailableTP,
		Cell castCell,
		Item moveItem,
		integer moveCost,
		integer mpToCast
	) {
		// Pool actions, knapsack, partition back to cells
		Array<Action> combinedPool = ComboBuilder._poolFromCells(selectedCells, cellActions)
		Array<Action> selectedPost = ActionKnapsack.solve(combinedPool, totalAvailableTP, ctx.initialWeapon, null)
		Map<Cell, Array<Action>> partitioned = ComboBuilder._partitionToCells(selectedPost, selectedCells, castCell)

		// ═══════════════════════════════════════════════════════════════════════════
		// Build combo in sequence order
		// ═══════════════════════════════════════════════════════════════════════════

		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		// 0. MP buffs first
		ComboBuilder._applyBuffs(combo, mpBuffActions, usesThisTurn)

		Consequences buffedCsq = combo.getCurrentConsequences()
		if (buffedCsq.currentMP < mpToCast) return null

		// 1. Move action (grapple/push) - we end up at castCell
		Consequences priorCsq = combo.getCurrentConsequences()
		Action moveAction = Action(moveItem, castCell, candidate.targetNewCell)
		moveAction.movementCandidate = candidate
		moveAction.overrideTargets = <candidate.target>

		Action actualizedMove = Action(moveAction, priorCsq)
		actualizedMove.consequences.score += candidate.score
		actualizedMove.score = actualizedMove.consequences.getScore()

		if (actualizedMove.score! <= priorCsq.score!) return null
		push(combo.actions, actualizedMove)
		usesThisTurn[moveItem] = 1

		// 2. Post-move actions in cell sequence order
		for (Cell cell in selectedCells) {
			Array<Action>? actions = partitioned[cell]
			if (actions == null) continue

			for (Action a in actions!) {
				ComboBuilder.tryAddAction(combo, a, usesThisTurn, 0)
			}
		}

		// Final position
		ComboBuilder._addFinalPosition(combo)

		return combo
	}

	/*
	 * Build combo with attract-push (grapple + boxing glove) as first-class strategy.
	 * Executes tactical sequence then fills remaining TP with actions.
	 *
	 * Flow:
	 * 1. Calculate MP buffs to reach grapple position
	 * 2. Execute: [buffs] → grapple → move to boxing position → boxing
	 * 3. Fill remaining TP with actions from final position
	 * 4. Final positioning
	 *
	 * @param ctx Exploration context with initial resources
	 * @param candidate AttractPush combo candidate
	 * @return Combo, or null if not feasible
	 */
	static Combo? buildWithAttractPush(ExplorationContext ctx, AttractPushCandidate candidate) {
		if (Fight.grappleItem == null || Fight.boxingGloveItem == null) return null

		Item grappleItem = candidate.grappleItem
		Item boxingItem = candidate.boxingItem

		integer comboTPCost = candidate.totalTP
		integer comboMPCost = candidate.totalMP

		// Check basic feasibility
		if (ctx.initialTP < comboTPCost) return null
		if (ctx.initialMP + ctx.maxMPBuff < comboMPCost) return null

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 1: Calculate MP buffs
		// ═══════════════════════════════════════════════════════════════════════════

		Array<Action>? mpBuffResult = ComboBuilder._getMPBuffs(comboMPCost, ctx.initialMP, ctx.maxMPBuff, ctx.initialTP - comboTPCost)
		if (mpBuffResult == null) return null
		Array<Action> mpBuffActions = mpBuffResult!
		integer mpBuffTPCost = ComboBuilder._sumBuffTPCost(mpBuffActions)

		integer remainingTP = ctx.initialTP - mpBuffTPCost - comboTPCost
		integer remainingMP = ctx.initialMP + ComboBuilder._sumMPGain(mpBuffActions) - comboMPCost

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 2: Build combo with tactical sequence
		// ═══════════════════════════════════════════════════════════════════════════

		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		// 0. MP buffs
		ComboBuilder._applyBuffs(combo, mpBuffActions, usesThisTurn)

		// 1. Grapple action - target destination cell (where enemy lands after pull)
		// LOS to enemy is validated in MapTactical candidate generation
		Consequences priorCsq = combo.getCurrentConsequences()
		Action grappleAction = Action(grappleItem, candidate.grappleFromCell, candidate.afterGrappleCell)
		// Create MovementCandidate for grapple (score=0, combo score goes on boxing)
		MovementCandidate grappleMC = MovementCandidate.forAttract(
			grappleItem, candidate.grappleFromCell, candidate.target,
			candidate.afterGrappleCell, 0, 0)  // MP already accounted, score on boxing
		grappleAction.movementCandidate = grappleMC
		grappleAction.overrideTargets = <candidate.target>

		Action actualizedGrapple = Action(grappleAction, priorCsq)
		push(combo.actions, actualizedGrapple)
		usesThisTurn[grappleItem] = 1

		// 2. Boxing action - target destination cell (where entity lands after push)
		// LOS to destination is validated in MapTactical candidate generation
		priorCsq = combo.getCurrentConsequences()
		// Update position: we moved from grappleFromCell to boxingFromCell (costs transitionMP)
		priorCsq.currentCell = candidate.boxingFromCell
		priorCsq.currentMP = remainingMP  // transitionMP already deducted in comboMPCost

		Action boxingAction = Action(boxingItem, candidate.boxingFromCell, candidate.finalCell)
		// Create MovementCandidate for boxing with the combo score
		MovementCandidate boxingMC = MovementCandidate.forPush(
			boxingItem, candidate.boxingFromCell, candidate.target,
			candidate.finalCell, 0, candidate.score)  // Full combo score here
		boxingAction.movementCandidate = boxingMC
		boxingAction.overrideTargets = <candidate.target>

		Action actualizedBoxing = Action(boxingAction, priorCsq)
		push(combo.actions, actualizedBoxing)
		usesThisTurn[boxingItem] = 1

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 3: Fill remaining TP with actions from final position
		// ═══════════════════════════════════════════════════════════════════════════

		// Use proper post-pool with simulated enemy position
		// After combo: we are at boxingFromCell, enemy is at finalCell
		Array<Action> postPool = MapTactical.getPostMovePool(
			candidate.target,
			candidate.boxingFromCell,  // where we are
			candidate.finalCell,       // where enemy ends up
			boxingItem,
			remainingMP,
			false  // enemy target, no ally support
		)

		// Fill with cell-sequenced actions
		ComboBuilder._fillWithCellSequencing(
			combo, postPool, candidate.boxingFromCell, candidate.finalCell,
			remainingTP, remainingMP, usesThisTurn, ctx.initialWeapon)

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 4: Final position
		// ═══════════════════════════════════════════════════════════════════════════

		ComboBuilder._addFinalPosition(combo)

		return combo
	}

	/*
	 * Build combo with pull-inversion-push (grapple + inversion + boxing) as first-class strategy.
	 * Executes 3-action tactical sequence then fills remaining TP.
	 *
	 * Flow:
	 * 1. Calculate MP buffs to reach grapple position
	 * 2. Execute: [buffs] → grapple → inversion → move 1 → boxing
	 * 3. Fill remaining TP with actions from final position
	 * 4. Final positioning
	 *
	 * @param ctx Exploration context with initial resources
	 * @param candidate PullInversionPush combo candidate
	 * @return Combo, or null if not feasible
	 */
	static Combo? buildWithPullInvPush(ExplorationContext ctx, PullInversionPushCandidate candidate) {
		if (Fight.grappleItem == null || Fight.inversionItem == null || Fight.boxingGloveItem == null) return null

		Item grappleItem = candidate.grappleItem
		Item inversionItem = candidate.inversionItem
		Item boxingItem = candidate.boxingItem

		integer comboTPCost = candidate.totalTP
		integer comboMPCost = candidate.totalMP

		// Check basic feasibility
		if (ctx.initialTP < comboTPCost) return null
		if (ctx.initialMP + ctx.maxMPBuff < comboMPCost) return null

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 1: Calculate MP buffs
		// ═══════════════════════════════════════════════════════════════════════════

		Array<Action>? mpBuffResult = ComboBuilder._getMPBuffs(comboMPCost, ctx.initialMP, ctx.maxMPBuff, ctx.initialTP - comboTPCost)
		if (mpBuffResult == null) return null
		Array<Action> mpBuffActions = mpBuffResult!
		integer mpBuffTPCost = ComboBuilder._sumBuffTPCost(mpBuffActions)

		integer remainingTP = ctx.initialTP - mpBuffTPCost - comboTPCost
		integer remainingMP = ctx.initialMP + ComboBuilder._sumMPGain(mpBuffActions) - comboMPCost

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 2: Build combo with tactical sequence
		// ═══════════════════════════════════════════════════════════════════════════

		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		// 0. MP buffs
		ComboBuilder._applyBuffs(combo, mpBuffActions, usesThisTurn)

		// 1. Grapple action - target destination cell (where enemy lands after pull)
		// LOS to enemy is validated in MapTactical candidate generation
		Consequences priorCsq = combo.getCurrentConsequences()
		Action grappleAction = Action(grappleItem, candidate.grappleFromCell, candidate.afterGrappleCell)
		// Create MovementCandidate for grapple (score=0, combo score goes on boxing)
		MovementCandidate grappleMC = MovementCandidate.forAttract(
			grappleItem, candidate.grappleFromCell, candidate.target,
			candidate.afterGrappleCell, 0, 0)
		grappleAction.movementCandidate = grappleMC
		grappleAction.overrideTargets = <candidate.target>

		Action actualizedGrapple = Action(grappleAction, priorCsq)
		push(combo.actions, actualizedGrapple)
		usesThisTurn[grappleItem] = 1

		// 2. Inversion action (swap with enemy at afterGrappleCell)
		priorCsq = combo.getCurrentConsequences()
		Action inversionAction = Action(inversionItem, candidate.grappleFromCell, candidate.afterGrappleCell)
		// Create MovementCandidate for inversion (score=0, combo score goes on boxing)
		MovementCandidate invMC = MovementCandidate.forInversion(
			inversionItem, candidate.grappleFromCell, candidate.target, 0, 0)
		inversionAction.movementCandidate = invMC
		inversionAction.overrideTargets = <candidate.target>

		Action actualizedInv = Action(inversionAction, priorCsq)
		push(combo.actions, actualizedInv)
		usesThisTurn[inversionItem] = 1

		// 3. Boxing action - target destination cell (where entity lands after push)
		// LOS to destination is validated in MapTactical candidate generation
		priorCsq = combo.getCurrentConsequences()
		// After inversion we're at afterGrappleCell, move 1 cell back to pushFromCell for minRange 2
		priorCsq.currentCell = candidate.pushFromCell
		priorCsq.currentMP = remainingMP  // transitionMP already deducted in comboMPCost

		Action boxingAction = Action(boxingItem, candidate.pushFromCell, candidate.finalCell)
		// Create MovementCandidate for boxing with the combo score
		MovementCandidate boxingMC = MovementCandidate.forPush(
			boxingItem, candidate.pushFromCell, candidate.target,
			candidate.finalCell, 0, candidate.score)  // Full combo score here
		boxingAction.movementCandidate = boxingMC
		boxingAction.overrideTargets = <candidate.target>

		Action actualizedBoxing = Action(boxingAction, priorCsq)
		push(combo.actions, actualizedBoxing)
		usesThisTurn[boxingItem] = 1

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 3: Fill remaining TP with actions from final position
		// ═══════════════════════════════════════════════════════════════════════════

		// Use proper post-pool with simulated enemy position
		// After combo: we are at pushFromCell, enemy is at finalCell
		Array<Action> postPool = MapTactical.getPostMovePool(
			candidate.target,
			candidate.pushFromCell,  // where we are
			candidate.finalCell,     // where enemy ends up
			boxingItem,
			remainingMP,
			false  // enemy target, no ally support
		)

		// Fill with cell-sequenced actions
		ComboBuilder._fillWithCellSequencing(
			combo, postPool, candidate.pushFromCell, candidate.finalCell,
			remainingTP, remainingMP, usesThisTurn, ctx.initialWeapon)

		// ═══════════════════════════════════════════════════════════════════════════
		// PHASE 4: Final position
		// ═══════════════════════════════════════════════════════════════════════════

		ComboBuilder._addFinalPosition(combo)

		return combo
	}

	/*
	 * Group actions by fromCell, sort cells by score, find valid movement sequences.
	 * Combines cell grouping, reachability computation, and sequence selection.
	 *
	 * @param pool Actions to group
	 * @param startCell Self-cell mapping AND reachability origin
	 * @param availableMP MP for reachability computation
	 * @param obstacleCell Cell occupied by moved/swapped entity (obstacle for pathfinding)
	 * @param outCellActions Mutated: filled with actions grouped by fromCell
	 * @return Valid cell sequences (with [[startCell]] fallback)
	 */
	static Array<Array<Cell>> _findCellSequences(
		Array<Action> pool,
		Cell startCell,
		integer availableMP,
		Cell obstacleCell,
		Map<Cell, Array<Action>> outCellActions
	) {
		// Group actions by fromCell and compute cell scores
		Map<Cell, real> cellScores = [:]

		for (Action a in pool) {
			Cell fromCell = a.from
			if (fromCell == Fight.selfCell) fromCell = startCell
			if (outCellActions[fromCell] == null) {
				outCellActions[fromCell] = []
				cellScores[fromCell] = 0
			}
			push(outCellActions[fromCell]!, a)
			if (a.score != null) cellScores[fromCell] += a.score!
		}

		// Sort cells by score descending
		Array<Cell> sortedCells = []
		for (Cell c : real score in cellScores) {
			push(sortedCells, c)
		}
		sortedCells = arraySort(sortedCells, (Cell a, Cell b) -> integer {
			return Sort.desc(cellScores[a]!, cellScores[b]!)
		}) as Array<Cell>

		// Compute reachability
		Set<Cell> newObstacles = <obstacleCell>
		Map<Cell, integer> reachable = MapPath.getCachedReachableCells(
			startCell, availableMP, Fight.self.cellsToIgnore, newObstacles)

		// Get valid cell sequences
		Array<Array<Cell>> validSequences = ComboBuilder._getValidCellSequences(
			sortedCells, cellScores, startCell, availableMP, reachable, newObstacles)

		if (count(validSequences) == 0) {
			return [[startCell]]
		}
		return validSequences
	}

	/*
	 * Pool actions from cells, deduplicated by actionKey.
	 */
	static Array<Action> _poolFromCells(Array<Cell> cells, Map<Cell, Array<Action>> cellActions) {
		Array<Action> combined = []
		Map<integer, boolean> seenKeys = [:]
		for (Cell cell in cells) {
			Array<Action>? actions = cellActions[cell]
			if (actions == null) continue
			for (Action a in actions!) {
				integer key = ComboBuilder.actionKey(a)
				if (!seenKeys[key]) {
					push(combined, a)
					seenKeys[key] = true
				}
			}
		}
		return combined
	}

	/*
	 * Partition selected actions back to cells, sorted by priority.
	 * Actions with from=Fight.selfCell are mapped to selfMapping.
	 * Actions not matching any cell fall back to first cell.
	 */
	static Map<Cell, Array<Action>> _partitionToCells(Array<Action> selected, Array<Cell> cells, Cell selfMapping) {
		Map<Cell, Array<Action>> partitioned = [:]
		for (Cell cell in cells) {
			partitioned[cell] = []
		}

		for (Action a in selected) {
			Cell fromCell = a.from
			if (fromCell == Fight.selfCell) fromCell = selfMapping
			if (partitioned[fromCell] != null) {
				push(partitioned[fromCell]!, a)
			} else {
				push(partitioned[cells[0]]!, a)
			}
		}

		for (Cell cell in cells) {
			partitioned[cell] = MapCellScore.sortByPriority(partitioned[cell]!)
		}

		return partitioned
	}

	/*
	 * Get all valid cell sequences for the first valid pair.
	 * Returns both orderings if both are MP-valid, otherwise just the valid one.
	 * Falls back to single cell if no pair works.
	 *
	 * @param sortedCells Cells sorted by score descending
	 * @param cellScores Score per cell
	 * @param newSelfCell Where we start after inversion
	 * @param availableMP MP available after inversion
	 * @param reachableFromNew Reachability map from newSelfCell
	 * @param obstacles Obstacles for pathfinding (swapped entity position)
	 * @return Array of valid cell sequences (1-2 sequences, each with 1-2 cells)
	 */
	static Array<Array<Cell>> _getValidCellSequences(
		Array<Cell> sortedCells,
		Map<Cell, real> cellScores,
		Cell newSelfCell,
		integer availableMP,
		Map<Cell, integer> reachableFromNew,
		Set<Cell> obstacles
	) {
		integer n = count(sortedCells)
		if (n == 0) return []

		// Try pairs: best+2nd, best+3rd, 2nd+3rd, etc.
		// For the first pair with at least one valid ordering, return all valid orderings
		for (integer i = 0; i < min(n, 5); i++) {
			for (integer j = i + 1; j < min(n, 5); j++) {
				Cell cellA = sortedCells[i]
				Cell cellB = sortedCells[j]

				// Check both orderings for this pair
				Array<Cell>? seqAB = ComboBuilder._tryPairOrder(
					cellA, cellB, newSelfCell, availableMP, reachableFromNew, obstacles)
				Array<Cell>? seqBA = ComboBuilder._tryPairOrder(
					cellB, cellA, newSelfCell, availableMP, reachableFromNew, obstacles)

				// If at least one ordering is valid, return all valid orderings for THIS pair
				if (seqAB != null || seqBA != null) {
					Array<Array<Cell>> result = []
					if (seqAB != null) push(result, seqAB!)
					if (seqBA != null) push(result, seqBA!)
					return result
				}
			}
		}

		// No valid pair - use single best reachable cell
		for (Cell cell in sortedCells) {
			if (cell == newSelfCell) return [[cell]]
			integer? dist = reachableFromNew[cell]
			if (dist != null && dist! <= availableMP) return [[cell]]
		}

		// Nothing reachable - just stay at newSelfCell
		return [[newSelfCell]]
	}

	/*
	 * Try a specific pair ordering: first -> second
	 * Returns the sequence if MP-valid, null otherwise.
	 */
	static Array<Cell>? _tryPairOrder(
		Cell first,
		Cell second,
		Cell newSelfCell,
		integer availableMP,
		Map<Cell, integer> reachableFromNew,
		Set<Cell> obstacles
	) {
		// Cost to reach first cell
		integer costToFirst = 0
		if (first != newSelfCell) {
			integer? dist = reachableFromNew[first]
			if (dist == null || dist! > availableMP) return null
			costToFirst = dist!
		}

		// MP remaining after reaching first cell
		integer mpAfterFirst = availableMP - costToFirst

		// Cost to reach second cell from first
		if (second == first) return [first]  // Same cell, just use single

		Map<Cell, integer> reachableFromFirst = MapPath.getCachedReachableCells(
			first, mpAfterFirst, Fight.self.cellsToIgnore, obstacles)

		integer? costToSecond = reachableFromFirst[second]
		if (costToSecond == null || costToSecond! > mpAfterFirst) return null

		// Valid path!
		return [first, second]
	}

	/*
	 * Fill combo with post-actions using cell-sequence optimization.
	 * Groups actions by fromCell, finds valid sequences, adds actions in optimal order.
	 * Used by attract-push and pull-inversion-push combo builders.
	 *
	 * @param combo Combo to add actions to
	 * @param postPool Pool of available post-actions
	 * @param startCell Current position (where we are after tactical sequence)
	 * @param obstacleCell Cell occupied by moved entity (obstacle for pathfinding)
	 * @param remainingTP TP available for fill actions
	 * @param remainingMP MP available for movement between cells
	 * @param usesThisTurn Item usage tracking map
	 * @param startWeapon Current weapon for TP cost calculation
	 */
	static void _fillWithCellSequencing(
		Combo combo,
		Array<Action> postPool,
		Cell startCell,
		Cell obstacleCell,
		integer remainingTP,
		integer remainingMP,
		Map<Item, integer> usesThisTurn,
		Item? startWeapon
	) {
		if (remainingTP <= 0 || count(postPool) == 0) return;

		// Group actions by cell, find valid movement sequences
		Map<Cell, Array<Action>> cellActions = [:]
		Array<Array<Cell>> validSequences = ComboBuilder._findCellSequences(
			postPool, startCell, remainingMP, obstacleCell, cellActions)

		// Find best sequence by trying each and computing total score
		Array<Cell>? bestSequence = null
		real bestScore = -999999
		Array<Action>? bestSelected = null

		for (Array<Cell> selectedCells in validSequences) {
			Array<Action> combinedPool = ComboBuilder._poolFromCells(selectedCells, cellActions)
			Array<Action> selected = ActionKnapsack.solve(combinedPool, remainingTP, startWeapon, null)
			real totalScore = ComboBuilder._sumActionScores(selected)

			if (totalScore > bestScore) {
				bestScore = totalScore
				bestSequence = selectedCells
				bestSelected = selected
			}
		}

		if (bestSequence == null || bestSelected == null) return;

		Map<Cell, Array<Action>> partitioned = ComboBuilder._partitionToCells(bestSelected!, bestSequence!, startCell)

		// Add actions in cell sequence order
		for (Cell cell in bestSequence!) {
			Array<Action>? actions = partitioned[cell]
			if (actions == null) continue

			for (Action a in actions!) {
				ComboBuilder.tryAddAction(combo, a, usesThisTurn, 0)
			}
		}
	}

	/*
	 * Sum TP cost of actions, accounting for weapon switches.
	 */
	static integer _sumTPCost(Array<Action> actions, Item? startWeapon) {
		integer total = 0
		Item? currentWeapon = startWeapon
		for (Action a in actions) {
			if (a.item.isWeap && (currentWeapon == null || a.item.id != currentWeapon!.id)) {
				total += 1  // Weapon switch cost
				currentWeapon = a.item
			}
			total += a.item.cost
		}
		return total
	}

	/*
	 * Sum MP gain from buff actions.
	 * Each buff action's consequences is computed independently (base + that buff's gain),
	 * so we sum individual gains (each is consequences.currentMP - baseMP).
	 */
	static integer _sumMPGain(Array<Action> buffs) {
		integer baseMP = Fight.self.mp
		integer totalGain = 0
		for (Action a in buffs) {
			totalGain += a.consequences.currentMP - baseMP
		}
		return totalGain
	}

	/*
	 * Count item usage in an action array.
	 */
	static Map<Item, integer> _countUsage(Array<Action> actions) {
		Map<Item, integer> usage = [:]
		for (Action a in actions) {
			integer count = usage[a.item] != null ? usage[a.item]! : 0
			usage[a.item] = count + 1
		}
		return usage
	}

	/*
	 * Filter actions by remaining usage (after some items already used).
	 */
	static Array<Action> _filterByUsage(Array<Action> pool, Map<Item, integer> usedCounts) {
		Array<Action> filtered = []
		Map<Item, integer> remaining = [:]
		for (Action a in pool) {
			integer used = usedCounts[a.item] != null ? usedCounts[a.item]! : 0
			integer seen = remaining[a.item] != null ? remaining[a.item]! : 0
			if (used + seen < a.item.maxUse) {
				push(filtered, a)
				remaining[a.item] = seen + 1
			}
		}
		return filtered
	}

	/*
	 * Sum scores of actions in an array.
	 */
	static real _sumActionScores(Array<Action> actions) {
		real total = 0
		for (Action a in actions) {
			if (a.score != null) total += a.score!
		}
		return total
	}

	// ════════════════════════════════════════════════════════════
	// JUMP COMBO METHODS
	// ════════════════════════════════════════════════════════════

	/*
	 * Find a jump route from walk-reachable cells to a target cell.
	 * Returns [launchCell, jumpDest] where:
	 *   - launchCell is in walkMap (walk-reachable)
	 *   - jumpDest is within AREA_CIRCLE_3 of launchCell
	 *   - target is walk-reachable from jumpDest (or jumpDest == target)
	 * Minimizes total MP cost (walk to launch + walk from jumpDest to target).
	 * Returns null if no route exists.
	 */
	static Array<Cell>? _findJumpRoute(Cell target, Map<Cell, integer> walkMap, integer maxMP, Set<Cell> ignoreCells) {
		Cell? bestLaunch = null
		Cell? bestDest = null
		integer bestCost = maxMP + 1

		// Pass 1: Direct jump to target (O(|jumpDests|), very cheap)
		// Reverse lookup: cells within AREA_CIRCLE_3 of target that are in walkMap
		for (Cell L in MapPath.getJumpDests(target)) {
			integer? walkToL = walkMap[L]
			if (walkToL == null) continue
			if (walkToL! < bestCost) {
				bestCost = walkToL!
				bestLaunch = L
				bestDest = target
			}
		}

		// If direct jump found at cost 0, it's optimal
		if (bestCost == 0) return [bestLaunch!, bestDest!]

		// Pass 2: Indirect — jump near target, then walk
		integer opsStart = getOperations()
		integer opsBudget = 50000  // Limit ops for indirect search

		for (Cell L : integer walkToL in walkMap) {
			if (getOperations() - opsStart > opsBudget) break
			if (walkToL >= bestCost) continue  // Can't improve

			for (Cell J in MapPath.getJumpDests(L)) {
				// Quick prune: cell distance is lower bound for walk distance
				integer cellDist = getCellDistance(J.id, target.id)
				if (cellDist > maxMP - walkToL) continue
				if (walkToL + cellDist >= bestCost) continue

				// Skip if J is occupied (not walkable)
				if (Board.entityCells[J] && !setContains(ignoreCells, J)) continue

				// Actual walk check from J to target
				Map<Cell, integer> reachFromJ = MapPath.getCachedReachableCells(J, maxMP - walkToL, ignoreCells)
				integer? walkJToTarget = reachFromJ[target]
				if (walkJToTarget != null) {
					integer totalCost = walkToL + walkJToTarget!
					if (totalCost < bestCost) {
						bestCost = totalCost
						bestLaunch = L
						bestDest = J
					}
				}
			}
		}

		if (bestLaunch == null) return null
		return [bestLaunch!, bestDest!]
	}

	/*
	 * Build combo at a cell reachable only via jump.
	 * Pattern: [MP buffs] → [walk to launch] → [jump] → [walk to cell] → [attacks]
	 */
	static Combo? buildAtCellWithJump(ExplorationContext ctx, Cell cell) {
		if (!ctx.hasJump || ctx.jumpItem == null) return null

		Item jumpItem = ctx.jumpItem!
		integer jumpCost = jumpItem.cost

		// Not enough TP for jump + at least one attack
		if (ctx.initialTP < jumpCost + 2) return null

		// Find jump route using extended walk map
		Array<Cell>? route = ComboBuilder._findJumpRoute(
			cell, ctx.extendedReachableCells, ctx.initialMP + ctx.maxMPBuff, ctx.cellsToIgnore)
		if (route == null) return null

		Cell launchCell = route![0]
		Cell jumpDest = route![1]

		// Walk distance to launch cell
		integer? walkToLaunch = ctx.extendedReachableCells[launchCell]
		if (walkToLaunch == null) return null
		integer walkDist = walkToLaunch!

		// Compute post-jump walk distance (jumpDest → cell) BEFORE MP buffs
		integer walkFromJump = 0
		if (jumpDest != cell) {
			Map<Cell, integer> reachFromDest = MapPath.getCachedReachableCells(
				jumpDest, ctx.initialMP + ctx.maxMPBuff - walkDist, ctx.cellsToIgnore)
			integer? dist = reachFromDest[cell]
			if (dist == null) return null
			walkFromJump = dist!
		}
		integer totalWalk = walkDist + walkFromJump

		// Calculate MP buffs for TOTAL walk (pre-jump + post-jump)
		Array<Action>? mpBuffResult = ComboBuilder._getMPBuffs(totalWalk, ctx.initialMP, ctx.maxMPBuff, ctx.initialTP - jumpCost)
		if (mpBuffResult == null) return null
		Array<Action> mpBuffActions = mpBuffResult!
		integer mpBuffTPCost = ComboBuilder._sumBuffTPCost(mpBuffActions)

		// Check TP budget: buffs + jump + at least 2 TP for attacks
		if (ctx.initialTP - mpBuffTPCost - jumpCost < 2) return null

		// Build combo
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		// 1. Apply MP buff actions
		ComboBuilder._applyBuffs(combo, mpBuffActions, usesThisTurn)

		// 2. Create and add jump action
		Consequences priorCsq = combo.getCurrentConsequences()

		// Check we have enough MP after buffs to reach launch cell
		if (priorCsq.currentMP < walkDist) return null

		Action jumpAction = Action(jumpItem, launchCell, jumpDest)
		Action actualizedJump = Action(jumpAction, priorCsq)

		// Override position: after jump, we're at jumpDest
		actualizedJump.consequences.currentCell = jumpDest

		// Deduct MP for walking to launch cell
		actualizedJump.consequences.currentMP = priorCsq.currentMP - walkDist

		// Push directly (bypass combo.add score check — jump has no intrinsic damage score)
		push(combo.actions, actualizedJump)
		usesThisTurn[jumpItem] = 1

		// 3. Calculate remaining resources
		integer remainingTP = actualizedJump.consequences.currentTP
		integer remainingMP = actualizedJump.consequences.currentMP
		Item? weapon = actualizedJump.consequences.currentWeapon

		// Deduct post-jump walk (distance already validated above)
		if (walkFromJump > 0) {
			if (remainingMP < walkFromJump) return null
			remainingMP -= walkFromJump
		}

		// 4. Get actions for target cell, exclude used items
		Array<Action> pool = MapCellScore.getActionsForCell(cell)
		pool = ComboBuilder._excludeUsed(pool, usesThisTurn)

		// 5. Build core into combo (knapsack, greedy, position)
		ComboBuilder._buildCoreInto(
			ctx, combo, usesThisTurn, pool, remainingTP, weapon,
			0,      // reserveMP (all MP committed to reach)
			null,   // stopWhenKilled
			true    // restrictToCell
		)

		return count(combo.actions) > 1 ? combo : null  // > 1 because jump action is always there
	}

	// ════════════════════════════════════════════════════════════
	// TELEPORT COMBO METHODS
	// ════════════════════════════════════════════════════════════

	/*
	 * Find a teleport route from walk-reachable cells to a target cell.
	 * Returns [launchCell, teleportDest] where:
	 *   - launchCell is in walkMap (walk-reachable)
	 *   - teleportDest is within teleport range of launchCell
	 *   - target is walk-reachable from teleportDest (or teleportDest == target)
	 * Minimizes total MP cost (walk to launch + walk from teleportDest to target).
	 * Returns null if no route exists.
	 */
	static Array<Cell>? _findTeleportRoute(Cell target, Map<Cell, integer> walkMap, integer maxMP,
			Set<Cell> ignoreCells, Item teleportItem) {
		Cell? bestLaunch = null
		Cell? bestDest = null
		integer bestCost = maxMP + 1
		integer maxRange = teleportItem.maxRange

		// Pass 1: Direct teleport to target (O(337))
		// Reverse lookup: cells within teleport range of target that are in walkMap
		for (Cell L in MapPath.getTeleportDests(target, maxRange)) {
			integer? walkToL = walkMap[L]
			if (walkToL == null) continue
			if (walkToL! < bestCost) {
				bestCost = walkToL!
				bestLaunch = L
				bestDest = target
			}
		}

		// If direct teleport found at cost 0, it's optimal
		if (bestCost == 0) return [bestLaunch!, bestDest!]

		// Pass 2: Indirect — teleport near target, then walk
		integer opsStart = getOperations()
		integer opsBudget = 50000

		for (Cell L : integer walkToL in walkMap) {
			if (getOperations() - opsStart > opsBudget) break
			if (walkToL >= bestCost) continue

			for (Cell T in MapPath.getTeleportDests(L, maxRange)) {
				// Quick prune: cell distance is lower bound
				integer cellDist = getCellDistance(T.id, target.id)
				if (cellDist > maxMP - walkToL) continue
				if (walkToL + cellDist >= bestCost) continue

				// Skip if T is occupied
				if (Board.entityCells[T] && !setContains(ignoreCells, T)) continue

				// Actual walk check from T to target
				Map<Cell, integer> reachFromT = MapPath.getCachedReachableCells(T, maxMP - walkToL, ignoreCells)
				integer? walkTToTarget = reachFromT[target]
				if (walkTToTarget != null) {
					integer totalCost = walkToL + walkTToTarget!
					if (totalCost < bestCost) {
						bestCost = totalCost
						bestLaunch = L
						bestDest = T
					}
				}
			}
		}

		if (bestLaunch == null) return null
		return [bestLaunch!, bestDest!]
	}

	/*
	 * Build combo at a cell reachable only via teleport (not walk+buff reachable).
	 * Pattern: [MP buffs] → [walk to launch] → [teleport] → [walk to cell] → [attacks]
	 */
	static Combo? buildAtCellWithTeleport(ExplorationContext ctx, Cell cell) {
		if (!ctx.hasTeleport || ctx.teleportItem == null) return null

		Item teleportItem = ctx.teleportItem!
		integer teleportCost = teleportItem.cost

		// Not enough TP for teleport + at least one attack
		if (ctx.initialTP < teleportCost + 2) return null

		// Find teleport route using extended walk map
		Array<Cell>? route = ComboBuilder._findTeleportRoute(
			cell, ctx.extendedReachableCells, ctx.initialMP + ctx.maxMPBuff,
			ctx.cellsToIgnore, teleportItem)
		if (route == null) return null

		Cell launchCell = route![0]
		Cell teleportDest = route![1]

		// Walk distance to launch cell
		integer? walkToLaunch = ctx.extendedReachableCells[launchCell]
		if (walkToLaunch == null) return null
		integer walkDist = walkToLaunch!

		// Compute post-teleport walk distance (teleportDest → cell) BEFORE MP buffs
		integer walkFromTeleport = 0
		if (teleportDest != cell) {
			Map<Cell, integer> reachFromDest = MapPath.getCachedReachableCells(
				teleportDest, ctx.initialMP + ctx.maxMPBuff - walkDist, ctx.cellsToIgnore)
			integer? dist = reachFromDest[cell]
			if (dist == null) return null
			walkFromTeleport = dist!
		}
		integer totalWalk = walkDist + walkFromTeleport

		// Calculate MP buffs for TOTAL walk (pre-teleport + post-teleport)
		Array<Action>? mpBuffResult = ComboBuilder._getMPBuffs(totalWalk, ctx.initialMP, ctx.maxMPBuff, ctx.initialTP - teleportCost)
		if (mpBuffResult == null) return null
		Array<Action> mpBuffActions = mpBuffResult!
		integer mpBuffTPCost = ComboBuilder._sumBuffTPCost(mpBuffActions)

		// Check TP budget: buffs + teleport + at least 2 TP for attacks
		if (ctx.initialTP - mpBuffTPCost - teleportCost < 2) return null

		// Build combo
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		// 1. Apply MP buff actions
		ComboBuilder._applyBuffs(combo, mpBuffActions, usesThisTurn)

		// 2. Create and add teleport action
		Consequences priorCsq = combo.getCurrentConsequences()

		// Check we have enough MP after buffs to reach launch cell
		if (priorCsq.currentMP < walkDist) return null

		Action teleportAction = Action(teleportItem, launchCell, teleportDest)
		Action actualizedTeleport = Action(teleportAction, priorCsq)

		// Override position: after teleport, we're at teleportDest
		actualizedTeleport.consequences.currentCell = teleportDest

		// Deduct MP for walking to launch cell
		actualizedTeleport.consequences.currentMP = priorCsq.currentMP - walkDist

		// Push directly (bypass combo.add score check — teleport has no intrinsic damage score)
		push(combo.actions, actualizedTeleport)
		usesThisTurn[teleportItem] = 1

		// 3. Calculate remaining resources
		integer remainingTP = actualizedTeleport.consequences.currentTP
		integer remainingMP = actualizedTeleport.consequences.currentMP
		Item? weapon = actualizedTeleport.consequences.currentWeapon

		// Deduct post-teleport walk (distance already validated above)
		if (walkFromTeleport > 0) {
			if (remainingMP < walkFromTeleport) return null
			remainingMP -= walkFromTeleport
		}

		// 4. Get actions for target cell, exclude used items
		Array<Action> pool = MapCellScore.getActionsForCell(cell)
		pool = ComboBuilder._excludeUsed(pool, usesThisTurn)

		// 5. Build core into combo (knapsack, greedy, position)
		ComboBuilder._buildCoreInto(
			ctx, combo, usesThisTurn, pool, remainingTP, weapon,
			0,      // reserveMP
			null,   // stopWhenKilled
			true    // restrictToCell
		)

		return count(combo.actions) > 1 ? combo : null
	}

	/*
	 * Find a route using BOTH jump and teleport to reach a target cell.
	 * Returns [ordering, cell1, cell2] where:
	 *   ordering: 0 = jump-first (walk→jump→walk→teleport→target)
	 *             1 = teleport-first (walk→teleport→jump→target)
	 *   cell1, cell2: intermediate cells (meaning depends on ordering)
	 *
	 * Strategy A — Jump-first then teleport to target (O(337)):
	 *   Check cells within teleport range of target. If any is in jumpExtReachable, route exists.
	 *
	 * Strategy B — Teleport-first then jump to target (O(28 * 337)):
	 *   For each jump dest of target, find cheapest walk cell that can teleport there.
	 *
	 * Returns null if no route exists.
	 */
	static Array<Cell>? _findJumpTeleportRoute(Cell target, Map<Cell, integer> walkMap, integer maxMP,
			Set<Cell> ignoreCells, integer teleportRange, Map<Cell, integer> jumpExtReachable) {
		Cell? bestCell1 = null
		Cell? bestCell2 = null
		integer bestCost = maxMP + 1
		integer bestOrder = 0

		// Strategy A: Jump-first → teleport to target (O(337))
		// Check all cells within teleport range of target; if any is in jumpExtReachable, we have a route
		for (Cell L2 in MapPath.getTeleportDests(target, teleportRange)) {
			integer? cost = jumpExtReachable[L2]
			if (cost == null) continue
			if (cost! < bestCost) {
				bestCost = cost!
				bestCell1 = L2      // teleport launch cell (in jumpExtReachable)
				bestCell2 = target  // teleport destination
				bestOrder = 0
			}
		}

		// Strategy B: Teleport-first → jump to target (O(28 * 337))
		// For each jump dest of target, find cheapest walk cell that can teleport to it
		for (Cell JD in MapPath.getJumpDests(target)) {
			// Skip if JD is occupied
			if (Board.entityCells[JD] && !setContains(ignoreCells, JD)) continue

			for (Cell L in MapPath.getTeleportDests(JD, teleportRange)) {
				integer? walkToL = walkMap[L]
				if (walkToL == null) continue
				if (walkToL! >= bestCost) continue
				bestCost = walkToL!
				bestCell1 = L   // walk to here, then teleport
				bestCell2 = JD  // teleport destination, then jump to target
				bestOrder = 1
			}
		}

		if (bestCell1 == null) return null
		return [Board.cells[bestOrder]!, bestCell1!, bestCell2!]
	}

	/*
	 * Build combo at a cell reachable only via both jump and teleport.
	 * Two orderings based on _findJumpTeleportRoute result:
	 *   Jump-first:     [buffs] → [walk→L] → [jump→J] → [walk→L2] → [teleport→target] → [attacks]
	 *   Teleport-first: [buffs] → [walk→L] → [teleport→JD] → [jump→target] → [attacks]
	 */
	static Combo? buildAtCellWithJumpAndTeleport(ExplorationContext ctx, Cell cell) {
		if (!ctx.hasJump || !ctx.hasTeleport) return null
		if (ctx.jumpItem == null || ctx.teleportItem == null) return null

		Item jumpItem = ctx.jumpItem!
		Item teleportItem = ctx.teleportItem!
		integer totalAbilityCost = jumpItem.cost + teleportItem.cost

		// Not enough TP for both abilities + at least one attack
		if (ctx.initialTP < totalAbilityCost + 2) return null

		// Find route
		Array<Cell>? route = ComboBuilder._findJumpTeleportRoute(
			cell, ctx.extendedReachableCells, ctx.initialMP + ctx.maxMPBuff,
			ctx.cellsToIgnore, teleportItem.maxRange, ctx.jumpExtendedReachableCells)
		if (route == null) return null

		// Decode ordering from first element (Cell at index 0 or 1 in Board.cells)
		integer ordering = route![0].id  // 0 = jump-first, 1 = teleport-first
		Cell routeCell1 = route![1]
		Cell routeCell2 = route![2]

		if (ordering == 0) {
			// Jump-first: routeCell1 = teleport launch (in jumpExtReachable), routeCell2 = target
			return ComboBuilder._buildJumpFirstTeleport(ctx, cell, routeCell1, jumpItem, teleportItem)
		} else {
			// Teleport-first: routeCell1 = walk dest (teleport launch), routeCell2 = teleport dest (jump launch)
			return ComboBuilder._buildTeleportFirstJump(ctx, cell, routeCell1, routeCell2, jumpItem, teleportItem)
		}
	}

	/*
	 * Jump-first ordering: walk → jump → walk to L2 → teleport → target → attacks
	 * L2 is in jumpExtendedReachableCells; we find the sub-route walk→jump→walk to reach L2,
	 * then teleport from L2 to target.
	 */
	static Combo? _buildJumpFirstTeleport(ExplorationContext ctx, Cell cell, Cell teleportLaunch,
			Item jumpItem, Item teleportItem) {
		integer totalAbilityCost = jumpItem.cost + teleportItem.cost

		// Find jump sub-route to reach teleportLaunch
		Array<Cell>? jumpRoute = ComboBuilder._findJumpRoute(
			teleportLaunch, ctx.extendedReachableCells, ctx.initialMP + ctx.maxMPBuff, ctx.cellsToIgnore)
		if (jumpRoute == null) return null

		Cell jumpLaunchCell = jumpRoute![0]
		Cell jumpDest = jumpRoute![1]

		// Walk distance to jump launch
		integer? walkToJumpLaunch = ctx.extendedReachableCells[jumpLaunchCell]
		if (walkToJumpLaunch == null) return null
		integer walkDist = walkToJumpLaunch!

		// Compute post-jump walk distance (jumpDest → teleportLaunch) BEFORE MP buffs
		integer walkJumpToTeleport = 0
		if (jumpDest != teleportLaunch) {
			Map<Cell, integer> reachFromJump = MapPath.getCachedReachableCells(
				jumpDest, ctx.initialMP + ctx.maxMPBuff - walkDist, ctx.cellsToIgnore)
			integer? dist = reachFromJump[teleportLaunch]
			if (dist == null) return null
			walkJumpToTeleport = dist!
		}
		integer totalWalk = walkDist + walkJumpToTeleport

		// Calculate MP buffs for TOTAL walk (pre-jump + post-jump)
		Array<Action>? mpBuffResult = ComboBuilder._getMPBuffs(totalWalk, ctx.initialMP, ctx.maxMPBuff, ctx.initialTP - totalAbilityCost)
		if (mpBuffResult == null) return null
		Array<Action> mpBuffActions = mpBuffResult!
		integer mpBuffTPCost = ComboBuilder._sumBuffTPCost(mpBuffActions)

		if (ctx.initialTP - mpBuffTPCost - totalAbilityCost < 2) return null

		// Build combo
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		// 1. MP buffs
		ComboBuilder._applyBuffs(combo, mpBuffActions, usesThisTurn)

		// 2. Jump action
		Consequences priorCsq = combo.getCurrentConsequences()
		if (priorCsq.currentMP < walkDist) return null

		Action jumpAction = Action(jumpItem, jumpLaunchCell, jumpDest)
		Action actualizedJump = Action(jumpAction, priorCsq)
		actualizedJump.consequences.currentCell = jumpDest
		actualizedJump.consequences.currentMP = priorCsq.currentMP - walkDist

		push(combo.actions, actualizedJump)
		usesThisTurn[jumpItem] = 1

		// 3. Walk from jumpDest to teleportLaunch (distance already validated above)
		integer mpAfterJump = actualizedJump.consequences.currentMP
		if (mpAfterJump < walkJumpToTeleport) return null

		// 4. Teleport action from teleportLaunch to cell (target)
		priorCsq = combo.getCurrentConsequences()
		priorCsq.currentCell = teleportLaunch
		priorCsq.currentMP = mpAfterJump - walkJumpToTeleport

		Action teleportAction = Action(teleportItem, teleportLaunch, cell)
		Action actualizedTeleport = Action(teleportAction, priorCsq)
		actualizedTeleport.consequences.currentCell = cell
		actualizedTeleport.consequences.currentMP = priorCsq.currentMP

		push(combo.actions, actualizedTeleport)
		usesThisTurn[teleportItem] = 1

		// 5. Fill with attacks
		integer remainingTP = actualizedTeleport.consequences.currentTP
		Item? weapon = actualizedTeleport.consequences.currentWeapon

		Array<Action> pool = MapCellScore.getActionsForCell(cell)
		pool = ComboBuilder._excludeUsed(pool, usesThisTurn)

		ComboBuilder._buildCoreInto(
			ctx, combo, usesThisTurn, pool, remainingTP, weapon,
			0, null, true
		)

		return count(combo.actions) > 2 ? combo : null
	}

	/*
	 * Teleport-first ordering: walk to L → teleport to JD → jump to target → attacks
	 * L is in walkMap (extendedReachableCells), JD is jump dest of target.
	 */
	static Combo? _buildTeleportFirstJump(ExplorationContext ctx, Cell cell, Cell teleportLaunch,
			Cell jumpDest, Item jumpItem, Item teleportItem) {
		integer totalAbilityCost = jumpItem.cost + teleportItem.cost

		// Walk distance to teleport launch
		integer? walkToLaunch = ctx.extendedReachableCells[teleportLaunch]
		if (walkToLaunch == null) return null
		integer walkDist = walkToLaunch!

		// Calculate MP buffs
		Array<Action>? mpBuffResult = ComboBuilder._getMPBuffs(walkDist, ctx.initialMP, ctx.maxMPBuff, ctx.initialTP - totalAbilityCost)
		if (mpBuffResult == null) return null
		Array<Action> mpBuffActions = mpBuffResult!
		integer mpBuffTPCost = ComboBuilder._sumBuffTPCost(mpBuffActions)

		if (ctx.initialTP - mpBuffTPCost - totalAbilityCost < 2) return null

		// Build combo
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		// 1. MP buffs
		ComboBuilder._applyBuffs(combo, mpBuffActions, usesThisTurn)

		// 2. Teleport action: walk to teleportLaunch, then teleport to jumpDest
		Consequences priorCsq = combo.getCurrentConsequences()
		if (priorCsq.currentMP < walkDist) return null

		Action teleportAction = Action(teleportItem, teleportLaunch, jumpDest)
		Action actualizedTeleport = Action(teleportAction, priorCsq)
		actualizedTeleport.consequences.currentCell = jumpDest
		actualizedTeleport.consequences.currentMP = priorCsq.currentMP - walkDist

		push(combo.actions, actualizedTeleport)
		usesThisTurn[teleportItem] = 1

		// 3. Jump action from jumpDest to cell (target)
		priorCsq = combo.getCurrentConsequences()

		Action jumpAction = Action(jumpItem, jumpDest, cell)
		Action actualizedJump = Action(jumpAction, priorCsq)
		actualizedJump.consequences.currentCell = cell
		// No extra walk cost — jumpDest is already our position

		push(combo.actions, actualizedJump)
		usesThisTurn[jumpItem] = 1

		// 4. Fill with attacks
		integer remainingTP = actualizedJump.consequences.currentTP
		Item? weapon = actualizedJump.consequences.currentWeapon

		Array<Action> pool = MapCellScore.getActionsForCell(cell)
		pool = ComboBuilder._excludeUsed(pool, usesThisTurn)

		ComboBuilder._buildCoreInto(
			ctx, combo, usesThisTurn, pool, remainingTP, weapon,
			0, null, true
		)

		return count(combo.actions) > 2 ? combo : null
	}

	// ════════════════════════════════════════════════════════════
	// PRIVATE CORE METHODS
	// ════════════════════════════════════════════════════════════

	/*
	 * Core combo building: knapsack -> sort -> add -> greedy -> position.
	 * Creates a new combo from scratch.
	 */
	static Combo _buildCore(
		ExplorationContext ctx,
		Array<Action> pool,
		integer availableTP,
		Item? currentWeapon,
		integer reserveMP,
		Entity? stopWhenKilled,
		boolean restrictToCell
	) {
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		ComboBuilder._buildCoreInto(
			ctx, combo, usesThisTurn, pool, availableTP, currentWeapon,
			reserveMP, stopWhenKilled, restrictToCell
		)

		return combo
	}

	/*
	 * Core combo building into an existing combo (without final position).
	 * Knapsack -> sort -> add -> greedy fallback.
	 */
	static void _buildCoreIntoNoPosition(
		ExplorationContext ctx,
		Combo combo,
		Map<Item, integer> usesThisTurn,
		Array<Action> pool,
		integer availableTP,
		Item? currentWeapon,
		integer reserveMP,
		Entity? stopWhenKilled,
		boolean restrictToCell
	) {
		// Knapsack selection
		Array<Action> selected = ActionKnapsack.solve(pool, availableTP, currentWeapon, null)
		selected = MapCellScore.sortByPriority(selected)

		// Add selected actions
		for (Action action in selected) {
			if (stopWhenKilled != null && combo.getCurrentConsequences().isKilled(stopWhenKilled!)) break

			boolean added = ComboBuilder.tryAddAction(ctx, combo, action, usesThisTurn, reserveMP)

			// If summon/resurrection was added, expand with pending entity buff actions
			if (added && action.item.isSummon) {
				ComboBuilder._expandWithPendingBuffs(ctx, combo, action.to, usesThisTurn, reserveMP)
			}
		}

		// Greedy fallback
		Consequences csq = combo.getCurrentConsequences()
		if (csq.currentTP > 0) {
			Array<Action> remaining = ComboBuilder._excludeUsed(pool, usesThisTurn)
			ComboBuilder._greedyFallback(ctx, combo, remaining, usesThisTurn, restrictToCell)
		}
	}

	/*
	 * Core combo building into an existing combo.
	 * Allows prepending buffs/liberation before core logic.
	 */
	static void _buildCoreInto(
		ExplorationContext ctx,
		Combo combo,
		Map<Item, integer> usesThisTurn,
		Array<Action> pool,
		integer availableTP,
		Item? currentWeapon,
		integer reserveMP,
		Entity? stopWhenKilled,
		boolean restrictToCell
	) {
		ComboBuilder._buildCoreIntoNoPosition(ctx, combo, usesThisTurn, pool,
			availableTP, currentWeapon, reserveMP, stopWhenKilled, restrictToCell)
		ComboBuilder._addFinalPosition(combo)
	}

	/*
	 * Expand combo with buff actions for a pending entity (summon or resurrection).
	 * Called after a summon or resurrection action is successfully added.
	 */
	static void _expandWithPendingBuffs(
		ExplorationContext ctx,
		Combo combo,
		Cell pendingCell,
		Map<Item, integer> usesThisTurn,
		integer reserveMP
	) {
		Consequences csq = combo.getCurrentConsequences()

		// Check if a pendingBulb or pendingResurrect exists at this cell
		if (csq.pendingBulbs[pendingCell] == null && csq.pendingResurrect[pendingCell] == null) return;

		// Build ignoreCells: base + killed entities
		Set<Cell> ignoreCells = ComboBuilder.buildIgnoreCells(ctx, csq)

		// Generate buff actions for the pending entity
		Array<Action> buffActions = MapAction.getPendingBuffActions(
			pendingCell,
			csq.currentCell,
			csq.currentMP,
			csq.currentTP,
			usesThisTurn,
			ignoreCells
		)

		if (count(buffActions) == 0) return;

		// Sort by score (greedy selection of best buffs)
		buffActions = MapCellScore.sortByScore(buffActions)

		// Try each buff
		for (Action buffAction in buffActions) {
			ComboBuilder.tryAddAction(ctx, combo, buffAction, usesThisTurn, reserveMP)
		}
	}


	/*
	 * Apply MP buff actions to combo.
	 */
	static void _applyBuffs(Combo combo, Array<Action> buffs, Map<Item, integer> usesThisTurn) {
		for (Action buff in buffs) {
			combo.add(buff)
			usesThisTurn[buff.item] = 1
		}
	}

	/*
	 * Greedy fallback: fill remaining TP from pool.
	 * Loops on repeatable items until maxUse reached.
	 */
	static void _greedyFallback(
		ExplorationContext ctx,
		Combo combo,
		Array<Action> pool,
		Map<Item, integer> usesThisTurn,
		boolean restrictToCell
	) {
		// Filter if restricting to cell
		Array<Action> filtered = []
		Consequences csq = combo.getCurrentConsequences()

		for (Action a in pool) {
			if (a.score <= 0) continue
			if (restrictToCell && a.from != Fight.selfCell && a.from != csq.currentCell) continue
			push(filtered, a)
		}

		// Sort by score for greedy fill
		filtered = MapCellScore.sortByScore(filtered)

		// Try to fill - loop on each action until it fails
		for (Action action in filtered) {
			boolean added = ComboBuilder.tryAddAction(ctx, combo, action, usesThisTurn, 0)

			// If summon/resurrection was added, expand with pending entity buff actions
			if (added && action.item.isSummon) {
				ComboBuilder._expandWithPendingBuffs(ctx, combo, action.to, usesThisTurn, 0)
			}

			// Continue looping for repeatable items
			while (added && ComboBuilder.tryAddAction(ctx, combo, action, usesThisTurn, 0)) {}
		}
	}

	/*
	 * Add final position to combo.
	 */
	static void _addFinalPosition(Combo combo) {
		Consequences csq = combo.getCurrentConsequences()
		integer? bossCell = BossPotiMalef.getResurrectionCell()
		if (bossCell != null) {
			// Only force leek to boss cell if combo has no summon to block it
			boolean hasSummon = false
			for (Action a in combo.actions) {
				if (a.item.isSummon) { hasSummon = true; break }
			}
			if (!hasSummon && ComboBuilder._addForcedFinalPosition(combo, Board.cells[bossCell!]!, 100000.0)) {
				return;
			}
		}
		Position pos = MapPosition.findBestPosition(csq.currentCell, csq.currentMP, csq)
		combo.addFinalPosition(pos)
	}

	/*
	 * Force final position to a specific cell with optional score bonus.
	 * Returns true if targetCell is reachable from combo's current position.
	 */
	static boolean _addForcedFinalPosition(Combo combo, Cell targetCell, real scoreBonus) {
		Consequences csq = combo.getCurrentConsequences()
		if (csq.currentCell.id != targetCell.id) {
			Map<Cell, integer> reachable = MapPath.getCachedReachableCells(
				csq.currentCell, csq.currentMP, Fight.self.cellsToIgnore)
			if (reachable[targetCell] == null) {
				return false
			}
		}
		Position pos = MapPosition.evaluatePosition(targetCell, csq)
		pos.score += scoreBonus
		combo.addFinalPosition(pos)
		return true
	}

	// ════════════════════════════════════════════════════════════
	// PRIVATE HELPERS
	// ════════════════════════════════════════════════════════════

	/*
	 * Find maximum distance needed to reach any action's from-cell.
	 */
	static integer _getMaxDistNeeded(ExplorationContext ctx, Array<Action> actions) {
		integer maxDist = 0
		Map<Cell, integer> reachable = ctx.extendedReachableCells

		for (Action a in actions) {
			if (a.from == Fight.selfCell) continue
			integer? dist = reachable[a.from]
			if (dist != null && dist! > maxDist) {
				maxDist = dist!
			}
		}
		return maxDist
	}

	/*
	 * Calculate MP buffs with feasibility check.
	 * Returns empty array if no buffs needed, null if impossible.
	 */
	static Array<Action>? _getMPBuffs(integer mpNeeded, integer baseMP, integer maxMPBuff, integer availableTP) {
		if (mpNeeded <= baseMP) return []
		if (mpNeeded > baseMP + maxMPBuff) return null
		return ComboBuilder._calculateMPBuffs(mpNeeded - baseMP, availableTP)
	}

	/*
	 * Sum TP cost of buff actions.
	 */
	static integer _sumBuffTPCost(Array<Action> buffs) {
		integer total = 0
		for (Action a in buffs) {
			total += a.item.cost
		}
		return total
	}

	/*
	 * Calculate minimal MP buffs needed for given extra MP.
	 * Greedy by efficiency (MP/TP).
	 * Returns null if impossible.
	 * Note: Uses Fight.self.effects to check active buffs (entity state, not context).
	 */
	static Array<Action>? _calculateMPBuffs(integer neededMP, integer availableTP) {
		if (neededMP <= 0) return []

		// Build set of already-active MP buff chips
		Map<integer, boolean> activeBuffChips = [:]
		for (EntityEffect e in Fight.self.effects) {
			if (e.type == EFFECT_BUFF_MP || e.type == EFFECT_RAW_BUFF_MP) {
				activeBuffChips[e.item.id] = true
			}
		}

		// Collect MP buff actions directly from entity items (not selfCastActions)
		// This matches computeMaxMPBuff() logic to avoid mismatch
		Array<Action> allBuffs = []
		real sncMultiplier = 1 + Fight.self.snc / 100.0

		for (Item item in Fight.self.items) {
			// Skip if not self-castable
			if (item.minRange > 0) continue
			// Skip if on cooldown
			if (item.haveCD && getCooldown(item.id, Fight.self.id) > 0) continue
			// Skip if can't afford
			if (item.cost > availableTP) continue
			// Skip if already active
			if (activeBuffChips[item.id]) continue

			// Check for MP buff effect and compute gain
			integer mpGain = 0
			for (ItemEffect effect in item.effects) {
				// Skip effects that don't apply to self (e.g. bulb-only MP buffs)
				if (Fight.self.isBulb ? !effect.targetType.onBulbs : !effect.targetType.onLeeks) continue
				if (effect.type == EFFECT_RAW_BUFF_MP) {
					mpGain = round(effect.avg)
					break
				} else if (effect.type == EFFECT_BUFF_MP) {
					mpGain = round(effect.avg * sncMultiplier)
					break
				}
			}
			if (mpGain <= 0) continue

			// Create self-cast action for this buff
			Action buffAction = Action(item, Fight.selfCell, Fight.selfCell)
			push(allBuffs, buffAction)
		}

		if (count(allBuffs) == 0) return null

		// Sort by efficiency (MP gain / TP cost) descending
		integer baseMP = Fight.self.mp
		allBuffs = arraySort(allBuffs, (Action a, Action b) => integer|real {
			integer gainA = a.consequences.currentMP - baseMP
			integer gainB = b.consequences.currentMP - baseMP
			real effA = gainA / a.item.cost
			real effB = gainB / b.item.cost
			return Sort.desc(effA, effB)
		}) as Array<Action>

		// Greedy selection
		Array<Action> selected = []
		integer totalGain = 0
		integer tpSpent = 0

		for (Action a in allBuffs) {
			if (totalGain >= neededMP) break
			if (tpSpent + a.item.cost > availableTP) continue

			integer gain = a.consequences.currentMP - baseMP
			push(selected, a)
			totalGain += gain
			tpSpent += a.item.cost
		}

		return totalGain >= neededMP ? selected : null
	}

	/*
	 * Collect available str buff options, sorted by efficiency (str gain / TP cost).
	 * Parallel to _calculateMPBuffs but returns all options (caller decides how many to use).
	 * Skips already-active str buff chips and items that can't be self-cast.
	 */
	static Array<Action> _collectStrBuffOptions(integer availableTP) {
		// Build set of already-active str buff chips
		Map<integer, boolean> activeChips = [:]
		for (EntityEffect e in Fight.self.effects) {
			if (e.type == EFFECT_BUFF_STRENGTH || e.type == EFFECT_RAW_BUFF_STRENGTH) {
				activeChips[e.item.id] = true
			}
		}

		Array<Action> allBuffs = []
		Map<integer, integer> gains = [:]
		real sncMultiplier = 1 + Fight.self.snc / 100.0

		for (Item item in Fight.self.items) {
			if (item.minRange > 0) continue
			if (item.id == CHIP_FEROCITY || item.id == CHIP_PRISM) continue
			if (item.haveCD && getCooldown(item.id, Fight.self.id) > 0) continue
			if (item.cost > availableTP) continue
			if (activeChips[item.id]) continue

			integer strGain = 0
			for (ItemEffect effect in item.effects) {
				if (effect.type == EFFECT_RAW_BUFF_STRENGTH) {
					strGain = round(effect.avg)
					break
				} else if (effect.type == EFFECT_BUFF_STRENGTH) {
					strGain = round(effect.avg * sncMultiplier)
					break
				}
			}
			if (strGain <= 0) continue

			Action buffAction = Action(item, Fight.selfCell, Fight.selfCell)
			push(allBuffs, buffAction)
			gains[item.id] = strGain
		}

		// Sort by efficiency (str gain / TP cost) descending
		allBuffs = arraySort(allBuffs, (Action a, Action b) => integer|real {
			real effA = gains[a.item.id]! / a.item.cost
			real effB = gains[b.item.id]! / b.item.cost
			return Sort.desc(effA, effB)
		}) as Array<Action>

		return allBuffs
	}

	/*
	 * Filter actions by reachability within a specific max distance.
	 * Uses extended or base reachable cells depending on whether maxDistance exceeds base MP.
	 */
	static Array<Action> _filterByReachDistance(ExplorationContext ctx, Array<Action> actions, integer maxDistance) {
		Map<Cell, integer> reachable = maxDistance > ctx.initialMP
			? ctx.extendedReachableCells : ctx.reachableCells

		Array<Action> filtered = []
		for (Action a in actions) {
			if (a.from == Fight.selfCell) {
				push(filtered, a)
			} else {
				integer? dist = reachable[a.from]
				if (dist != null && dist! <= maxDistance) {
					push(filtered, a)
				}
			}
		}
		return filtered
	}

	/*
	 * Calculate total path distance for a sequence of cells.
	 * Returns -1 if any leg is unreachable.
	 */
	static integer _calculatePathDistance(Array<Cell> sequence, Set<Cell> ignoreCells, integer maxMP) {
		if (count(sequence) == 0) return 0

		integer totalDist = 0
		Cell current = Fight.self.cell
		integer remainingMP = maxMP

		for (Cell target in sequence) {
			Map<Cell, integer> reachable
			if (current == Fight.self.cell) {
				reachable = Fight.self.extendedReachableCells
			} else {
				reachable = MapPath.getCachedReachableCells(current, remainingMP, ignoreCells)
			}

			integer? dist = reachable[target]
			if (dist == null) return -1  // Unreachable

			totalDist += dist!
			remainingMP -= dist!
			if (remainingMP < 0) return -1
			current = target
		}

		return totalDist
	}

	/*
	 * Pool actions from multiple cells, deduplicated.
	 */
	static Array<Action> _poolActionsFromCells(Array<Cell> cells, Array<Action> excludeBuffs) {
		Array<Action> combined = []
		Map<integer, boolean> seen = [:]

		// Build exclude set
		Map<integer, boolean> excludeKeys = [:]
		for (Action buff in excludeBuffs) {
			excludeKeys[ComboBuilder.actionKey(buff)] = true
		}

		for (Cell cell in cells) {
			Array<Action> cellActions = MapCellScore.getActionsForCell(cell)
			for (Action a in cellActions) {
				integer key = ComboBuilder.actionKey(a)
				if (excludeKeys[key]) continue
				if (!seen[key]) {
					push(combined, a)
					seen[key] = true
				}
			}
		}

		return combined
	}

	/*
	 * Partition actions by their from-cell.
	 */
	static Map<Cell, Array<Action>> _partitionByCell(Array<Action> actions, Array<Cell> cells) {
		Map<Cell, Array<Action>> result = [:]

		// Initialize empty arrays for each cell
		for (Cell cell in cells) {
			result[cell] = []
		}

		Cell firstCell = cells[0]

		for (Action action in actions) {
			if (action.from == Fight.selfCell) {
				// Self-cast goes to first cell
				push(result[firstCell]!, action)
			} else if (result[action.from] != null) {
				push(result[action.from]!, action)
			}
			// Actions from other cells are skipped (shouldn't happen)
		}

		return result
	}

	/*
	 * Get ALL actions from all cells (for fallback expansion).
	 * Note: cellActions and selfCastActions are already filtered (score > 0)
	 * in MapCellScore.refresh(), so no need to re-check here.
	 */
	static Array<Action> _getAllActions() {
		Array<Action> all = []

		for (Cell cell : Array<Action> actions in MapCellScore.cellActions) {
			for (Action a in actions) {
				push(all, a)
			}
		}

		// Add self-cast
		for (Action a in MapCellScore.selfCastActions) {
			push(all, a)
		}

		return all
	}

	/*
	 * Exclude already-used items from pool.
	 */
	static Array<Action> _excludeUsed(Array<Action> pool, Map<Item, integer> usesThisTurn) {
		Array<Action> filtered = []
		for (Action a in pool) {
			integer uses = usesThisTurn[a.item] != null ? usesThisTurn[a.item]! : 0
			if (uses < a.item.maxUse) {
				push(filtered, a)
			}
		}
		return filtered
	}

	/*
	 * Find Liberation action targeting specific entity.
	 */
	static Action? _findLiberationAction(ExplorationContext ctx, Item liberationItem, Entity target, Consequences csq) {
		Map<Cell, Map<Item, Action>> bestActions = MapAction.getMapBestAction()

		for (Cell cell : Map<Item, Action> itemActions in bestActions) {
			Action? action = itemActions[liberationItem]
			if (action == null) continue

			if (action!.to != target.cell) continue

			// Check reachability (cache may have cells beyond MP, must verify distance)
			if (action!.from != Fight.selfCell) {
				Set<Cell> ignoreCells = ComboBuilder.buildIgnoreCells(ctx, csq)
				Map<Cell, integer> reachable = MapPath.getCachedReachableCells(
					csq.currentCell, csq.currentMP, ignoreCells, csq._newObstacles)
				integer? dist = reachable[action!.from]
				if (dist == null || dist! > csq.currentMP) continue
			}

			return action
		}
		return null
	}

	/*
	 * Find Neutrino action targeting specific entity.
	 * Similar to _findLiberationAction but for WEAPON_NEUTRINO.
	 */
	static Action? _findNeutrinoAction(ExplorationContext ctx, Item neutrinoItem, Entity target, Consequences csq) {
		Map<Cell, Map<Item, Action>> bestActions = MapAction.getMapBestAction()

		for (Cell cell : Map<Item, Action> itemActions in bestActions) {
			Action? action = itemActions[neutrinoItem]
			if (action == null) continue

			if (action!.to != target.cell) continue

			// Check reachability
			if (action!.from != Fight.selfCell) {
				Set<Cell> ignoreCells = ComboBuilder.buildIgnoreCells(ctx, csq)
				Map<Cell, integer> reachable = MapPath.getCachedReachableCells(
					csq.currentCell, csq.currentMP, ignoreCells, csq._newObstacles)
				integer? dist = reachable[action!.from]
				if (dist == null || dist! > csq.currentMP) continue
			}

			return action
		}
		return null
	}

	// ════════════════════════════════════════════════════════════
	// PUBLIC HELPERS (used by other modules)
	// ════════════════════════════════════════════════════════════

	/*
	 * Build ignoreCells array for pathfinding: base cells + killed entities + freed cells
	 */
	static Set<Cell> buildIgnoreCells(ExplorationContext ctx, Consequences csq) {
		Set<Cell> ignoreCells = clone(ctx.cellsToIgnore) as Set<Cell>
		csq.appendKilledCells(ignoreCells)
		csq.appendFreedCells(ignoreCells)
		return ignoreCells
	}

	/*
	 * Try to add an action to a combo, checking all preconditions.
	 * Handles: usage limits, TP cost, weapon switch, reachability with reserveMP.
	 * Updates usesThisTurn map if action was added.
	 *
	 * @param ctx Exploration context with initial resources
	 * @param combo The combo to add to
	 * @param action The action to try adding
	 * @param usesThisTurn Map tracking item usage counts this turn
	 * @param reserveMP MP to reserve for defense (subtracted from available MP)
	 * @return true if action was added, false otherwise
	 */
	static boolean tryAddAction(ExplorationContext ctx, Combo combo, Action action, Map<Item, integer> usesThisTurn, integer reserveMP) {
		return ComboBuilder._tryAddActionImpl(combo, action, usesThisTurn, reserveMP, 0, ctx.cellsToIgnore)
	}

	/*
	 * Try to add an action to a combo (without exploration context).
	 * For use by external modules like MapSummon that build combos outside exploration.
	 * Uses Fight.self.cellsToIgnore for pathfinding.
	 */
	static boolean tryAddAction(Combo combo, Action action, Map<Item, integer> usesThisTurn, integer reserveMP) {
		return ComboBuilder._tryAddActionImpl(combo, action, usesThisTurn, reserveMP, 0, Fight.self.cellsToIgnore)
	}

	/*
	 * Internal implementation of tryAddAction.
	 */
	static boolean _tryAddActionImpl(Combo combo, Action action, Map<Item, integer> usesThisTurn, integer reserveMP, integer reserveTP, Set<Cell> baseCellsToIgnore) {
		// Check usage limit
		integer uses = usesThisTurn[action.item] != null ? usesThisTurn[action.item]! : 0
		if (uses >= action.item.maxUse) return false

		// Get current state
		Consequences csq = combo.getCurrentConsequences()

		// Check if action was invalidated by inversion (targets moved)
		if (csq.invalidatedActions != null && setContains(csq.invalidatedActions!, action)) return false

		// Check TP (including weapon switch cost + reserved TP)
		integer switchCost = (action.item.isWeap && (csq.currentWeapon == null || action.item.id != csq.currentWeapon!.id)) ? 1 : 0
		if (csq.currentTP < action.item.cost + switchCost + reserveTP) return false

		// Check reachability
		if (action.from != Fight.selfCell) {
			// Build ignore cells: base + killed entities + freed cells (COW-aware)
			Set<Cell> ignoreCells = clone(baseCellsToIgnore) as Set<Cell>
			csq.appendKilledCells(ignoreCells)
			csq.appendFreedCells(ignoreCells)
			integer effectiveMP = max(0, csq.currentMP - reserveMP)
			Map<Cell, integer> reachable = MapPath.getCachedReachableCells(
				csq.currentCell, effectiveMP, ignoreCells, csq._newObstacles)
			if (reachable[action.from] == null || reachable[action.from]! > effectiveMP) return false
		}

		// Try to add
		boolean added = combo.add(action)
		if (added) {
			usesThisTurn[action.item] = uses + 1
		}
		return added
	}

	/*
	 * Unique key for action (for deduplication)
	 */
	static integer actionKey(Action a) {
		return a.item.id * 10000000 + a.from.id * 10000 + a.to.id
	}
}
