/*
 * ComboExplorer - Multi-phase combo exploration algorithm
 *
 * Explores action combinations across multiple cells to find optimal combos.
 * Uses precomputed actions from MapAction (no duplication).
 *
 * Phases (in order):
 * - Phase 0: Stay in place (cheap baseline, 0 MP offense)
 * - Phase T: Target focus
 *   - Kill each enemy: 4 variants (Liberation x MPBuff)
 *   - Support each ally: 2 variants (MPBuff)
 * - Phase 1a: Single-cell MP sampling (1..maxMP, no buffs needed)
 * - Phase 1b: Extended range cells (maxMP+1..maxMP+maxMPBuff, with minimal buffs)
 * - Phase 2: Multi-cell pairs (top K cells, both orderings, minimal buffs if needed)
 * - Phase 3: Three-cell combos (top K cells, all 6 orderings, minimal buffs if needed)
 *
 * Key principles:
 * - Action SELECTION by knapsack (optimal TP allocation)
 * - Action ORDERING by priority (for execution)
 * - Greedy FALLBACK after kills (fill remaining TP)
 * - Proper consequence chaining
 * - Weapon switch costs handled in Consequences
 * - Operation budget checked after each combo
 * - MP buffs: stacked minimally to reach extended cells (minimize TP spent)
 */

// ════════════════════════════════════════════════════════════════
// CONFIGURATION
// ════════════════════════════════════════════════════════════════

class ExplorerConfig {
	// Top K cells for Phase 2 multi-cell exploration
	// Complexity is O(K^2): K=10 -> 90 combos, K=15 -> 210, K=20 -> 380
	static integer INTERESTING_CELLS_K = 10
	// Top K cells for Phase 3 three-cell exploration
	// Complexity is O(K^3 x 6): K=7 -> 210 combos, K=10 -> 720 combos
	static integer INTERESTING_CELLS_K_PHASE3 = 7
	// Operation buffer: dynamic for main leek (base + per bulb + potential summon), fixed for bulbs
	static integer OPERATION_BUFFER_LEEK_BASE = 250000
	static integer OPERATION_BUFFER_PER_BULB = 200000
	static integer OPERATION_BUFFER_POTENTIAL_SUMMON = 200000
	static integer OPERATION_BUFFER_BULB = 200000
	static integer MAX_RESULTS_KEPT = 5
}

// ════════════════════════════════════════════════════════════════
// EXPLORATION CONTEXT
// Holds per-exploration state: initial resources, results, operation control
// ════════════════════════════════════════════════════════════════

class ExplorationContext {
	// Initial resources (snapshot at exploration start)
	integer initialTP
	integer initialMP
	Item? initialWeapon
	integer maxMPBuff

	// Reachability maps (snapshot at exploration start)
	Map<Cell, integer> reachableCells
	Map<Cell, integer> extendedReachableCells
	Array<Cell> cellsToIgnore

	// Results tracking
	Array<ExplorerResult> topResults
	ExplorerResult? bestResult
	integer combosEvaluated
	string bestPhase

	// Operation control
	integer operationBuffer

	/*
	 * Create fresh context from current Fight.self state
	 */
	constructor() {
		// Snapshot initial resources
		this.initialTP = Fight.self.tp
		this.initialMP = Fight.self.mp
		this.initialWeapon = Fight.self.getWeaponInHand()
		this.maxMPBuff = Fight.self.maxMPBuff

		// Snapshot reachability
		this.reachableCells = Fight.self.reachableCells
		this.extendedReachableCells = Fight.self.extendedReachableCells
		this.cellsToIgnore = clone(Fight.self.cellsToIgnore) as Array<Cell>

		// Initialize results
		this.topResults = []
		this.bestResult = null
		this.combosEvaluated = 0
		this.bestPhase = ""

		// Calculate operation buffer based on entity type
		if (Fight.self.isBulb) {
			this.operationBuffer = ExplorerConfig.OPERATION_BUFFER_BULB
		} else {
			integer bulbCount = count(getSummons())
			this.operationBuffer = ExplorerConfig.OPERATION_BUFFER_LEEK_BASE
				+ bulbCount * ExplorerConfig.OPERATION_BUFFER_PER_BULB
			if (Fight.canSummon) {
				this.operationBuffer += ExplorerConfig.OPERATION_BUFFER_POTENTIAL_SUMMON
			}
		}
	}

	/*
	 * Check if we should stop (operation budget exhausted)
	 */
	boolean shouldStop() {
		return getOperations() > getMaxOperations() - this.operationBuffer
	}

	/*
	 * Record a result and update best if needed
	 */
	void recordResult(ExplorerResult result) {
		this.combosEvaluated++

		// Update best
		if (this.bestResult == null || result.score > this.bestResult!.score) {
			this.bestResult = result
			this.bestPhase = result.phase
		}

		// Keep top N results
		push(this.topResults, result)
		if (count(this.topResults) > ExplorerConfig.MAX_RESULTS_KEPT) {
			// Sort and trim
			this.topResults = arraySort(this.topResults, (ExplorerResult a, ExplorerResult b) => integer|real {
				return Sort.desc(a.score, b.score)
			}) as Array<ExplorerResult>
			this.topResults = arraySlice(this.topResults, 0, ExplorerConfig.MAX_RESULTS_KEPT) as Array<ExplorerResult>
		}
	}
}

// ════════════════════════════════════════════════════════════════
// RESULT WRAPPER
// ════════════════════════════════════════════════════════════════

class ExplorerResult {
	Combo combo
	string name      // e.g., "T:Kill_Goblin", "P0:Stay", "P2:A->B"
	string phase     // "T", "0", "1", "2", "3"
	real score

	constructor(Combo combo, string name, string phase) {
		this.combo = combo
		this.name = name
		this.phase = phase
		this.score = combo.getScore()!
	}

	string string() {
		return "<ExplorerResult " + this.name + " score:" + round(this.score) + ">"
	}
}

// ════════════════════════════════════════════════════════════════
// CELL SCORING (No duplication)
// ════════════════════════════════════════════════════════════════

class MapCellScore {
	// Cell -> total action score (sum of best actions per item)
	static Map<Cell, real> cellScores = [:]

	// Cell -> actions (unsorted, sorted lazily in buildWithKnapsack)
	static Map<Cell, Array<Action>> cellActions = [:]

	// Self-cast actions (available from any cell)
	static Array<Action> selfCastActions = []

	// Top K interesting cells (sorted by score DESC)
	static Array<Cell> interestingCells = []

	/*
	 * Refresh cell scoring from MapAction (no duplication)
	 */
	static void refresh() {
		MapCellScore.cellScores = [:]
		MapCellScore.cellActions = [:]
		MapCellScore.selfCastActions = []

		Map<Cell, Map<Item, Action>> bestActions = MapAction.getMapBestAction()

		for (Cell cell : Map<Item, Action> itemActions in bestActions) {
			real totalScore = 0.0
			Array<Action> actions = []

			for (Item item : Action action in itemActions) {
				if (action.score == null || action.score! <= 0) continue
				totalScore += action.score!
				push(actions, action)
			}

			if (count(actions) == 0) continue

			// Handle self-cast separately
			if (cell == Fight.selfCell) {
				MapCellScore.selfCastActions = actions
			} else {
				MapCellScore.cellScores[cell] = totalScore
				MapCellScore.cellActions[cell] = actions
			}
		}

		// Build interesting cells list (top K by score)
		MapCellScore.interestingCells = []
		Array<Cell> allCells = []
		for (Cell cell : real score in MapCellScore.cellScores) {
			push(allCells, cell)
		}

		allCells = arraySort(allCells, (Cell a, Cell b) => integer|real {
			return Sort.desc(MapCellScore.cellScores[a]!, MapCellScore.cellScores[b]!)
		}) as Array<Cell>

		integer k = min(ExplorerConfig.INTERESTING_CELLS_K, count(allCells))
		for (integer i = 0; i < k; i++) {
			push(MapCellScore.interestingCells, allCells[i])
		}
	}

	/*
	 * Sort actions by priority ASC, then score DESC
	 */
	static Array<Action> sortByPriority(Array<Action> actions) {
		return arraySort(actions, (Action a, Action b) => integer|real {
			if (a.item.priority != b.item.priority) {
				return Sort.asc(a.item.priority, b.item.priority)
			}
			return Sort.desc(a.score!, b.score!)
		}) as Array<Action>
	}

	/*
	 * Sort actions by score DESC (for selection)
	 */
	static Array<Action> sortByScore(Array<Action> actions) {
		return arraySort(actions, (Action a, Action b) => integer|real {
			return Sort.desc(a.score!, b.score!)
		}) as Array<Action>
	}

	/*
	 * Display cell scores on the map (for debugging)
	 * Color: black = reachable but no useful action
	 *        red (low) to green (high) gradient = has actions
	 *        blue = top K selected cells
	 * Text: rounded score value
	 */
	static void showCellScores() {
		// Find max for normalization
		real maxScore = 1.0
		for (Cell c : real s in MapCellScore.cellScores) {
			if (s > maxScore) maxScore = s
		}

		// Build set of interesting cells for O(1) lookup
		Map<Cell, boolean> isInteresting = [:]
		for (Cell c in MapCellScore.interestingCells) {
			isInteresting[c] = true
		}

		// Color all reachable cells
		for (Cell c : integer dist in Fight.self.reachableCells) {
			real? score = MapCellScore.cellScores[c]
			if (isInteresting[c]) {
				mark(c.id, getColor(0, 0, 255))
				markText(c.id, round(score!) + "")
			} else if (score != null && score! > 0) {
				integer green = ((score! * 255) / maxScore) as integer
				integer red = 255 - green
				mark(c.id, getColor(red, green, 0))
				markText(c.id, round(score!) + "")
			} else {
				// Reachable but no useful action
				mark(c.id, getColor(0, 0, 0))
			}
		}
	}

	/*
	 * Get actions for a cell (including self-cast merged in)
	 */
	static Array<Action> getActionsForCell(Cell cell) {
		Array<Action> result = []

		// Add cell-specific actions
		if (MapCellScore.cellActions[cell] != null) {
			for (Action a in MapCellScore.cellActions[cell]!) {
				push(result, a)
			}
		}

		// Add self-cast actions
		for (Action a in MapCellScore.selfCastActions) {
			push(result, a)
		}

		return result
	}

	/*
	 * Get all actions that damage a specific target
	 */
	static Array<Action> getActionsDamagingTarget(Entity target) {
		Array<Action> result = []
		Map<Cell, Map<Item, Action>> bestActions = MapAction.getMapBestAction()

		for (Cell cell : Map<Item, Action> itemActions in bestActions) {
			for (Item item : Action action in itemActions) {
				if (action.score == null || action.score! <= 0) continue
				// Check if this action targets the enemy
				if (action.to == target.cell || (action.item.isAOE && MapCellScore.actionHitsTarget(action, target))) {
					push(result, action)
				}
			}
		}

		return result
	}

	/*
	 * Get all actions that help a specific ally (heals/buffs)
	 */
	static Array<Action> getActionsHelpingAlly(Entity ally) {
		Array<Action> result = []
		Map<Cell, Map<Item, Action>> bestActions = MapAction.getMapBestAction()

		for (Cell cell : Map<Item, Action> itemActions in bestActions) {
			for (Item item : Action action in itemActions) {
				if (action.score == null || action.score! <= 0) continue
				// Check if this action targets the ally (heal/buff)
				if (action.to == ally.cell) {
					// Only include if it's a helpful action (check item effects)
					if (MapCellScore.isHelpfulAction(action, ally)) {
						push(result, action)
					}
				}
			}
		}

		return result
	}

	/*
	 * Check if an AOE action hits a specific target
	 */
	static boolean actionHitsTarget(Action action, Entity target) {
		// Get cells affected by this AOE
		Array<Cell> affectedCells = action.to.getAreaCells(action.item.area)
		for (Cell c in affectedCells) {
			if (c == target.cell) return true
		}
		return false
	}

	/*
	 * Check if action is helpful (heal/buff) for an ally.
	 * Uses TargetType.allies which covers all ally-targeting effects.
	 */
	static boolean isHelpfulAction(Action action, Entity ally) {
		for (ItemEffect effect in action.item.effects) {
			if (effect.targetType.allies) {
				return true
			}
		}
		return false
	}
}

// ════════════════════════════════════════════════════════════════
// MAIN EXPLORER
// ════════════════════════════════════════════════════════════════

class ComboExplorer {
	// Current exploration context (set during explore())
	static ExplorationContext? ctx = null

	/*
	 * Main entry point
	 */
	static Combo explore() {
		Benchmark.start("ComboExplorer.explore")

		// Create fresh context for this exploration
		ExplorationContext ctx = ExplorationContext()
		ComboExplorer.ctx = ctx

		// Refresh cell scoring
		MapCellScore.refresh()

		// Phase 0: Stay in place - ALWAYS runs (cheap baseline, guaranteed result)
		ComboExplorer.phaseStay(ctx)

		// Phase T: Target Focus
		if (!ctx.shouldStop()) {
			ComboExplorer.phaseTargetFocus(ctx)
		}

		// Phase 1: Single-cell MP sampling
		if (!ctx.shouldStop()) {
			ComboExplorer.phaseSingleCell(ctx)
		}

		// Phase 2: Multi-cell pairs
		if (!ctx.shouldStop()) {
			ComboExplorer.phaseMultiCell(ctx)
		}

		// Phase 3: Three-cell combos
		if (!ctx.shouldStop()) {
			ComboExplorer.phaseThreeCell(ctx)
		}

		// Phase S: SummonPlan - check if pre-computed summon+buff plans beat current best
		ComboExplorer.phaseSummonPlan(ctx)

		// Log results
		ComboExplorer.logResults(ctx)

		Benchmark.stop("ComboExplorer.explore")

		// Return best combo (guaranteed from Phase 0)
		return ctx.bestResult!.combo
	}

	// ════════════════════════════════════════════════════════════
	// PHASE S: SUMMON PLAN
	// Check if pre-computed summon+buff plans beat current best
	// ════════════════════════════════════════════════════════════

	static void phaseSummonPlan(ExplorationContext ctx) {
		// Check each summon chip for plans
		for (Item item in Fight.self.items) {
			if (!item.isSummon) continue

			// Check offensive plan
			OffensivePlan? offPlan = MapSummon.getBestOffensivePlan(item.id)
			if (offPlan != null) {
				// Only record if it beats current best
				if (ctx.bestResult == null || offPlan!.score > ctx.bestResult!.score) {
					string buffStr = count(offPlan!.buffs) > 0 ? "+" + offPlan!.buffs[0].chip.name : ""
					ExplorerResult result = ExplorerResult(offPlan!.combo, "S:" + item.name + buffStr, "S")
					ctx.recordResult(result)
				}
			}

			// Check defensive plan
			DefensivePlan? defPlan = MapSummon.getBestDefensivePlan(item.id)
			if (defPlan != null) {
				// Only record if it beats current best
				if (ctx.bestResult == null || defPlan!.score > ctx.bestResult!.score) {
					string buffStr = count(defPlan!.buffs) > 0 ? "+" + defPlan!.buffs[0].chip.name : ""
					ExplorerResult result = ExplorerResult(defPlan!.combo, "D:" + item.name + buffStr, "D")
					ctx.recordResult(result)
				}
			}
		}
	}

	// ════════════════════════════════════════════════════════════
	// PHASE T: TARGET FOCUS
	// ════════════════════════════════════════════════════════════

	static void phaseTargetFocus(ExplorationContext ctx) {
		Benchmark.start("ComboExplorer.phaseTargetFocus")

		boolean hasMPBuff = ctx.maxMPBuff > 0

		// For each enemy: try kill focus (with and without Liberation, with and without MP buff)
		for (Entity enemy in Fight.getEnemiesAlive()) {
			if (ctx.shouldStop()) break
			if (enemy.isInvincible) continue

			// Variant A: Max damage on this enemy (no MP buff)
			ComboExplorer.tryKillTarget(ctx, enemy, null, "T:Kill_" + enemy.name, false)

			// Variant B: With MP buff to reach extended cells
			if (hasMPBuff) {
				if (ctx.shouldStop()) break
				ComboExplorer.tryKillTarget(ctx, enemy, null, "T:Kill_" + enemy.name + "+B", true)
			}

			// Variant C: Liberation first, then max damage (no MP buff)
			if (Fight.liberationReady && Fight.liberationItem != null) {
				if (ctx.shouldStop()) break
				ComboExplorer.tryKillTarget(ctx, enemy, Fight.liberationItem, "T:Lib+" + enemy.name, false)

				// Variant D: Liberation + MP buff
				if (hasMPBuff) {
					if (ctx.shouldStop()) break
					ComboExplorer.tryKillTarget(ctx, enemy, Fight.liberationItem, "T:Lib+" + enemy.name + "+B", true)
				}
			}
		}

		// For each ally (not self): try support focus (with and without MP buff)
		for (Entity ally in Fight.getAlliesAlive()) {
			if (ctx.shouldStop()) break
			if (ally == Fight.self) continue

			ComboExplorer.trySupportAlly(ctx, ally, "T:Help_" + ally.name, false)

			if (hasMPBuff) {
				if (ctx.shouldStop()) break
				ComboExplorer.trySupportAlly(ctx, ally, "T:Help_" + ally.name + "+B", true)
			}
		}

		Benchmark.stop("ComboExplorer.phaseTargetFocus")
	}

	/*
	 * Try to kill a specific target using ComboBuilder
	 */
	static void tryKillTarget(ExplorationContext ctx, Entity target, Item? liberationItem, string name, boolean useMPBuff) {
		Combo? combo = ComboBuilder.buildForTarget(ctx, target, liberationItem, useMPBuff)
		if (combo == null) return;

		if (count(combo!.actions) > 0 || combo!.finalPosition!.score > 0) {
			ctx.recordResult(ExplorerResult(combo!, name, "T"))
		}
	}

	/*
	 * Try to support a specific ally using ComboBuilder
	 */
	static void trySupportAlly(ExplorationContext ctx, Entity ally, string name, boolean useMPBuff) {
		Combo? combo = ComboBuilder.buildForAlly(ctx, ally, useMPBuff)
		if (combo == null) return;

		if (count(combo!.actions) > 0 || combo!.finalPosition!.score > 0) {
			ctx.recordResult(ExplorerResult(combo!, name, "T"))
		}
	}

	// ════════════════════════════════════════════════════════════
	// PHASE 0: STAY IN PLACE
	// ════════════════════════════════════════════════════════════

	static void phaseStay(ExplorationContext ctx) {
		Benchmark.start("ComboExplorer.phaseStay")

		Combo combo = ComboBuilder.buildAtCell(ctx, Fight.self.cell, 0)
		ctx.recordResult(ExplorerResult(combo, "P0:Stay", "0"))

		Benchmark.stop("ComboExplorer.phaseStay")
	}

	// ════════════════════════════════════════════════════════════
	// PHASE 1: SINGLE-CELL MP SAMPLING
	// ════════════════════════════════════════════════════════════

	static void phaseSingleCell(ExplorationContext ctx) {
		Benchmark.start("ComboExplorer.phaseSingleCell")

		integer maxMP = ctx.initialMP
		integer maxMPBuff = ctx.maxMPBuff

		// Phase 1a: Current MP range (no buffs needed)
		for (integer offenseMP = 1; offenseMP <= maxMP; offenseMP++) {
			if (ctx.shouldStop()) break

			// Find best cell at exactly this distance (each iteration explores a new ring)
			Cell? bestCell = ComboExplorer.findBestCellAtDistance(ctx, offenseMP)
			if (bestCell == null) continue

			// Reserve (maxMP - offenseMP) for defense
			integer reserveMP = maxMP - offenseMP
			Combo combo = ComboBuilder.buildAtCell(ctx, bestCell!, reserveMP)
			ctx.recordResult(ExplorerResult(combo, "P1:MP" + offenseMP, "1"))
		}

		// Phase 1b: Extended range (requires MP buffs)
		if (maxMPBuff > 0) {
			integer maxExtended = maxMP + maxMPBuff

			for (integer offenseMP = maxMP + 1; offenseMP <= maxExtended; offenseMP++) {
				if (ctx.shouldStop()) break

				// Find best cell at this extended distance
				Cell? bestCell = ComboExplorer.findBestCellAtExtendedDistance(ctx, offenseMP)
				if (bestCell == null) continue

				// Build combo with auto MP buffs
				Combo? combo = ComboBuilder.buildAtCellBuffed(ctx, bestCell!, offenseMP)
				if (combo != null) {
					ctx.recordResult(ExplorerResult(combo!, "P1:MP" + offenseMP + "B", "1"))
				}
			}
		}

		Benchmark.stop("ComboExplorer.phaseSingleCell")
	}

	/*
	 * Find the best cell at exactly the given MP distance.
	 * Each offenseMP value explores a new "ring" of cells, avoiding redundant
	 * evaluation of closer cells already covered by smaller budgets.
	 */
	static Cell? findBestCellAtDistance(ExplorationContext ctx, integer distance) {
		Cell? best = null
		real bestScore = -999999.0

		Map<Cell, integer> reachable = ctx.reachableCells

		for (Cell cell : real score in MapCellScore.cellScores) {
			integer? dist = reachable[cell]
			if (dist == null || dist! != distance) continue  // exact match only

			if (score > bestScore) {
				bestScore = score
				best = cell
			}
		}

		return best
	}

	/*
	 * Find the best cell at exactly the given extended distance.
	 * Used for cells beyond current MP that require MP buffs to reach.
	 * Only considers cells in the extended range (distance > currentMP).
	 */
	static Cell? findBestCellAtExtendedDistance(ExplorationContext ctx, integer distance) {
		Cell? best = null
		real bestScore = -999999.0

		Map<Cell, integer> reachable = ctx.extendedReachableCells

		for (Cell cell : real score in MapCellScore.cellScores) {
			integer? dist = reachable[cell]
			if (dist == null || dist! != distance) continue  // exact match only

			if (score > bestScore) {
				bestScore = score
				best = cell
			}
		}

		return best
	}

	// ════════════════════════════════════════════════════════════
	// PHASE 2: MULTI-CELL PAIRS
	// ════════════════════════════════════════════════════════════

	static void phaseMultiCell(ExplorationContext ctx) {
		Benchmark.start("ComboExplorer.phaseMultiCell")

		Array<Cell> interesting = MapCellScore.interestingCells
		integer n = count(interesting)

		// Try all pairs
		for (integer i = 0; i < n; i++) {
			if (ctx.shouldStop()) break

			for (integer j = i + 1; j < n; j++) {
				if (ctx.shouldStop()) break

				Cell cellA = interesting[i]
				Cell cellB = interesting[j]

				// Try both orderings
				ComboExplorer.tryPairOrder(ctx, cellA, cellB)
				if (ctx.shouldStop()) break
				ComboExplorer.tryPairOrder(ctx, cellB, cellA)
			}
		}

		Benchmark.stop("ComboExplorer.phaseMultiCell")
	}

	/*
	 * Try a specific pair ordering: first -> second
	 */
	static void tryPairOrder(ExplorationContext ctx, Cell first, Cell second) {
		Combo? combo = ComboBuilder.buildAcrossCells(ctx, [first, second], true)
		if (combo == null) return;

		string name = "P2:" + first.id + "->" + second.id
		ctx.recordResult(ExplorerResult(combo!, name, "2"))
	}

	// ════════════════════════════════════════════════════════════
	// PHASE 3: THREE-CELL COMBOS
	// ════════════════════════════════════════════════════════════

	static void phaseThreeCell(ExplorationContext ctx) {
		Benchmark.start("ComboExplorer.phaseThreeCell")

		Array<Cell> interesting = MapCellScore.interestingCells
		integer n = min(ExplorerConfig.INTERESTING_CELLS_K_PHASE3, count(interesting))

		// Try all triplets with all 6 orderings
		for (integer i = 0; i < n; i++) {
			if (ctx.shouldStop()) break
			for (integer j = i + 1; j < n; j++) {
				if (ctx.shouldStop()) break
				for (integer k = j + 1; k < n; k++) {
					if (ctx.shouldStop()) break

					Cell cellA = interesting[i]
					Cell cellB = interesting[j]
					Cell cellC = interesting[k]

					// Try all 6 orderings
					ComboExplorer.tryTripletOrder(ctx, cellA, cellB, cellC)
					if (ctx.shouldStop()) break
					ComboExplorer.tryTripletOrder(ctx, cellA, cellC, cellB)
					if (ctx.shouldStop()) break
					ComboExplorer.tryTripletOrder(ctx, cellB, cellA, cellC)
					if (ctx.shouldStop()) break
					ComboExplorer.tryTripletOrder(ctx, cellB, cellC, cellA)
					if (ctx.shouldStop()) break
					ComboExplorer.tryTripletOrder(ctx, cellC, cellA, cellB)
					if (ctx.shouldStop()) break
					ComboExplorer.tryTripletOrder(ctx, cellC, cellB, cellA)
				}
			}
		}

		Benchmark.stop("ComboExplorer.phaseThreeCell")
	}

	/*
	 * Try a specific triplet ordering: first -> second -> third
	 */
	static void tryTripletOrder(ExplorationContext ctx, Cell first, Cell second, Cell third) {
		Combo? combo = ComboBuilder.buildAcrossCells(ctx, [first, second, third], true)
		if (combo == null) return;

		string name = "P3:" + first.id + "->" + second.id + "->" + third.id
		ctx.recordResult(ExplorerResult(combo!, name, "3"))
	}

	// ════════════════════════════════════════════════════════════
	// LOGGING
	// ════════════════════════════════════════════════════════════

	static void logResults(ExplorationContext ctx) {
		// Sort top results
		ctx.topResults = arraySort(ctx.topResults, (ExplorerResult a, ExplorerResult b) => integer|real {
			return Sort.desc(a.score, b.score)
		}) as Array<ExplorerResult>

		// Log top 5 to Benchmark
		integer logged = 0
		for (ExplorerResult r in ctx.topResults) {
			if (logged >= ExplorerConfig.MAX_RESULTS_KEPT) break

			string desc = "EXP[" + r.name + "]:" + ComboExplorer.buildComboDesc(r.combo)
			real posScore = r.combo.finalPosition != null ? r.combo.finalPosition!.score : 0.0
			real actionScore = r.score - posScore
			Benchmark.addCombo(r.score, count(r.combo.actions), desc, posScore, actionScore)
			logged++
		}

		// Log summary
		debug("ComboExplorer: " + ctx.combosEvaluated + " combos, best=" +
			(ctx.bestResult != null ? ctx.bestResult!.name : "none") +
			" score=" + (ctx.bestResult != null ? round(ctx.bestResult!.score) : 0))
	}

	/*
	 * Build description string for a combo
	 */
	static string buildComboDesc(Combo combo) {
		string desc = ""
		for (Action a in combo.actions) {
			if (desc != "") desc += "->"
			desc += a.item.name + "(" + round(a.score!) + ")"
		}
		if (combo.finalPosition != null) {
			if (desc != "") desc += "->"
			desc += "mv(" + combo.finalPosition!.cell.id + ")"
		}
		if (desc == "") desc = "stay"
		return desc
	}
}
