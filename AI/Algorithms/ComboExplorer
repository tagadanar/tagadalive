/*
 * ComboExplorer - Multi-phase combo exploration algorithm
 *
 * Explores action combinations across multiple cells to find optimal combos.
 * Uses precomputed actions from MapAction (no duplication).
 *
 * Phases (in order):
 * - Phase 0: Stay in place (cheap baseline, 0 MP offense)
 * - Phase T: Target focus
 *   - Kill each enemy: 4 variants (±Liberation × ±MPBuff)
 *   - Support each ally: 2 variants (±MPBuff)
 * - Phase 1a: Single-cell MP sampling (1..maxMP, no buffs needed)
 * - Phase 1b: Extended range cells (maxMP+1..maxMP+maxMPBuff, with minimal buffs)
 * - Phase 2: Multi-cell pairs (top K cells, both orderings, minimal buffs if needed)
 * - Phase 3: Three-cell combos (top K cells, all 6 orderings, minimal buffs if needed)
 *
 * Key principles:
 * - Action SELECTION by knapsack (optimal TP allocation)
 * - Action ORDERING by priority (for execution)
 * - Greedy FALLBACK after kills (fill remaining TP)
 * - Proper consequence chaining
 * - Weapon switch costs handled in Consequences
 * - Operation budget checked after each combo
 * - MP buffs: stacked minimally to reach extended cells (minimize TP spent)
 */

// ════════════════════════════════════════════════════════════════
// CONFIGURATION
// ════════════════════════════════════════════════════════════════

class ExplorerConfig {
	// Top K cells for Phase 2 multi-cell exploration
	// Complexity is O(K²): K=10 → 90 combos, K=15 → 210, K=20 → 380
	static integer INTERESTING_CELLS_K = 10
	// Top K cells for Phase 3 three-cell exploration
	// Complexity is O(K³ × 6): K=7 → 210 combos, K=10 → 720 combos
	static integer INTERESTING_CELLS_K_PHASE3 = 7
	static integer OPERATION_BUFFER = 150000
	static integer MAX_RESULTS_KEPT = 10
	static integer MAX_RESULTS_LOGGED = 5
}

// ════════════════════════════════════════════════════════════════
// RESULT WRAPPER
// ════════════════════════════════════════════════════════════════

class ExplorerResult {
	Combo combo
	string name      // e.g., "T:Kill_Goblin", "P0:Stay", "P2:A→B"
	string phase     // "T", "0", "1", "2", "3"
	real score

	constructor(Combo combo, string name, string phase) {
		this.combo = combo
		this.name = name
		this.phase = phase
		this.score = combo.getScore()!
	}

	string string() {
		return "<ExplorerResult " + this.name + " score:" + round(this.score) + ">"
	}
}

// ════════════════════════════════════════════════════════════════
// CELL SCORING (No duplication)
// ════════════════════════════════════════════════════════════════

class MapCellScore {
	// Cell → total action score (sum of best actions per item)
	static Map<Cell, real> cellScores = [:]

	// Cell → actions sorted by (priority ASC, score DESC)
	static Map<Cell, Array<Action>> cellActions = [:]

	// Self-cast actions (available from any cell)
	static Array<Action> selfCastActions = []

	// Top K interesting cells (sorted by score DESC)
	static Array<Cell> interestingCells = []

	/*
	 * Refresh cell scoring from MapAction (no duplication)
	 */
	static void refresh() {
		MapCellScore.cellScores = [:]
		MapCellScore.cellActions = [:]
		MapCellScore.selfCastActions = []

		Map<Cell, Map<Item, Action>> bestActions = MapAction.getMapBestAction()

		for (Cell cell : Map<Item, Action> itemActions in bestActions) {
			real totalScore = 0.0
			Array<Action> actions = []

			for (Item item : Action action in itemActions) {
				if (action.score == null || action.score! <= 0) continue
				totalScore += action.score!
				push(actions, action)
			}

			if (count(actions) == 0) continue

			// Sort by priority ASC, score DESC (for execution order)
			actions = MapCellScore.sortByPriority(actions)

			// Handle self-cast separately
			if (cell == Fight.selfCell) {
				MapCellScore.selfCastActions = actions
			} else {
				MapCellScore.cellScores[cell] = totalScore
				MapCellScore.cellActions[cell] = actions
			}
		}

		// Build interesting cells list (top K by score)
		MapCellScore.interestingCells = []
		Array<Cell> allCells = []
		for (Cell cell : real score in MapCellScore.cellScores) {
			push(allCells, cell)
		}

		allCells = arraySort(allCells, (Cell a, Cell b) => integer|real {
			return Sort.desc(MapCellScore.cellScores[a]!, MapCellScore.cellScores[b]!)
		}) as Array<Cell>

		integer k = min(ExplorerConfig.INTERESTING_CELLS_K, count(allCells))
		for (integer i = 0; i < k; i++) {
			push(MapCellScore.interestingCells, allCells[i])
		}
	}

	/*
	 * Sort actions by priority ASC, then score DESC
	 */
	static Array<Action> sortByPriority(Array<Action> actions) {
		return arraySort(actions, (Action a, Action b) => integer|real {
			if (a.item.priority != b.item.priority) {
				return Sort.asc(a.item.priority, b.item.priority)
			}
			return Sort.desc(a.score!, b.score!)
		}) as Array<Action>
	}

	/*
	 * Sort actions by score DESC (for selection)
	 */
	static Array<Action> sortByScore(Array<Action> actions) {
		return arraySort(actions, (Action a, Action b) => integer|real {
			return Sort.desc(a.score!, b.score!)
		}) as Array<Action>
	}

	/*
	 * Display cell scores on the map (for debugging)
	 * Color: black = reachable but no useful action
	 *        red (low) to green (high) gradient = has actions
	 *        blue = top K selected cells
	 * Text: rounded score value
	 */
	static void showCellScores() {
		// Find max for normalization
		real maxScore = 1.0
		for (Cell c : real s in MapCellScore.cellScores) {
			if (s > maxScore) maxScore = s
		}

		// Build set of interesting cells for O(1) lookup
		Map<Cell, boolean> isInteresting = [:]
		for (Cell c in MapCellScore.interestingCells) {
			isInteresting[c] = true
		}

		// Color all reachable cells
		for (Cell c : integer dist in Fight.self.reachableCells) {
			real? score = MapCellScore.cellScores[c]
			if (isInteresting[c]) {
				mark(c.id, getColor(0, 0, 255))
				markText(c.id, round(score!) + "")
			} else if (score != null && score! > 0) {
				integer green = ((score! * 255) / maxScore) as integer
				integer red = 255 - green
				mark(c.id, getColor(red, green, 0))
				markText(c.id, round(score!) + "")
			} else {
				// Reachable but no useful action
				mark(c.id, getColor(0, 0, 0))
			}
		}
	}

	/*
	 * Get actions for a cell (including self-cast merged in)
	 */
	static Array<Action> getActionsForCell(Cell cell) {
		Array<Action> result = []

		// Add cell-specific actions
		if (MapCellScore.cellActions[cell] != null) {
			for (Action a in MapCellScore.cellActions[cell]!) {
				push(result, a)
			}
		}

		// Add self-cast actions
		for (Action a in MapCellScore.selfCastActions) {
			push(result, a)
		}

		return result
	}

	/*
	 * Get all actions that damage a specific target
	 */
	static Array<Action> getActionsDamagingTarget(Entity target) {
		Array<Action> result = []
		Map<Cell, Map<Item, Action>> bestActions = MapAction.getMapBestAction()

		for (Cell cell : Map<Item, Action> itemActions in bestActions) {
			for (Item item : Action action in itemActions) {
				if (action.score == null || action.score! <= 0) continue
				// Check if this action targets the enemy
				if (action.to == target.cell || (action.item.isAOE && MapCellScore.actionHitsTarget(action, target))) {
					push(result, action)
				}
			}
		}

		return result
	}

	/*
	 * Get all actions that help a specific ally (heals/buffs)
	 */
	static Array<Action> getActionsHelpingAlly(Entity ally) {
		Array<Action> result = []
		Map<Cell, Map<Item, Action>> bestActions = MapAction.getMapBestAction()

		for (Cell cell : Map<Item, Action> itemActions in bestActions) {
			for (Item item : Action action in itemActions) {
				if (action.score == null || action.score! <= 0) continue
				// Check if this action targets the ally (heal/buff)
				if (action.to == ally.cell) {
					// Only include if it's a helpful action (check item effects)
					if (MapCellScore.isHelpfulAction(action, ally)) {
						push(result, action)
					}
				}
			}
		}

		return result
	}

	/*
	 * Check if an AOE action hits a specific target
	 */
	static boolean actionHitsTarget(Action action, Entity target) {
		// Get cells affected by this AOE
		Array<Cell> affectedCells = action.to.getAreaCells(action.item.area)
		for (Cell c in affectedCells) {
			if (c == target.cell) return true
		}
		return false
	}

	/*
	 * Check if action is helpful (heal/buff) for an ally.
	 * Uses TargetType.allies which covers all ally-targeting effects.
	 */
	static boolean isHelpfulAction(Action action, Entity ally) {
		for (ItemEffect effect in action.item.effects) {
			if (effect.targetType.allies) {
				return true
			}
		}
		return false
	}
}

// ════════════════════════════════════════════════════════════════
// COMBO BUILDER HELPERS
// ════════════════════════════════════════════════════════════════

class ComboBuilder {
	/*
	 * Build ignoreCells array for pathfinding: base cells + killed entities
	 */
	static Array<Cell> buildIgnoreCells(Consequences csq) {
		Array<Cell> ignoreCells = clone(Fight.self.cellsToIgnore) as Array<Cell>
		for (Entity e : Entity _ in csq._killed) {
			push(ignoreCells, e.cell)
		}
		return ignoreCells
	}

	/*
	 * Try to add an action to a combo, checking all preconditions.
	 * Handles: usage limits, TP cost, weapon switch, reachability with reserveMP.
	 * Updates usesThisTurn map if action was added.
	 *
	 * @param combo The combo to add to
	 * @param action The action to try adding
	 * @param usesThisTurn Map tracking item usage counts this turn
	 * @param reserveMP MP to reserve for defense (subtracted from available MP)
	 * @return true if action was added, false otherwise
	 */
	static boolean tryAddAction(Combo combo, Action action, Map<Item, integer> usesThisTurn, integer reserveMP) {
		// Check usage limit
		integer uses = usesThisTurn[action.item] != null ? usesThisTurn[action.item]! : 0
		if (uses >= action.item.maxUse) return false

		// Get current state
		Consequences csq = combo.getCurrentConsequences()

		// Check TP (including weapon switch cost)
		integer switchCost = (action.item.isWeap && action.item != csq.currentWeapon) ? 1 : 0
		if (csq.currentTP < action.item.cost + switchCost) return false

		// Check reachability
		if (action.from != Fight.selfCell) {
			Array<Cell> ignoreCells = ComboBuilder.buildIgnoreCells(csq)
			integer effectiveMP = max(0, csq.currentMP - reserveMP)
			Map<Cell, integer> reachable = MapPath.getCachedReachableCells(
				csq.currentCell, effectiveMP, ignoreCells)
			if (reachable[action.from] == null || reachable[action.from]! > effectiveMP) return false
		}

		// Try to add
		boolean added = combo.add(action)
		if (added) {
			usesThisTurn[action.item] = uses + 1
		}
		return added
	}

	/*
	 * Build a combo executing actions across multiple cells in order
	 * cellSequence: array of cells to visit in order
	 * cellActionMap: cell → actions to execute there (already priority-sorted)
	 */
	static Combo buildMultiCell(Array<Cell> cellSequence, Map<Cell, Array<Action>> cellActionMap) {
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		for (Cell cell in cellSequence) {
			Array<Action>? actions = cellActionMap[cell]
			if (actions == null) continue

			for (Action action in actions!) {
				ComboBuilder.tryAddAction(combo, action, usesThisTurn, 0)
			}
		}

		// Find best final position
		Consequences finalCsq = combo.getCurrentConsequences()
		Position pos = MapPosition.findBestPosition(finalCsq.currentCell, finalCsq.currentMP, finalCsq)
		combo.addFinalPosition(pos)

		return combo
	}

	/*
	 * Build combo using knapsack for optimal TP allocation + greedy fallback for kills
	 *
	 * Strategy:
	 * 1. Use ActionKnapsack to select optimal set of actions within TP budget
	 * 2. Try to add selected actions in priority order
	 * 3. When an action fails (target dead), skip and continue
	 * 4. After processing selected actions, greedy-fill remaining TP from pool
	 *
	 * This handles the case where knapsack over-allocates to a target that gets killed.
	 *
	 * @param pool All available actions
	 * @param availableTP Maximum TP to spend
	 * @param currentWeapon Currently equipped weapon
	 * @param restrictToCurrentCell If true, only use actions from current cell for fallback
	 * @param reserveMP MP to reserve for defense (default 0)
	 * @return Built combo with final position
	 */
	static Combo buildWithKnapsack(Array<Action> pool, integer availableTP, Item? currentWeapon, boolean restrictToCurrentCell, integer reserveMP) {
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]

		// Step 1: Use knapsack to select optimal actions
		Array<Action> selected = ActionKnapsack.solve(pool, availableTP, currentWeapon)

		// Step 2: Sort selected by priority for execution order
		selected = MapCellScore.sortByPriority(selected)

		// Step 3: Build set of selected action keys for tracking
		Map<integer, boolean> selectedKeys = [:]
		for (Action a in selected) {
			selectedKeys[ComboBuilder.actionKey(a)] = true
		}

		// Step 4: Try to add selected actions
		for (Action action in selected) {
			ComboBuilder.tryAddAction(combo, action, usesThisTurn, reserveMP)
		}

		// Step 5: Greedy fallback - fill remaining TP from unselected pool
		Consequences currentCsq = combo.getCurrentConsequences()
		if (currentCsq.currentTP > 0) {
			// Get remaining actions not in selected set
			Array<Action> remaining = []
			for (Action a in pool) {
				if (selectedKeys[ComboBuilder.actionKey(a)]) continue
				if (a.score == null || a.score! <= 0) continue

				// If restricting to current cell, skip actions from other cells
				if (restrictToCurrentCell) {
					if (a.from != Fight.selfCell && a.from != currentCsq.currentCell) continue
				}

				push(remaining, a)
			}

			// Sort by score for greedy fill
			remaining = MapCellScore.sortByScore(remaining)

			// Try to fill
			for (Action action in remaining) {
				ComboBuilder.tryAddAction(combo, action, usesThisTurn, reserveMP)
			}
		}

		// Step 6: Final position
		Consequences finalCsq = combo.getCurrentConsequences()
		Position pos = MapPosition.findBestPosition(finalCsq.currentCell, finalCsq.currentMP, finalCsq)
		combo.addFinalPosition(pos)

		return combo
	}

	/*
	 * Unique key for action (for deduplication)
	 */
	static integer actionKey(Action a) {
		return a.item.id * 10000000 + a.from.id * 10000 + a.to.id
	}
}

// ════════════════════════════════════════════════════════════════
// MAIN EXPLORER
// ════════════════════════════════════════════════════════════════

class ComboExplorer {
	// Best results tracking
	static Array<ExplorerResult> topResults = []
	static ExplorerResult? bestResult = null

	// Statistics
	static integer combosEvaluated = 0
	static string bestPhase = ""

	/*
	 * Check if we should stop (operation budget exhausted)
	 */
	static boolean shouldStop() {
		return getOperations() > getMaxOperations() - ExplorerConfig.OPERATION_BUFFER
	}

	/*
	 * Main entry point
	 */
	static Combo explore() {
		Benchmark.start("ComboExplorer.explore")

		// Initialize
		ComboExplorer.topResults = []
		ComboExplorer.bestResult = null
		ComboExplorer.combosEvaluated = 0

		// Refresh cell scoring
		MapCellScore.refresh()

		// Phase 0: Stay in place - ALWAYS runs (cheap baseline, guaranteed result)
		ComboExplorer.phaseStay()

		// Phase T: Target Focus
		if (!ComboExplorer.shouldStop()) {
			ComboExplorer.phaseTargetFocus()
		}

		// Phase 1: Single-cell MP sampling
		if (!ComboExplorer.shouldStop()) {
			ComboExplorer.phaseSingleCell()
		}

		// Phase 2: Multi-cell pairs
		if (!ComboExplorer.shouldStop()) {
			ComboExplorer.phaseMultiCell()
		}

		// Phase 3: Three-cell combos
		if (!ComboExplorer.shouldStop()) {
			ComboExplorer.phaseThreeCell()
		}

		// Log results
		ComboExplorer.logResults()

		Benchmark.stop("ComboExplorer.explore")

		// Return best combo (guaranteed from Phase 0)
		return ComboExplorer.bestResult!.combo
	}

	/*
	 * Record a result and update best if needed
	 */
	static void recordResult(ExplorerResult result) {
		ComboExplorer.combosEvaluated++

		// Update best
		if (ComboExplorer.bestResult == null || result.score > ComboExplorer.bestResult!.score) {
			ComboExplorer.bestResult = result
			ComboExplorer.bestPhase = result.phase
		}

		// Keep top N results
		push(ComboExplorer.topResults, result)
		if (count(ComboExplorer.topResults) > ExplorerConfig.MAX_RESULTS_KEPT) {
			// Sort and trim
			ComboExplorer.topResults = arraySort(ComboExplorer.topResults, (ExplorerResult a, ExplorerResult b) => integer|real {
				return Sort.desc(a.score, b.score)
			}) as Array<ExplorerResult>
			ComboExplorer.topResults = arraySlice(ComboExplorer.topResults, 0, ExplorerConfig.MAX_RESULTS_KEPT) as Array<ExplorerResult>
		}
	}

	// ════════════════════════════════════════════════════════════
	// PHASE T: TARGET FOCUS
	// ════════════════════════════════════════════════════════════

	static void phaseTargetFocus() {
		Benchmark.start("ComboExplorer.phaseTargetFocus")

		// Check if we have Liberation available
		boolean hasLiberation = false
		Item? liberationItem = null
		for (Item item in Fight.self.items) {
			if (item.id == CHIP_LIBERATION && getCooldown(item.id, Fight.self.id) == 0) {
				hasLiberation = true
				liberationItem = item
				break
			}
		}

		boolean hasMPBuff = Fight.self.maxMPBuff > 0

		// For each enemy: try kill focus (with and without Liberation, with and without MP buff)
		for (Entity enemy in Fight.getEnemiesAlive()) {
			if (ComboExplorer.shouldStop()) break
			if (enemy.isInvincible) continue

			// Variant A: Max damage on this enemy (no MP buff)
			ComboExplorer.tryKillTarget(enemy, null, "T:Kill_" + enemy.name, false)

			// Variant B: With MP buff to reach extended cells
			if (hasMPBuff) {
				if (ComboExplorer.shouldStop()) break
				ComboExplorer.tryKillTarget(enemy, null, "T:Kill_" + enemy.name + "+B", true)
			}

			// Variant C: Liberation first, then max damage (no MP buff)
			if (hasLiberation && liberationItem != null) {
				if (ComboExplorer.shouldStop()) break
				ComboExplorer.tryKillTarget(enemy, liberationItem, "T:Lib+" + enemy.name, false)

				// Variant D: Liberation + MP buff
				if (hasMPBuff) {
					if (ComboExplorer.shouldStop()) break
					ComboExplorer.tryKillTarget(enemy, liberationItem, "T:Lib+" + enemy.name + "+B", true)
				}
			}
		}

		// For each ally (not self): try support focus (with and without MP buff)
		for (Entity ally in Fight.getAlliesAlive()) {
			if (ComboExplorer.shouldStop()) break
			if (ally == Fight.self) continue

			ComboExplorer.trySupportAlly(ally, "T:Help_" + ally.name, false)

			if (hasMPBuff) {
				if (ComboExplorer.shouldStop()) break
				ComboExplorer.trySupportAlly(ally, "T:Help_" + ally.name + "+B", true)
			}
		}

		Benchmark.stop("ComboExplorer.phaseTargetFocus")
	}

	/*
	 * Try to kill a specific target
	 * If liberationItem is provided, use it first
	 * If useMPBuff is true, prepend minimal MP buffs to reach extended-range actions
	 * Uses knapsack for optimal damage allocation
	 */
	static void tryKillTarget(Entity target, Item? liberationItem, string name, boolean useMPBuff) {
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]
		integer baseMP = Fight.self.mp

		// Get all actions that can damage this target (includes extended range)
		Array<Action> damageActions = MapCellScore.getActionsDamagingTarget(target)

		// Filter to current reach if not using MP buff
		if (!useMPBuff) {
			Array<Action> filtered = []
			for (Action a in damageActions) {
				if (a.from == Fight.selfCell) {
					push(filtered, a)
				} else {
					integer? dist = Fight.self.reachableCells[a.from]
					if (dist != null && dist! <= baseMP) {
						push(filtered, a)
					}
				}
			}
			damageActions = filtered
		}

		// Calculate MP buffs if requested
		Array<Action> mpBuffActions = []
		if (useMPBuff && Fight.self.maxMPBuff > 0) {
			// Find farthest attack cell among damage actions
			integer maxDistNeeded = 0
			for (Action a in damageActions) {
				if (a.from == Fight.selfCell) continue
				integer? dist = Fight.self.extendedReachableCells[a.from]
				if (dist != null && dist! > maxDistNeeded) {
					maxDistNeeded = dist!
				}
			}

			// Get minimal buffs if we need extended reach
			if (maxDistNeeded > baseMP) {
				integer neededBuff = maxDistNeeded - baseMP
				Array<Action>? buffs = ComboExplorer.findMinimalMPBuffs(neededBuff, Fight.self.tp)
				if (buffs == null) return;  // Can't reach, skip this variant
				mpBuffActions = buffs!
			}
		}

		// Add MP buffs first
		for (Action buff in mpBuffActions) {
			combo.add(buff)
			usesThisTurn[buff.item] = 1
		}

		// If Liberation, find and execute it
		if (liberationItem != null) {
			Consequences csq = combo.getCurrentConsequences()
			// Find Liberation action targeting this enemy
			Action? libAction = ComboExplorer.findLiberationAction(liberationItem!, target, csq)
			if (libAction != null) {
				boolean added = combo.add(libAction!)
				if (added) {
					usesThisTurn[liberationItem!] = 1
				}
			}
		}

		// Get state AFTER buffs and Liberation (chained consequences)
		Consequences currentCsq = combo.getCurrentConsequences()
		integer remainingTP = currentCsq.currentTP
		Item? currentWeapon = currentCsq.currentWeapon

		// Exclude buff actions from damage pool
		Map<integer, boolean> buffKeys = [:]
		for (Action buff in mpBuffActions) {
			buffKeys[ComboBuilder.actionKey(buff)] = true
		}
		Array<Action> filteredActions = []
		for (Action a in damageActions) {
			if (!buffKeys[ComboBuilder.actionKey(a)]) {
				push(filteredActions, a)
			}
		}

		// Use knapsack to select optimal set of damage actions
		Array<Action> selected = ActionKnapsack.solve(filteredActions, remainingTP, currentWeapon)

		// Sort by priority for execution
		selected = MapCellScore.sortByPriority(selected)

		// Build set of selected keys for greedy fallback
		Map<integer, boolean> selectedKeys = [:]
		for (Action a in selected) {
			selectedKeys[ComboBuilder.actionKey(a)] = true
		}

		// Try to add selected actions (stop if target dies)
		for (Action action in selected) {
			if (combo.getCurrentConsequences().isKilled(target)) break
			ComboBuilder.tryAddAction(combo, action, usesThisTurn, 0)
		}

		// Greedy fallback: fill remaining TP
		Consequences csq = combo.getCurrentConsequences()
		if (csq.currentTP > 0) {
			Array<Action> remaining = []
			boolean targetDead = csq.isKilled(target)

			if (targetDead) {
				// Target dead → expand to full action pool
				// Note: cellActions excludes self-cast (stored separately)
				for (Cell cell : Array<Action> actions in MapCellScore.cellActions) {
					for (Action a in actions) {
						if (selectedKeys[ComboBuilder.actionKey(a)]) continue
						if (a.score == null || a.score! <= 0) continue
						push(remaining, a)
					}
				}
				// Add self-cast actions (not in cellActions)
				for (Action a in MapCellScore.selfCastActions) {
					if (selectedKeys[ComboBuilder.actionKey(a)]) continue
					if (a.score == null || a.score! <= 0) continue
					push(remaining, a)
				}
			} else {
				// Target alive → stick to damageActions (try to finish kill)
				for (Action a in damageActions) {
					if (selectedKeys[ComboBuilder.actionKey(a)]) continue
					if (a.score == null || a.score! <= 0) continue
					push(remaining, a)
				}
			}

			remaining = MapCellScore.sortByScore(remaining)

			for (Action action in remaining) {
				// Only break on kill if we were trying to kill (not in full-pool mode)
				if (!targetDead && combo.getCurrentConsequences().isKilled(target)) break
				ComboBuilder.tryAddAction(combo, action, usesThisTurn, 0)
			}
		}

		// Final position
		Consequences finalCsq = combo.getCurrentConsequences()
		Position pos = MapPosition.findBestPosition(finalCsq.currentCell, finalCsq.currentMP, finalCsq)
		combo.addFinalPosition(pos)

		// Record result
		if (count(combo.actions) > 0 || pos.score > 0) {
			ComboExplorer.recordResult(ExplorerResult(combo, name, "T"))
		}
	}

	/*
	 * Try to support a specific ally
	 * If useMPBuff is true, prepend minimal MP buffs to reach extended-range actions
	 * Uses knapsack for optimal support allocation
	 */
	static void trySupportAlly(Entity ally, string name, boolean useMPBuff) {
		Combo combo = Combo()
		Map<Item, integer> usesThisTurn = [:]
		integer baseMP = Fight.self.mp

		// Get all actions that help this ally (may include healing weapons)
		Array<Action> helpActions = MapCellScore.getActionsHelpingAlly(ally)

		// Filter to current reach if not using MP buff
		if (!useMPBuff) {
			Array<Action> filtered = []
			for (Action a in helpActions) {
				if (a.from == Fight.selfCell) {
					push(filtered, a)
				} else {
					integer? dist = Fight.self.reachableCells[a.from]
					if (dist != null && dist! <= baseMP) {
						push(filtered, a)
					}
				}
			}
			helpActions = filtered
		}

		// Calculate MP buffs if requested
		Array<Action> mpBuffActions = []
		if (useMPBuff && Fight.self.maxMPBuff > 0) {
			// Find farthest support cell among help actions
			integer maxDistNeeded = 0
			for (Action a in helpActions) {
				if (a.from == Fight.selfCell) continue
				integer? dist = Fight.self.extendedReachableCells[a.from]
				if (dist != null && dist! > maxDistNeeded) {
					maxDistNeeded = dist!
				}
			}

			// Get minimal buffs if we need extended reach
			if (maxDistNeeded > baseMP) {
				integer neededBuff = maxDistNeeded - baseMP
				Array<Action>? buffs = ComboExplorer.findMinimalMPBuffs(neededBuff, Fight.self.tp)
				if (buffs == null) return;  // Can't reach, skip this variant
				mpBuffActions = buffs!
			}
		}

		// Add MP buffs first
		for (Action buff in mpBuffActions) {
			combo.add(buff)
			usesThisTurn[buff.item] = 1
		}

		// Get state after buffs
		Consequences currentCsq = combo.getCurrentConsequences()
		integer remainingTP = currentCsq.currentTP
		Item? currentWeapon = currentCsq.currentWeapon

		// Exclude buff actions from help pool
		Map<integer, boolean> buffKeys = [:]
		for (Action buff in mpBuffActions) {
			buffKeys[ComboBuilder.actionKey(buff)] = true
		}
		Array<Action> filteredActions = []
		for (Action a in helpActions) {
			if (!buffKeys[ComboBuilder.actionKey(a)]) {
				push(filteredActions, a)
			}
		}

		// Use knapsack to select optimal set of help actions
		Array<Action> selected = ActionKnapsack.solve(filteredActions, remainingTP, currentWeapon)

		// Sort by priority for execution
		selected = MapCellScore.sortByPriority(selected)

		// Build set of selected keys for greedy fallback
		Map<integer, boolean> selectedKeys = [:]
		for (Action a in selected) {
			selectedKeys[ComboBuilder.actionKey(a)] = true
		}

		// Try to add selected actions
		for (Action action in selected) {
			ComboBuilder.tryAddAction(combo, action, usesThisTurn, 0)
		}

		// Greedy fallback: if TP remaining, try unselected actions
		if (combo.getCurrentConsequences().currentTP > 0) {
			// Sort remaining by score for greedy fill
			Array<Action> remaining = []
			for (Action a in filteredActions) {
				if (selectedKeys[ComboBuilder.actionKey(a)]) continue
				if (a.score == null || a.score! <= 0) continue
				push(remaining, a)
			}
			remaining = MapCellScore.sortByScore(remaining)

			for (Action action in remaining) {
				ComboBuilder.tryAddAction(combo, action, usesThisTurn, 0)
			}
		}

		// Final position
		Consequences finalCsq = combo.getCurrentConsequences()
		Position pos = MapPosition.findBestPosition(finalCsq.currentCell, finalCsq.currentMP, finalCsq)
		combo.addFinalPosition(pos)

		// Record result
		if (count(combo.actions) > 0 || pos.score > 0) {
			ComboExplorer.recordResult(ExplorerResult(combo, name, "T"))
		}
	}

	/*
	 * Find a Liberation action targeting a specific enemy.
	 * Liberation reduces ALL effects by 40% - including enemy shields, buffs, and HoTs.
	 * Strategy: strip defenses first, then maximize damage.
	 */
	static Action? findLiberationAction(Item liberationItem, Entity target, Consequences csq) {
		Map<Cell, Map<Item, Action>> bestActions = MapAction.getMapBestAction()

		for (Cell cell : Map<Item, Action> itemActions in bestActions) {
			Action? action = itemActions[liberationItem]
			if (action == null) continue

			// Check if this action targets our target
			if (action!.to == target.cell) {
				// Check reachability
				if (action!.from != Fight.selfCell) {
					Array<Cell> ignoreCells = ComboBuilder.buildIgnoreCells(csq)
					Map<Cell, integer> reachable = MapPath.getCachedReachableCells(csq.currentCell, csq.currentMP, ignoreCells)
					if (reachable[action!.from] == null || reachable[action!.from]! > csq.currentMP) continue
				}
				return action
			}
		}
		return null
	}

	// ════════════════════════════════════════════════════════════
	// PHASE 0: STAY IN PLACE
	// ════════════════════════════════════════════════════════════

	static void phaseStay() {
		Benchmark.start("ComboExplorer.phaseStay")

		// Get actions at current cell (including self-cast)
		Array<Action> actions = MapCellScore.getActionsForCell(Fight.self.cell)

		// Build combo with knapsack - restrict to current cell for fallback
		Combo combo = ComboBuilder.buildWithKnapsack(
			actions,
			Fight.self.tp,
			Fight.self.getWeaponInHand(),
			true,  // restrictToCurrentCell
			0      // reserveMP (0 for stay-in-place)
		)

		ComboExplorer.recordResult(ExplorerResult(combo, "P0:Stay", "0"))

		Benchmark.stop("ComboExplorer.phaseStay")
	}

	// ════════════════════════════════════════════════════════════
	// PHASE 1: SINGLE-CELL MP SAMPLING
	// ════════════════════════════════════════════════════════════

	static void phaseSingleCell() {
		Benchmark.start("ComboExplorer.phaseSingleCell")

		integer maxMP = Fight.self.mp
		integer maxMPBuff = Fight.self.maxMPBuff

		// Phase 1a: Current MP range (no buffs needed)
		for (integer offenseMP = 1; offenseMP <= maxMP; offenseMP++) {
			if (ComboExplorer.shouldStop()) break

			// Find best cell at exactly this distance (each iteration explores a new ring)
			Cell? bestCell = ComboExplorer.findBestCellAtDistance(offenseMP)
			if (bestCell == null) continue

			// Get actions for this cell
			Array<Action> actions = MapCellScore.getActionsForCell(bestCell!)

			// Build combo with knapsack - reserve (maxMP - offenseMP) for defense
			integer reserveMP = maxMP - offenseMP
			Combo combo = ComboBuilder.buildWithKnapsack(
				actions,
				Fight.self.tp,
				Fight.self.getWeaponInHand(),
				true,      // restrictToCurrentCell
				reserveMP  // reserve MP for defense
			)

			ComboExplorer.recordResult(ExplorerResult(combo, "P1:MP" + offenseMP, "1"))
		}

		// Phase 1b: Extended range (requires MP buffs)
		if (maxMPBuff > 0) {
			integer maxExtended = maxMP + maxMPBuff

			for (integer offenseMP = maxMP + 1; offenseMP <= maxExtended; offenseMP++) {
				if (ComboExplorer.shouldStop()) break

				// Find best cell at this extended distance
				Cell? bestCell = ComboExplorer.findBestCellAtExtendedDistance(offenseMP)
				if (bestCell == null) continue

				// Calculate needed MP buff
				integer neededBuff = offenseMP - maxMP

				// Find minimal buffs to achieve this
				Array<Action>? buffs = ComboExplorer.findMinimalMPBuffs(neededBuff, Fight.self.tp)
				if (buffs == null) continue

				// Build combo: prepend buffs, then actions at cell
				Combo combo = Combo()
				Map<Item, integer> usesThisTurn = [:]

				// Add buffs first
				for (Action buff in buffs!) {
					combo.add(buff)
					usesThisTurn[buff.item] = 1
				}

				// Get state after buffs
				Consequences csq = combo.getCurrentConsequences()
				integer remainingTP = csq.currentTP

				// Get actions for target cell
				Array<Action> actions = MapCellScore.getActionsForCell(bestCell!)

				// Select optimal actions with remaining TP
				Array<Action> selected = ActionKnapsack.solve(actions, remainingTP, csq.currentWeapon)
				selected = MapCellScore.sortByPriority(selected)

				// Reserve MP: after reaching cell, we have (buffedMP - offenseMP) left
				// buffedMP = maxMP + actualGain from buffs = csq.currentMP
				integer reserveMP = csq.currentMP - offenseMP

				// Add selected actions
				for (Action a in selected) {
					ComboBuilder.tryAddAction(combo, a, usesThisTurn, reserveMP)
				}

				// Final position
				Consequences finalCsq = combo.getCurrentConsequences()
				Position pos = MapPosition.findBestPosition(finalCsq.currentCell, finalCsq.currentMP, finalCsq)
				combo.addFinalPosition(pos)

				ComboExplorer.recordResult(ExplorerResult(combo, "P1:MP" + offenseMP + "B", "1"))
			}
		}

		Benchmark.stop("ComboExplorer.phaseSingleCell")
	}

	/*
	 * Find the best cell at exactly the given MP distance.
	 * Each offenseMP value explores a new "ring" of cells, avoiding redundant
	 * evaluation of closer cells already covered by smaller budgets.
	 */
	static Cell? findBestCellAtDistance(integer distance) {
		Cell? best = null
		real bestScore = -999999.0

		Map<Cell, integer> reachable = Fight.self.reachableCells

		for (Cell cell : real score in MapCellScore.cellScores) {
			integer? dist = reachable[cell]
			if (dist == null || dist! != distance) continue  // exact match only

			if (score > bestScore) {
				bestScore = score
				best = cell
			}
		}

		return best
	}

	/*
	 * Find the best cell at exactly the given extended distance.
	 * Used for cells beyond current MP that require MP buffs to reach.
	 * Only considers cells in the extended range (distance > currentMP).
	 */
	static Cell? findBestCellAtExtendedDistance(integer distance) {
		Cell? best = null
		real bestScore = -999999.0

		Map<Cell, integer> reachable = Fight.self.extendedReachableCells

		for (Cell cell : real score in MapCellScore.cellScores) {
			integer? dist = reachable[cell]
			if (dist == null || dist! != distance) continue  // exact match only

			if (score > bestScore) {
				bestScore = score
				best = cell
			}
		}

		return best
	}

	// ════════════════════════════════════════════════════════════
	// PHASE 2: MULTI-CELL PAIRS
	// ════════════════════════════════════════════════════════════

	static void phaseMultiCell() {
		Benchmark.start("ComboExplorer.phaseMultiCell")

		Array<Cell> interesting = MapCellScore.interestingCells
		integer n = count(interesting)

		// Try all pairs
		for (integer i = 0; i < n; i++) {
			if (ComboExplorer.shouldStop()) break

			for (integer j = i + 1; j < n; j++) {
				if (ComboExplorer.shouldStop()) break

				Cell cellA = interesting[i]
				Cell cellB = interesting[j]

				// Try both orderings
				ComboExplorer.tryPairOrder(cellA, cellB)
				if (ComboExplorer.shouldStop()) break
				ComboExplorer.tryPairOrder(cellB, cellA)
			}
		}

		Benchmark.stop("ComboExplorer.phaseMultiCell")
	}

	// ════════════════════════════════════════════════════════════
	// PHASE 3: THREE-CELL COMBOS
	// ════════════════════════════════════════════════════════════

	static void phaseThreeCell() {
		Benchmark.start("ComboExplorer.phaseThreeCell")

		Array<Cell> interesting = MapCellScore.interestingCells
		integer n = min(ExplorerConfig.INTERESTING_CELLS_K_PHASE3, count(interesting))

		// Try all triplets with all 6 orderings
		for (integer i = 0; i < n; i++) {
			if (ComboExplorer.shouldStop()) break
			for (integer j = i + 1; j < n; j++) {
				if (ComboExplorer.shouldStop()) break
				for (integer k = j + 1; k < n; k++) {
					if (ComboExplorer.shouldStop()) break

					Cell cellA = interesting[i]
					Cell cellB = interesting[j]
					Cell cellC = interesting[k]

					// Try all 6 orderings
					ComboExplorer.tryTripletOrder(cellA, cellB, cellC)
					if (ComboExplorer.shouldStop()) break
					ComboExplorer.tryTripletOrder(cellA, cellC, cellB)
					if (ComboExplorer.shouldStop()) break
					ComboExplorer.tryTripletOrder(cellB, cellA, cellC)
					if (ComboExplorer.shouldStop()) break
					ComboExplorer.tryTripletOrder(cellB, cellC, cellA)
					if (ComboExplorer.shouldStop()) break
					ComboExplorer.tryTripletOrder(cellC, cellA, cellB)
					if (ComboExplorer.shouldStop()) break
					ComboExplorer.tryTripletOrder(cellC, cellB, cellA)
				}
			}
		}

		Benchmark.stop("ComboExplorer.phaseThreeCell")
	}

	/*
	 * Try a specific triplet ordering: first → second → third
	 * Uses minimal MP buffs when needed to complete the path.
	 */
	static ExplorerResult? tryTripletOrder(Cell first, Cell second, Cell third) {
		integer baseMP = Fight.self.mp
		integer baseTP = Fight.self.tp
		integer maxMPBuff = Fight.self.maxMPBuff
		Array<Cell> ignoreCells = clone(Fight.self.cellsToIgnore) as Array<Cell>

		// Check if first is reachable (use extended reach for initial check)
		integer? distToFirst = Fight.self.extendedReachableCells[first]
		if (distToFirst == null) return null

		// Find all distances using max possible MP
		integer maxPossibleMP = baseMP + maxMPBuff

		// === Leg 1: start → first ===
		integer mpAfterFirstMax = maxPossibleMP - distToFirst!
		if (mpAfterFirstMax <= 0) return null

		// === Leg 2: first → second ===
		Map<Cell, integer> reachFromFirstMax = MapPath.getCachedReachableCells(first, mpAfterFirstMax, ignoreCells)
		integer? distFirstToSecond = reachFromFirstMax[second]
		if (distFirstToSecond == null) return null

		integer mpAfterSecondMax = mpAfterFirstMax - distFirstToSecond!
		if (mpAfterSecondMax <= 0) return null

		// === Leg 3: second → third ===
		Map<Cell, integer> reachFromSecondMax = MapPath.getCachedReachableCells(second, mpAfterSecondMax, ignoreCells)
		integer? distSecondToThird = reachFromSecondMax[third]
		if (distSecondToThird == null) return null

		// Calculate total MP needed and minimal buff required
		integer totalMPNeeded = distToFirst! + distFirstToSecond! + distSecondToThird!
		integer neededBuff = max(0, totalMPNeeded - baseMP)

		// Get minimal buffs if needed
		Array<Action> mpBuffActions = []
		integer effectiveTP = baseTP
		Item? effectiveWeapon = Fight.self.getWeaponInHand()

		if (neededBuff > 0) {
			Array<Action>? buffs = ComboExplorer.findMinimalMPBuffs(neededBuff, baseTP)
			if (buffs == null) return null

			mpBuffActions = buffs!

			// Calculate effective TP/weapon after buffs
			integer tpSpent = 0
			for (Action buff in mpBuffActions) {
				tpSpent += buff.item.cost
				effectiveWeapon = buff.consequences.currentWeapon
			}
			effectiveTP = baseTP - tpSpent
		}

		// === All legs reachable, build combo ===

		// Pool actions from all 3 cells
		Array<Action> poolFirst = MapCellScore.getActionsForCell(first)
		Array<Action> poolSecond = MapCellScore.getActionsForCell(second)
		Array<Action> poolThird = MapCellScore.getActionsForCell(third)

		// Combine pools, avoid duplicates
		Array<Action> combined = []
		Map<integer, boolean> seen = [:]

		// Build set of buff keys to exclude
		Map<integer, boolean> buffKeys = [:]
		for (Action buff in mpBuffActions) {
			buffKeys[ComboBuilder.actionKey(buff)] = true
		}

		for (Action a in poolFirst) {
			integer key = ComboBuilder.actionKey(a)
			if (buffKeys[key]) continue
			if (!seen[key]) {
				push(combined, a)
				seen[key] = true
			}
		}
		for (Action a in poolSecond) {
			integer key = ComboBuilder.actionKey(a)
			if (buffKeys[key]) continue
			if (!seen[key]) {
				push(combined, a)
				seen[key] = true
			}
		}
		for (Action a in poolThird) {
			integer key = ComboBuilder.actionKey(a)
			if (buffKeys[key]) continue
			if (!seen[key]) {
				push(combined, a)
				seen[key] = true
			}
		}

		// Use knapsack
		Array<Action> selected = ActionKnapsack.solve(combined, effectiveTP, effectiveWeapon)
		if (count(selected) == 0 && count(mpBuffActions) == 0) return null

		// Partition actions by cell
		Map<Cell, Array<Action>> cellActionMap = [:]
		cellActionMap[first] = []
		cellActionMap[second] = []
		cellActionMap[third] = []

		// Prepend MP buffs to first cell
		for (Action buff in mpBuffActions) {
			push(cellActionMap[first]!, buff)
		}

		for (Action action in selected) {
			if (action.from == Fight.selfCell) {
				push(cellActionMap[first]!, action)
			} else if (action.from == first) {
				push(cellActionMap[first]!, action)
			} else if (action.from == second) {
				push(cellActionMap[second]!, action)
			} else if (action.from == third) {
				push(cellActionMap[third]!, action)
			}
		}

		// Sort by priority
		cellActionMap[first] = MapCellScore.sortByPriority(cellActionMap[first]!)
		cellActionMap[second] = MapCellScore.sortByPriority(cellActionMap[second]!)
		cellActionMap[third] = MapCellScore.sortByPriority(cellActionMap[third]!)

		// Build combo
		Array<Cell> sequence = [first, second, third]
		Combo combo = ComboBuilder.buildMultiCell(sequence, cellActionMap)

		string name = "P3:" + first.id + "→" + second.id + "→" + third.id
		ExplorerResult result = ExplorerResult(combo, name, "3")
		ComboExplorer.recordResult(result)

		return result
	}

	/*
	 * Find minimal set of MP buff actions to achieve at least neededMP extra.
	 * Greedy by efficiency (MP/TP) to minimize TP spent.
	 * Returns null if impossible to achieve neededMP with available buffs/TP.
	 *
	 * @param neededMP Minimum extra MP required
	 * @param availableTP Maximum TP budget for buffs
	 * @return Array of buff actions to prepend, or null if impossible
	 */
	static Array<Action>? findMinimalMPBuffs(integer neededMP, integer availableTP) {
		if (neededMP <= 0) return []

		integer baseMP = Fight.self.mp

		// Build set of MP buff chips already active on self
		Map<integer, boolean> activeBuffChips = [:]
		for (EntityEffect e in Fight.self.effects) {
			if (e.type == EFFECT_BUFF_MP || e.type == EFFECT_RAW_BUFF_MP) {
				activeBuffChips[e.item.id] = true
			}
		}

		// Collect all affordable MP buff actions with their gains
		Array<Action> allBuffs = []
		for (Action a in MapCellScore.selfCastActions) {
			if (a.item.cost > availableTP) continue

			// Skip if buff already active (would just refresh, not stack)
			if (activeBuffChips[a.item.id]) continue

			// Check for MP buff effect
			boolean hasMPBuff = false
			for (ItemEffect effect in a.item.effects) {
				if (effect.type == EFFECT_BUFF_MP || effect.type == EFFECT_RAW_BUFF_MP) {
					hasMPBuff = true
					break
				}
			}
			if (!hasMPBuff) continue

			push(allBuffs, a)
		}

		if (count(allBuffs) == 0) return null

		// Sort by efficiency (MP gain / TP cost) descending - minimizes TP spent
		allBuffs = arraySort(allBuffs, (Action a, Action b) => integer|real {
			real gainA = a.consequences.currentMP - baseMP
			real gainB = b.consequences.currentMP - baseMP
			real effA = gainA / a.item.cost
			real effB = gainB / b.item.cost
			return Sort.desc(effA, effB)
		}) as Array<Action>

		// Greedy selection: pick most efficient until we have enough
		Array<Action> selected = []
		integer totalGain = 0
		integer tpSpent = 0

		for (Action a in allBuffs) {
			if (totalGain >= neededMP) break
			if (tpSpent + a.item.cost > availableTP) continue

			integer gain = a.consequences.currentMP - baseMP
			push(selected, a)
			totalGain += gain
			tpSpent += a.item.cost
		}

		return totalGain >= neededMP ? selected : null
	}

	/*
	 * Try a specific pair ordering: first → second
	 * Pre-checks MP reachability using actual pathfinding, using minimal MP buffs if needed.
	 */
	static ExplorerResult? tryPairOrder(Cell first, Cell second) {
		integer baseMP = Fight.self.mp
		integer baseTP = Fight.self.tp
		integer maxMPBuff = Fight.self.maxMPBuff
		Array<Cell> ignoreCells = clone(Fight.self.cellsToIgnore) as Array<Cell>

		// Check if first is reachable (use extended reach for initial check)
		integer? distToFirst = Fight.self.extendedReachableCells[first]
		if (distToFirst == null) return null

		// Find distance from first to second using max possible MP
		integer maxPossibleMP = baseMP + maxMPBuff
		integer mpAfterFirstMax = maxPossibleMP - distToFirst!

		if (mpAfterFirstMax <= 0) return null  // Can't even reach first with full buffs

		Map<Cell, integer> reachableFromFirstMax = MapPath.getCachedReachableCells(first, mpAfterFirstMax, ignoreCells)
		integer? distFirstToSecond = reachableFromFirstMax[second]

		if (distFirstToSecond == null) return null  // Can't reach second even with full buffs

		// Calculate total MP needed and minimal buff required
		integer totalMPNeeded = distToFirst! + distFirstToSecond!
		integer neededBuff = max(0, totalMPNeeded - baseMP)

		// Get minimal buffs if needed
		Array<Action> mpBuffActions = []
		integer effectiveTP = baseTP
		Item? effectiveWeapon = Fight.self.getWeaponInHand()

		if (neededBuff > 0) {
			Array<Action>? buffs = ComboExplorer.findMinimalMPBuffs(neededBuff, baseTP)
			if (buffs == null) return null

			mpBuffActions = buffs!

			// Calculate effective TP/weapon after buffs (chain consequences)
			integer tpSpent = 0
			for (Action buff in mpBuffActions) {
				tpSpent += buff.item.cost
				effectiveWeapon = buff.consequences.currentWeapon
			}
			effectiveTP = baseTP - tpSpent
		}

		// Pool actions from both cells
		Array<Action> poolFirst = MapCellScore.getActionsForCell(first)
		Array<Action> poolSecond = MapCellScore.getActionsForCell(second)

		// Combine pools (avoid duplicates for self-cast)
		Array<Action> combined = []
		Map<integer, boolean> seen = [:]

		// Build set of buff keys to exclude
		Map<integer, boolean> buffKeys = [:]
		for (Action buff in mpBuffActions) {
			buffKeys[ComboBuilder.actionKey(buff)] = true
		}

		for (Action a in poolFirst) {
			integer key = ComboBuilder.actionKey(a)
			if (buffKeys[key]) continue  // Skip pre-selected buff
			if (!seen[key]) {
				push(combined, a)
				seen[key] = true
			}
		}
		for (Action a in poolSecond) {
			integer key = ComboBuilder.actionKey(a)
			if (buffKeys[key]) continue  // Skip pre-selected buff
			if (!seen[key]) {
				push(combined, a)
				seen[key] = true
			}
		}

		// Use knapsack with adjusted TP budget
		Array<Action> selected = ActionKnapsack.solve(combined, effectiveTP, effectiveWeapon)

		if (count(selected) == 0 && count(mpBuffActions) == 0) return null

		// Partition actions by cell
		Map<Cell, Array<Action>> cellActionMap = [:]
		cellActionMap[first] = []
		cellActionMap[second] = []

		// Prepend MP buffs to first cell
		for (Action buff in mpBuffActions) {
			push(cellActionMap[first]!, buff)
		}

		for (Action action in selected) {
			if (action.from == Fight.selfCell) {
				// Self-cast: add to first cell (will be executed there)
				push(cellActionMap[first]!, action)
			} else if (action.from == first) {
				push(cellActionMap[first]!, action)
			} else if (action.from == second) {
				push(cellActionMap[second]!, action)
			}
			// Actions from other cells are skipped (shouldn't happen with proper filtering)
		}

		// Sort each cell's actions by priority
		cellActionMap[first] = MapCellScore.sortByPriority(cellActionMap[first]!)
		cellActionMap[second] = MapCellScore.sortByPriority(cellActionMap[second]!)

		// Build combo with cell sequence
		Array<Cell> sequence = [first, second]
		Combo combo = ComboBuilder.buildMultiCell(sequence, cellActionMap)

		string name = "P2:" + first.id + "→" + second.id
		ExplorerResult result = ExplorerResult(combo, name, "2")
		ComboExplorer.recordResult(result)

		return result
	}

	// ════════════════════════════════════════════════════════════
	// LOGGING
	// ════════════════════════════════════════════════════════════

	static void logResults() {
		// Sort top results
		ComboExplorer.topResults = arraySort(ComboExplorer.topResults, (ExplorerResult a, ExplorerResult b) => integer|real {
			return Sort.desc(a.score, b.score)
		}) as Array<ExplorerResult>

		// Log top 5 to Benchmark
		integer logged = 0
		for (ExplorerResult r in ComboExplorer.topResults) {
			if (logged >= ExplorerConfig.MAX_RESULTS_LOGGED) break

			string desc = "EXP[" + r.name + "]:" + ComboExplorer.buildComboDesc(r.combo)
			real posScore = r.combo.finalPosition != null ? r.combo.finalPosition!.score : 0.0
			real actionScore = r.score - posScore
			Benchmark.addCombo(r.score, count(r.combo.actions), desc, posScore, actionScore)
			logged++
		}

		// Log summary
		debug("ComboExplorer: " + ComboExplorer.combosEvaluated + " combos, best=" +
			(ComboExplorer.bestResult != null ? ComboExplorer.bestResult!.name : "none") +
			" score=" + (ComboExplorer.bestResult != null ? round(ComboExplorer.bestResult!.score) : 0))
	}

	/*
	 * Build description string for a combo
	 */
	static string buildComboDesc(Combo combo) {
		string desc = ""
		for (Action a in combo.actions) {
			if (desc != "") desc += "→"
			desc += a.item.name + "(" + round(a.score!) + ")"
		}
		if (combo.finalPosition != null) {
			if (desc != "") desc += "→"
			desc += "mv(" + combo.finalPosition!.cell.id + ")"
		}
		if (desc == "") desc = "stay"
		return desc
	}
}
