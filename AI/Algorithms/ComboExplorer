/*
 * ComboExplorer - Multi-phase combo exploration algorithm
 *
 * Explores action combinations across multiple cells to find optimal combos.
 * Uses precomputed actions from MapAction (no duplication).
 *
 * Phases (in order):
 * - Phase 0: Stay in place (cheap baseline, 0 MP offense)
 * - Phase T: Target focus
 *   - Kill each enemy: 4 variants (Liberation x MPBuff)
 *   - Support each ally: 2 variants (MPBuff)
 * - Phase 1a: Single-cell MP sampling (1..maxMP, no buffs needed)
 * - Phase 1b: Extended range cells (maxMP+1..maxMP+maxMPBuff, with minimal buffs)
 * - Phase 2: Multi-cell pairs (top K cells, both orderings, minimal buffs if needed)
 * - Phase 3: Three-cell combos (top K cells, all 6 orderings, minimal buffs if needed)
 *
 * Key principles:
 * - Action SELECTION by knapsack (optimal TP allocation)
 * - Action ORDERING by priority (for execution)
 * - Greedy FALLBACK after kills (fill remaining TP)
 * - Proper consequence chaining
 * - Weapon switch costs handled in Consequences
 * - Operation budget checked after each combo
 * - MP buffs: stacked minimally to reach extended cells (minimize TP spent)
 */

// ════════════════════════════════════════════════════════════════
// CONFIGURATION
// ════════════════════════════════════════════════════════════════

class ExplorerConfig {
	// Top K cells for Phase 2 multi-cell exploration
	// Complexity is O(K^2): K=10 -> 90 combos, K=15 -> 210, K=20 -> 380
	static integer INTERESTING_CELLS_K = 10
	// Top K cells for Phase 3 three-cell exploration
	// Complexity is O(K^3 x 6): K=7 -> 210 combos, K=10 -> 720 combos
	static integer INTERESTING_CELLS_K_PHASE3 = 7
	// Operation buffer: dynamic for main leek (base + per bulb + potential summon), fixed for bulbs
	static integer OPERATION_BUFFER_LEEK_BASE = 250000
	static integer OPERATION_BUFFER_PER_BULB = 200000
	static integer OPERATION_BUFFER_POTENTIAL_SUMMON = 200000
	static integer OPERATION_BUFFER_BULB = 200000
	static integer MAX_RESULTS_KEPT = 5
}

// ════════════════════════════════════════════════════════════════
// RESULT WRAPPER
// ════════════════════════════════════════════════════════════════

class ExplorerResult {
	Combo combo
	string name      // e.g., "T:Kill_Goblin", "P0:Stay", "P2:A->B"
	string phase     // "T", "0", "1", "2", "3"
	real score

	constructor(Combo combo, string name, string phase) {
		this.combo = combo
		this.name = name
		this.phase = phase
		this.score = combo.getScore()!
	}

	string string() {
		return "<ExplorerResult " + this.name + " score:" + round(this.score) + ">"
	}
}

// ════════════════════════════════════════════════════════════════
// CELL SCORING (No duplication)
// ════════════════════════════════════════════════════════════════

class MapCellScore {
	// Cell -> total action score (sum of best actions per item)
	static Map<Cell, real> cellScores = [:]

	// Cell -> actions (unsorted, sorted lazily in buildWithKnapsack)
	static Map<Cell, Array<Action>> cellActions = [:]

	// Self-cast actions (available from any cell)
	static Array<Action> selfCastActions = []

	// Top K interesting cells (sorted by score DESC)
	static Array<Cell> interestingCells = []

	/*
	 * Refresh cell scoring from MapAction (no duplication)
	 */
	static void refresh() {
		MapCellScore.cellScores = [:]
		MapCellScore.cellActions = [:]
		MapCellScore.selfCastActions = []

		Map<Cell, Map<Item, Action>> bestActions = MapAction.getMapBestAction()

		for (Cell cell : Map<Item, Action> itemActions in bestActions) {
			real totalScore = 0.0
			Array<Action> actions = []

			for (Item item : Action action in itemActions) {
				if (action.score == null || action.score! <= 0) continue
				totalScore += action.score!
				push(actions, action)
			}

			if (count(actions) == 0) continue

			// Handle self-cast separately
			if (cell == Fight.selfCell) {
				MapCellScore.selfCastActions = actions
			} else {
				MapCellScore.cellScores[cell] = totalScore
				MapCellScore.cellActions[cell] = actions
			}
		}

		// Build interesting cells list (top K by score)
		MapCellScore.interestingCells = []
		Array<Cell> allCells = []
		for (Cell cell : real score in MapCellScore.cellScores) {
			push(allCells, cell)
		}

		allCells = arraySort(allCells, (Cell a, Cell b) => integer|real {
			return Sort.desc(MapCellScore.cellScores[a]!, MapCellScore.cellScores[b]!)
		}) as Array<Cell>

		integer k = min(ExplorerConfig.INTERESTING_CELLS_K, count(allCells))
		for (integer i = 0; i < k; i++) {
			push(MapCellScore.interestingCells, allCells[i])
		}
	}

	/*
	 * Sort actions by priority ASC, then score DESC
	 */
	static Array<Action> sortByPriority(Array<Action> actions) {
		return arraySort(actions, (Action a, Action b) => integer|real {
			if (a.item.priority != b.item.priority) {
				return Sort.asc(a.item.priority, b.item.priority)
			}
			return Sort.desc(a.score!, b.score!)
		}) as Array<Action>
	}

	/*
	 * Sort actions by score DESC (for selection)
	 */
	static Array<Action> sortByScore(Array<Action> actions) {
		return arraySort(actions, (Action a, Action b) => integer|real {
			return Sort.desc(a.score!, b.score!)
		}) as Array<Action>
	}

	/*
	 * Display cell scores on the map (for debugging)
	 * Color: black = reachable but no useful action
	 *        red (low) to green (high) gradient = has actions
	 *        blue = top K selected cells
	 * Text: rounded score value
	 */
	static void showCellScores() {
		// Find max for normalization
		real maxScore = 1.0
		for (Cell c : real s in MapCellScore.cellScores) {
			if (s > maxScore) maxScore = s
		}

		// Build set of interesting cells for O(1) lookup
		Map<Cell, boolean> isInteresting = [:]
		for (Cell c in MapCellScore.interestingCells) {
			isInteresting[c] = true
		}

		// Color all reachable cells
		for (Cell c : integer dist in Fight.self.reachableCells) {
			real? score = MapCellScore.cellScores[c]
			if (isInteresting[c]) {
				mark(c.id, getColor(0, 0, 255))
				markText(c.id, round(score!) + "")
			} else if (score != null && score! > 0) {
				integer green = ((score! * 255) / maxScore) as integer
				integer red = 255 - green
				mark(c.id, getColor(red, green, 0))
				markText(c.id, round(score!) + "")
			} else {
				// Reachable but no useful action
				mark(c.id, getColor(0, 0, 0))
			}
		}
	}

	/*
	 * Get actions for a cell (including self-cast merged in)
	 */
	static Array<Action> getActionsForCell(Cell cell) {
		Array<Action> result = []

		// Add cell-specific actions
		if (MapCellScore.cellActions[cell] != null) {
			for (Action a in MapCellScore.cellActions[cell]!) {
				push(result, a)
			}
		}

		// Add self-cast actions
		for (Action a in MapCellScore.selfCastActions) {
			push(result, a)
		}

		return result
	}

	/*
	 * Get all actions that damage a specific target
	 */
	static Array<Action> getActionsDamagingTarget(Entity target) {
		Array<Action> result = []
		Map<Cell, Map<Item, Action>> bestActions = MapAction.getMapBestAction()

		for (Cell cell : Map<Item, Action> itemActions in bestActions) {
			for (Item item : Action action in itemActions) {
				if (action.score == null || action.score! <= 0) continue
				// Check if this action targets the enemy
				if (action.to == target.cell || (action.item.isAOE && MapCellScore.actionHitsTarget(action, target))) {
					push(result, action)
				}
			}
		}

		return result
	}

	/*
	 * Get all actions that help a specific ally (heals/buffs)
	 */
	static Array<Action> getActionsHelpingAlly(Entity ally) {
		Array<Action> result = []
		Map<Cell, Map<Item, Action>> bestActions = MapAction.getMapBestAction()

		for (Cell cell : Map<Item, Action> itemActions in bestActions) {
			for (Item item : Action action in itemActions) {
				if (action.score == null || action.score! <= 0) continue
				// Check if this action targets the ally (heal/buff)
				if (action.to == ally.cell) {
					// Only include if it's a helpful action (check item effects)
					if (MapCellScore.isHelpfulAction(action, ally)) {
						push(result, action)
					}
				}
			}
		}

		return result
	}

	/*
	 * Check if an AOE action hits a specific target
	 */
	static boolean actionHitsTarget(Action action, Entity target) {
		// Get cells affected by this AOE
		Array<Cell> affectedCells = action.to.getAreaCells(action.item.area)
		for (Cell c in affectedCells) {
			if (c == target.cell) return true
		}
		return false
	}

	/*
	 * Check if action is helpful (heal/buff) for an ally.
	 * Uses TargetType.allies which covers all ally-targeting effects.
	 */
	static boolean isHelpfulAction(Action action, Entity ally) {
		for (ItemEffect effect in action.item.effects) {
			if (effect.targetType.allies) {
				return true
			}
		}
		return false
	}
}

// ════════════════════════════════════════════════════════════════
// MAIN EXPLORER
// ════════════════════════════════════════════════════════════════

class ComboExplorer {
	// Best results tracking
	static Array<ExplorerResult> topResults = []
	static ExplorerResult? bestResult = null

	// Statistics
	static integer combosEvaluated = 0
	static string bestPhase = ""

	// Dynamic operation buffer (set at explore() start based on entity type)
	static integer operationBuffer = 0

	/*
	 * Check if we should stop (operation budget exhausted)
	 */
	static boolean shouldStop() {
		return getOperations() > getMaxOperations() - ComboExplorer.operationBuffer
	}

	/*
	 * Main entry point
	 */
	static Combo explore() {
		Benchmark.start("ComboExplorer.explore")

		// Set operation buffer based on entity type
		// Bulbs: fixed buffer. Leeks: base + per-bulb + potential summon
		if (Fight.self.isBulb) {
			ComboExplorer.operationBuffer = ExplorerConfig.OPERATION_BUFFER_BULB
		} else {
			integer bulbCount = count(getSummons())
			ComboExplorer.operationBuffer = ExplorerConfig.OPERATION_BUFFER_LEEK_BASE
				+ bulbCount * ExplorerConfig.OPERATION_BUFFER_PER_BULB
			if (Fight.canSummon) {
				ComboExplorer.operationBuffer += ExplorerConfig.OPERATION_BUFFER_POTENTIAL_SUMMON
			}
		}

		// Initialize
		ComboExplorer.topResults = []
		ComboExplorer.bestResult = null
		ComboExplorer.combosEvaluated = 0

		// Refresh cell scoring
		MapCellScore.refresh()

		// Phase 0: Stay in place - ALWAYS runs (cheap baseline, guaranteed result)
		ComboExplorer.phaseStay()

		// Phase T: Target Focus
		if (!ComboExplorer.shouldStop()) {
			ComboExplorer.phaseTargetFocus()
		}

		// Phase 1: Single-cell MP sampling
		if (!ComboExplorer.shouldStop()) {
			ComboExplorer.phaseSingleCell()
		}

		// Phase 2: Multi-cell pairs
		if (!ComboExplorer.shouldStop()) {
			ComboExplorer.phaseMultiCell()
		}

		// Phase 3: Three-cell combos
		if (!ComboExplorer.shouldStop()) {
			ComboExplorer.phaseThreeCell()
		}

		// Phase S: SummonPlan - check if pre-computed summon+buff plans beat current best
		ComboExplorer.phaseSummonPlan()

		// Log results
		ComboExplorer.logResults()

		Benchmark.stop("ComboExplorer.explore")

		// Return best combo (guaranteed from Phase 0)
		return ComboExplorer.bestResult!.combo
	}

	/*
	 * Record a result and update best if needed
	 */
	static void recordResult(ExplorerResult result) {
		ComboExplorer.combosEvaluated++

		// Update best
		if (ComboExplorer.bestResult == null || result.score > ComboExplorer.bestResult!.score) {
			ComboExplorer.bestResult = result
			ComboExplorer.bestPhase = result.phase
		}

		// Keep top N results
		push(ComboExplorer.topResults, result)
		if (count(ComboExplorer.topResults) > ExplorerConfig.MAX_RESULTS_KEPT) {
			// Sort and trim
			ComboExplorer.topResults = arraySort(ComboExplorer.topResults, (ExplorerResult a, ExplorerResult b) => integer|real {
				return Sort.desc(a.score, b.score)
			}) as Array<ExplorerResult>
			ComboExplorer.topResults = arraySlice(ComboExplorer.topResults, 0, ExplorerConfig.MAX_RESULTS_KEPT) as Array<ExplorerResult>
		}
	}

	// ════════════════════════════════════════════════════════════
	// PHASE S: SUMMON PLAN
	// Check if pre-computed summon+buff plans beat current best
	// ════════════════════════════════════════════════════════════

	static void phaseSummonPlan() {
		// Check each summon chip for plans
		for (Item item in Fight.self.items) {
			if (!item.isSummon) continue

			// Check offensive plan
			OffensivePlan? offPlan = MapSummon.getBestOffensivePlan(item.id)
			if (offPlan != null) {
				// Only record if it beats current best
				if (ComboExplorer.bestResult == null || offPlan!.score > ComboExplorer.bestResult!.score) {
					string buffStr = count(offPlan!.buffs) > 0 ? "+" + offPlan!.buffs[0].chip.name : ""
					ExplorerResult result = ExplorerResult(offPlan!.combo, "S:" + item.name + buffStr, "S")
					ComboExplorer.recordResult(result)
				}
			}

			// Check defensive plan
			DefensivePlan? defPlan = MapSummon.getBestDefensivePlan(item.id)
			if (defPlan != null) {
				// Only record if it beats current best
				if (ComboExplorer.bestResult == null || defPlan!.score > ComboExplorer.bestResult!.score) {
					string buffStr = count(defPlan!.buffs) > 0 ? "+" + defPlan!.buffs[0].chip.name : ""
					ExplorerResult result = ExplorerResult(defPlan!.combo, "D:" + item.name + buffStr, "D")
					ComboExplorer.recordResult(result)
				}
			}
		}
	}

	// ════════════════════════════════════════════════════════════
	// PHASE T: TARGET FOCUS
	// ════════════════════════════════════════════════════════════

	static void phaseTargetFocus() {
		Benchmark.start("ComboExplorer.phaseTargetFocus")

		boolean hasMPBuff = Fight.self.maxMPBuff > 0

		// For each enemy: try kill focus (with and without Liberation, with and without MP buff)
		for (Entity enemy in Fight.getEnemiesAlive()) {
			if (ComboExplorer.shouldStop()) break
			if (enemy.isInvincible) continue

			// Variant A: Max damage on this enemy (no MP buff)
			ComboExplorer.tryKillTarget(enemy, null, "T:Kill_" + enemy.name, false)

			// Variant B: With MP buff to reach extended cells
			if (hasMPBuff) {
				if (ComboExplorer.shouldStop()) break
				ComboExplorer.tryKillTarget(enemy, null, "T:Kill_" + enemy.name + "+B", true)
			}

			// Variant C: Liberation first, then max damage (no MP buff)
			if (Fight.liberationReady && Fight.liberationItem != null) {
				if (ComboExplorer.shouldStop()) break
				ComboExplorer.tryKillTarget(enemy, Fight.liberationItem, "T:Lib+" + enemy.name, false)

				// Variant D: Liberation + MP buff
				if (hasMPBuff) {
					if (ComboExplorer.shouldStop()) break
					ComboExplorer.tryKillTarget(enemy, Fight.liberationItem, "T:Lib+" + enemy.name + "+B", true)
				}
			}
		}

		// For each ally (not self): try support focus (with and without MP buff)
		for (Entity ally in Fight.getAlliesAlive()) {
			if (ComboExplorer.shouldStop()) break
			if (ally == Fight.self) continue

			ComboExplorer.trySupportAlly(ally, "T:Help_" + ally.name, false)

			if (hasMPBuff) {
				if (ComboExplorer.shouldStop()) break
				ComboExplorer.trySupportAlly(ally, "T:Help_" + ally.name + "+B", true)
			}
		}

		Benchmark.stop("ComboExplorer.phaseTargetFocus")
	}

	/*
	 * Try to kill a specific target using ComboBuilder
	 */
	static void tryKillTarget(Entity target, Item? liberationItem, string name, boolean useMPBuff) {
		Combo? combo = ComboBuilder.buildForTarget(target, liberationItem, useMPBuff)
		if (combo == null) return;

		if (count(combo!.actions) > 0 || combo!.finalPosition!.score > 0) {
			ComboExplorer.recordResult(ExplorerResult(combo!, name, "T"))
		}
	}

	/*
	 * Try to support a specific ally using ComboBuilder
	 */
	static void trySupportAlly(Entity ally, string name, boolean useMPBuff) {
		Combo? combo = ComboBuilder.buildForAlly(ally, useMPBuff)
		if (combo == null) return;

		if (count(combo!.actions) > 0 || combo!.finalPosition!.score > 0) {
			ComboExplorer.recordResult(ExplorerResult(combo!, name, "T"))
		}
	}

	// ════════════════════════════════════════════════════════════
	// PHASE 0: STAY IN PLACE
	// ════════════════════════════════════════════════════════════

	static void phaseStay() {
		Benchmark.start("ComboExplorer.phaseStay")

		Combo combo = ComboBuilder.buildAtCell(Fight.self.cell, 0)
		ComboExplorer.recordResult(ExplorerResult(combo, "P0:Stay", "0"))

		Benchmark.stop("ComboExplorer.phaseStay")
	}

	// ════════════════════════════════════════════════════════════
	// PHASE 1: SINGLE-CELL MP SAMPLING
	// ════════════════════════════════════════════════════════════

	static void phaseSingleCell() {
		Benchmark.start("ComboExplorer.phaseSingleCell")

		integer maxMP = Fight.self.mp
		integer maxMPBuff = Fight.self.maxMPBuff

		// Phase 1a: Current MP range (no buffs needed)
		for (integer offenseMP = 1; offenseMP <= maxMP; offenseMP++) {
			if (ComboExplorer.shouldStop()) break

			// Find best cell at exactly this distance (each iteration explores a new ring)
			Cell? bestCell = ComboExplorer.findBestCellAtDistance(offenseMP)
			if (bestCell == null) continue

			// Reserve (maxMP - offenseMP) for defense
			integer reserveMP = maxMP - offenseMP
			Combo combo = ComboBuilder.buildAtCell(bestCell!, reserveMP)
			ComboExplorer.recordResult(ExplorerResult(combo, "P1:MP" + offenseMP, "1"))
		}

		// Phase 1b: Extended range (requires MP buffs)
		if (maxMPBuff > 0) {
			integer maxExtended = maxMP + maxMPBuff

			for (integer offenseMP = maxMP + 1; offenseMP <= maxExtended; offenseMP++) {
				if (ComboExplorer.shouldStop()) break

				// Find best cell at this extended distance
				Cell? bestCell = ComboExplorer.findBestCellAtExtendedDistance(offenseMP)
				if (bestCell == null) continue

				// Build combo with auto MP buffs
				Combo? combo = ComboBuilder.buildAtCellBuffed(bestCell!, offenseMP)
				if (combo != null) {
					ComboExplorer.recordResult(ExplorerResult(combo!, "P1:MP" + offenseMP + "B", "1"))
				}
			}
		}

		Benchmark.stop("ComboExplorer.phaseSingleCell")
	}

	/*
	 * Find the best cell at exactly the given MP distance.
	 * Each offenseMP value explores a new "ring" of cells, avoiding redundant
	 * evaluation of closer cells already covered by smaller budgets.
	 */
	static Cell? findBestCellAtDistance(integer distance) {
		Cell? best = null
		real bestScore = -999999.0

		Map<Cell, integer> reachable = Fight.self.reachableCells

		for (Cell cell : real score in MapCellScore.cellScores) {
			integer? dist = reachable[cell]
			if (dist == null || dist! != distance) continue  // exact match only

			if (score > bestScore) {
				bestScore = score
				best = cell
			}
		}

		return best
	}

	/*
	 * Find the best cell at exactly the given extended distance.
	 * Used for cells beyond current MP that require MP buffs to reach.
	 * Only considers cells in the extended range (distance > currentMP).
	 */
	static Cell? findBestCellAtExtendedDistance(integer distance) {
		Cell? best = null
		real bestScore = -999999.0

		Map<Cell, integer> reachable = Fight.self.extendedReachableCells

		for (Cell cell : real score in MapCellScore.cellScores) {
			integer? dist = reachable[cell]
			if (dist == null || dist! != distance) continue  // exact match only

			if (score > bestScore) {
				bestScore = score
				best = cell
			}
		}

		return best
	}

	// ════════════════════════════════════════════════════════════
	// PHASE 2: MULTI-CELL PAIRS
	// ════════════════════════════════════════════════════════════

	static void phaseMultiCell() {
		Benchmark.start("ComboExplorer.phaseMultiCell")

		Array<Cell> interesting = MapCellScore.interestingCells
		integer n = count(interesting)

		// Try all pairs
		for (integer i = 0; i < n; i++) {
			if (ComboExplorer.shouldStop()) break

			for (integer j = i + 1; j < n; j++) {
				if (ComboExplorer.shouldStop()) break

				Cell cellA = interesting[i]
				Cell cellB = interesting[j]

				// Try both orderings
				ComboExplorer.tryPairOrder(cellA, cellB)
				if (ComboExplorer.shouldStop()) break
				ComboExplorer.tryPairOrder(cellB, cellA)
			}
		}

		Benchmark.stop("ComboExplorer.phaseMultiCell")
	}

	/*
	 * Try a specific pair ordering: first -> second
	 */
	static void tryPairOrder(Cell first, Cell second) {
		Combo? combo = ComboBuilder.buildAcrossCells([first, second], true)
		if (combo == null) return;

		string name = "P2:" + first.id + "->" + second.id
		ComboExplorer.recordResult(ExplorerResult(combo!, name, "2"))
	}

	// ════════════════════════════════════════════════════════════
	// PHASE 3: THREE-CELL COMBOS
	// ════════════════════════════════════════════════════════════

	static void phaseThreeCell() {
		Benchmark.start("ComboExplorer.phaseThreeCell")

		Array<Cell> interesting = MapCellScore.interestingCells
		integer n = min(ExplorerConfig.INTERESTING_CELLS_K_PHASE3, count(interesting))

		// Try all triplets with all 6 orderings
		for (integer i = 0; i < n; i++) {
			if (ComboExplorer.shouldStop()) break
			for (integer j = i + 1; j < n; j++) {
				if (ComboExplorer.shouldStop()) break
				for (integer k = j + 1; k < n; k++) {
					if (ComboExplorer.shouldStop()) break

					Cell cellA = interesting[i]
					Cell cellB = interesting[j]
					Cell cellC = interesting[k]

					// Try all 6 orderings
					ComboExplorer.tryTripletOrder(cellA, cellB, cellC)
					if (ComboExplorer.shouldStop()) break
					ComboExplorer.tryTripletOrder(cellA, cellC, cellB)
					if (ComboExplorer.shouldStop()) break
					ComboExplorer.tryTripletOrder(cellB, cellA, cellC)
					if (ComboExplorer.shouldStop()) break
					ComboExplorer.tryTripletOrder(cellB, cellC, cellA)
					if (ComboExplorer.shouldStop()) break
					ComboExplorer.tryTripletOrder(cellC, cellA, cellB)
					if (ComboExplorer.shouldStop()) break
					ComboExplorer.tryTripletOrder(cellC, cellB, cellA)
				}
			}
		}

		Benchmark.stop("ComboExplorer.phaseThreeCell")
	}

	/*
	 * Try a specific triplet ordering: first -> second -> third
	 */
	static void tryTripletOrder(Cell first, Cell second, Cell third) {
		Combo? combo = ComboBuilder.buildAcrossCells([first, second, third], true)
		if (combo == null) return;

		string name = "P3:" + first.id + "->" + second.id + "->" + third.id
		ComboExplorer.recordResult(ExplorerResult(combo!, name, "3"))
	}

	// ════════════════════════════════════════════════════════════
	// LOGGING
	// ════════════════════════════════════════════════════════════

	static void logResults() {
		// Sort top results
		ComboExplorer.topResults = arraySort(ComboExplorer.topResults, (ExplorerResult a, ExplorerResult b) => integer|real {
			return Sort.desc(a.score, b.score)
		}) as Array<ExplorerResult>

		// Log top 5 to Benchmark
		integer logged = 0
		for (ExplorerResult r in ComboExplorer.topResults) {
			if (logged >= ExplorerConfig.MAX_RESULTS_KEPT) break

			string desc = "EXP[" + r.name + "]:" + ComboExplorer.buildComboDesc(r.combo)
			real posScore = r.combo.finalPosition != null ? r.combo.finalPosition!.score : 0.0
			real actionScore = r.score - posScore
			Benchmark.addCombo(r.score, count(r.combo.actions), desc, posScore, actionScore)
			logged++
		}

		// Log summary
		debug("ComboExplorer: " + ComboExplorer.combosEvaluated + " combos, best=" +
			(ComboExplorer.bestResult != null ? ComboExplorer.bestResult!.name : "none") +
			" score=" + (ComboExplorer.bestResult != null ? round(ComboExplorer.bestResult!.score) : 0))
	}

	/*
	 * Build description string for a combo
	 */
	static string buildComboDesc(Combo combo) {
		string desc = ""
		for (Action a in combo.actions) {
			if (desc != "") desc += "->"
			desc += a.item.name + "(" + round(a.score!) + ")"
		}
		if (combo.finalPosition != null) {
			if (desc != "") desc += "->"
			desc += "mv(" + combo.finalPosition!.cell.id + ")"
		}
		if (desc == "") desc = "stay"
		return desc
	}
}
