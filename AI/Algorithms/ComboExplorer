/*
 * ComboExplorer - Multi-phase combo exploration algorithm
 *
 * Explores action combinations across multiple cells to find optimal combos.
 * Uses precomputed actions from MapAction (no duplication).
 *
 * Phases (in order):
 * - Phase 0: Stay in place (cheap baseline, 0 MP offense)
 * - Phase T: Target focus
 *   - Each non-bulb enemy: prefix enumeration (Liberation × Str buffs × MP levels)
 *   - Each non-bulb ally (canDie): 2 variants (MPBuff)
 * - Phase 1a: Single-cell MP sampling (1..maxMP, no buffs needed)
 * - Phase 1b: Extended range cells (maxMP+1..maxMP+maxMPBuff, with minimal buffs)
 * - Phase 2: Multi-cell pairs (top K cells, both orderings, minimal buffs if needed)
 * - Phase 3: Three-cell combos (top K cells, all 6 orderings, minimal buffs if needed)
 *
 * Key principles:
 * - Action SELECTION by knapsack (optimal TP allocation)
 * - Action ORDERING by priority (for execution)
 * - Greedy FALLBACK after kills (fill remaining TP)
 * - Proper consequence chaining
 * - Weapon switch costs handled in Consequences
 * - Operation budget checked after each combo
 * - MP buffs: stacked minimally to reach extended cells (minimize TP spent)
 */

// ════════════════════════════════════════════════════════════════
// CONFIGURATION
// ════════════════════════════════════════════════════════════════

class ExplorerConfig {
	// Top K cells for multi-cell exploration phases
	// Complexity: O(K^2) for pairs, O(K^3 x 6) for triplets
	static integer INTERESTING_CELLS_K_PHASE2 = 15
	static integer INTERESTING_CELLS_K_PHASE3 = 10
	// Operation buffer: dynamic for main leek (base + per bulb + potential summon), fixed for bulbs
	static integer OPERATION_BUFFER_LEEK_BASE = 400000
	static integer OPERATION_BUFFER_BULB_RESERVE = 200000   // Leek reserves this per existing bulb
	static integer OPERATION_BUFFER_SUMMON_RESERVE = 200000 // Leek reserves this if can summon
	static integer OPERATION_BUFFER_BULB_SELF = 200000      // Buffer when bulb itself explores
	static integer MAX_RESULTS_KEPT = 5
}

// ════════════════════════════════════════════════════════════════
// EXPLORATION CONTEXT
// Holds per-exploration state: initial resources, results, operation control
// ════════════════════════════════════════════════════════════════

class ExplorationContext {
	// Initial resources (snapshot at exploration start)
	integer initialTP
	integer initialMP
	Item? initialWeapon
	integer maxMPBuff

	// Reachability maps (snapshot at exploration start)
	Map<Cell, integer> reachableCells
	Map<Cell, integer> extendedReachableCells
	Set<Cell> cellsToIgnore

	// Results tracking
	Array<ExplorerResult> topResults
	ExplorerResult? bestResult
	integer combosEvaluated
	string bestPhase

	// Operation control
	integer operationBuffer

	/*
	 * Create fresh context from current Fight.self state
	 */
	constructor() {
		// Snapshot initial resources
		this.initialTP = Fight.self.tp
		this.initialMP = Fight.self.mp
		this.initialWeapon = Fight.self.getWeaponInHand()
		this.maxMPBuff = Fight.self.maxMPBuff

		// Snapshot reachability
		this.reachableCells = Fight.self.reachableCells
		this.extendedReachableCells = Fight.self.extendedReachableCells
		this.cellsToIgnore = clone(Fight.self.cellsToIgnore) as Set<Cell>

		// Initialize results
		this.topResults = []
		this.bestResult = null
		this.combosEvaluated = 0
		this.bestPhase = ""

		// Calculate operation buffer based on entity type
		if (Fight.self.isBulb) {
			this.operationBuffer = ExplorerConfig.OPERATION_BUFFER_BULB_SELF
		} else {
			integer bulbCount = count(getSummons())
			this.operationBuffer = ExplorerConfig.OPERATION_BUFFER_LEEK_BASE
				+ bulbCount * ExplorerConfig.OPERATION_BUFFER_BULB_RESERVE
			if (Fight.canSummon) {
				this.operationBuffer += ExplorerConfig.OPERATION_BUFFER_SUMMON_RESERVE
			}
		}
	}

	/*
	 * Check if we should stop (operation budget exhausted)
	 */
	boolean shouldStop() {
		return getOperations() > getMaxOperations() - this.operationBuffer
	}

	/*
	 * Record a result and update best if needed
	 */
	void recordResult(ExplorerResult result) {
		this.combosEvaluated++

		// Update best
		if (this.bestResult == null || result.score > this.bestResult!.score) {
			this.bestResult = result
			this.bestPhase = result.phase
		}

		// Keep top N results
		push(this.topResults, result)
		if (count(this.topResults) > ExplorerConfig.MAX_RESULTS_KEPT) {
			// Sort and trim
			this.topResults = arraySort(this.topResults, (ExplorerResult a, ExplorerResult b) => integer|real {
				return Sort.desc(a.score, b.score)
			}) as Array<ExplorerResult>
			this.topResults = arraySlice(this.topResults, 0, ExplorerConfig.MAX_RESULTS_KEPT) as Array<ExplorerResult>
		}
	}
}

// ════════════════════════════════════════════════════════════════
// RESULT WRAPPER
// ════════════════════════════════════════════════════════════════

class ExplorerResult {
	Combo combo
	string name      // e.g., "T:Kill_Goblin", "P0:Stay", "P2:A->B"
	string phase     // "T", "0", "1", "2", "3"
	real score

	constructor(Combo combo, string name, string phase) {
		this.combo = combo
		this.name = name
		this.phase = phase
		this.score = combo.getScore()!
	}

	string string() {
		return "<ExplorerResult " + this.name + " score:" + round(this.score) + ">"
	}
}

// ════════════════════════════════════════════════════════════════
// MAIN EXPLORER
// ════════════════════════════════════════════════════════════════

class ComboExplorer {
	// Current exploration context (set during explore())
	static ExplorationContext? ctx = null

	/*
	 * Main entry point
	 */
	static Combo explore() {
		Benchmark.start("ComboExplorer.explore")

		// Create fresh context for this exploration
		ExplorationContext ctx = ExplorationContext()
		ComboExplorer.ctx = ctx

		// Phase 0: Stay in place - ALWAYS runs (cheap baseline, guaranteed result)
		ComboExplorer.phaseStay(ctx)

		// Phase T: Target Focus
		if (!ctx.shouldStop()) {
			ComboExplorer.phaseTargetFocus(ctx)
		}

		// Phase I: Inversion strategies
		if (!ctx.shouldStop()) {
			ComboExplorer.phaseInversion(ctx)
		}

		// Debug best inversion combo
		ExplorerResult? bestInv = null
		for (ExplorerResult r in ctx.topResults) {
			if (r.phase == "I" && (bestInv == null || r.score > bestInv!.score)) {
				bestInv = r
			}
		}
		if (bestInv != null) {
			debug("PhaseI best: " + bestInv!.name + " score=" + round(bestInv!.score) + " " + bestInv!.combo)
		}

		// Phase R: Repotting strategies (swap with allied bulbs)
		if (!ctx.shouldStop()) {
			ComboExplorer.phaseRepotting(ctx)
		}

		// Phase A: Simple attract (grapple only)
		if (!ctx.shouldStop()) {
			ComboExplorer.phaseAttract(ctx)
		}

		// Phase P: Simple push (boxing glove only)
		if (!ctx.shouldStop()) {
			ComboExplorer.phasePush(ctx)
		}

		// Phase AP: Attract-Push combos (grapple + boxing glove)
		if (!ctx.shouldStop()) {
			ComboExplorer.phaseAttractPush(ctx)
		}

		// Phase PIP: Pull-Inversion-Push combos (grapple + inversion + boxing glove)
		if (!ctx.shouldStop()) {
			ComboExplorer.phasePullInvPush(ctx)
		}

		// Phase 1: Single-cell MP sampling
		if (!ctx.shouldStop()) {
			ComboExplorer.phaseSingleCell(ctx)
		}

		// Phase 2: Multi-cell pairs
		if (!ctx.shouldStop()) {
			ComboExplorer.phaseMultiCell(ctx)
		}

		// Phase 3: Three-cell combos
		if (!ctx.shouldStop()) {
			ComboExplorer.phaseThreeCell(ctx)
		}

		// NOTE: Summon buff exploration is now handled dynamically in ComboBuilder
		// via _expandWithBulbBuffs() after any summon action is added to a combo.

		// Log results
		ComboExplorer.logResults(ctx)

		Benchmark.stop("ComboExplorer.explore")

		// Return best combo (guaranteed from Phase 0)
		return ctx.bestResult!.combo
	}

	// ════════════════════════════════════════════════════════════
	// PHASE T: TARGET FOCUS
	// ════════════════════════════════════════════════════════════

	static void phaseTargetFocus(ExplorationContext ctx) {
		Benchmark.start("ComboExplorer.phaseTargetFocus")

		// Pre-collect str buff options once (shared across all enemies)
		Array<Action> strBuffOptions = ComboBuilder._collectStrBuffOptions(ctx.initialTP)

		// === ENEMIES ===
		for (Entity enemy in Fight.getEnemiesAlive()) {
			if (ctx.shouldStop()) break
			if (enemy.isBulb || enemy.isInvincible || BossFennel.shouldNotTarget(enemy)) continue
			ComboExplorer._exploreTargetEnemy(ctx, enemy, strBuffOptions)
		}

		// === ALLIES: canDie OR low lifeRatio (including poison) ===
		boolean hasMPBuff = ctx.maxMPBuff > 0
		for (Entity ally in Fight.getAlliesAlive()) {
			if (ctx.shouldStop()) break
			if (ally == Fight.self || ally.isBulb) continue
			// Include if canDie OR lifeRatio (with poison) < 50%
			if (!ally.canDie && ally.psnlife * 2 >= ally.totalLife) continue

			ComboExplorer.trySupportAlly(ctx, ally, "T:Help_" + ally.name, false)
			if (hasMPBuff) {
				if (ctx.shouldStop()) break
				ComboExplorer.trySupportAlly(ctx, ally, "T:Help_" + ally.name + "+B", true)
			}
		}

		Benchmark.stop("ComboExplorer.phaseTargetFocus")
	}

	/*
	 * Try to support a specific ally using ComboBuilder
	 */
	static void trySupportAlly(ExplorationContext ctx, Entity ally, string name, boolean useMPBuff) {
		Combo? combo = ComboBuilder.buildForAlly(ctx, ally, useMPBuff)
		if (combo == null) return;

		if (count(combo!.actions) > 0 || combo!.finalPosition!.score > 0) {
			ctx.recordResult(ExplorerResult(combo!, name, "T"))
		}
	}

	/*
	 * Explore all prefix combinations for a single enemy target.
	 * Enumerates: lib(0..1) × str(0..N) × mp(useful levels)
	 */
	static void _exploreTargetEnemy(ExplorationContext ctx, Entity enemy, Array<Action> strBuffOptions) {
		Array<Action> damageActions = MapCellScore.getActionsDamagingTarget(enemy)
		if (count(damageActions) == 0) return;

		// Check if we have damage-type actions (str/lib only help EFFECT_DAMAGE, not poison)
		boolean hasDamageType = false
		for (Action a in damageActions) {
			if (a.item.isDamage) {
				hasDamageType = true
				break
			}
		}

		// Liberation option: only if target has shields and we have damage-type actions
		boolean canLib = Fight.liberationReady && Fight.liberationItem != null
			&& hasDamageType && (enemy.absShield > 0 || enemy.relShield > 0)

		// Str buff options: only if we have damage-type actions
		Array<Action> strOptions = hasDamageType ? strBuffOptions : []
		integer strCount = count(strOptions)

		// MP levels: [0] + distinct distances beyond baseMP where damage actions exist
		Array<integer> mpLevels = ComboExplorer._computeUsefulMPLevels(ctx, damageActions)

		// Enumerate: lib(0..1) × str(0..strCount) × mp(each level)
		integer maxLib = canLib ? 1 : 0
		for (integer useLib = 0; useLib <= maxLib; useLib++) {
			for (integer strLevel = 0; strLevel <= strCount; strLevel++) {
				// Build str prefix and track TP
				Array<Action> strPrefixes = []
				integer prefixTP = 0
				boolean affordable = true

				if (useLib == 1) {
					prefixTP += Fight.liberationItem!.cost
				}

				for (integer i = 0; i < strLevel; i++) {
					if (prefixTP + strOptions[i].item.cost >= ctx.initialTP) {
						affordable = false
						break
					}
					push(strPrefixes, strOptions[i])
					prefixTP += strOptions[i].item.cost
				}
				if (!affordable) break  // higher strLevels even more expensive

				for (integer mpIdx = 0; mpIdx < count(mpLevels); mpIdx++) {
					if (ctx.shouldStop()) return;
					integer mpDist = mpLevels[mpIdx]

					// Calculate MP buffs for this level
					Array<Action> mpBuffs = []
					integer mpBuffTP = 0
					if (mpDist > ctx.initialMP) {
						Array<Action>? buffs = ComboBuilder._calculateMPBuffs(
							mpDist - ctx.initialMP, ctx.initialTP - prefixTP)
						if (buffs == null) continue
						mpBuffs = buffs!
						for (Action b in mpBuffs) {
							mpBuffTP += b.item.cost
						}
					}

					// Check minimum remaining TP for damage
					if (ctx.initialTP - prefixTP - mpBuffTP < 2) continue

					// Filter damage pool by reach at this MP level
					integer effectiveMP = mpDist == 0 ? ctx.initialMP : mpDist
					Array<Action> reachablePool = ComboBuilder._filterByReachDistance(
						ctx, damageActions, effectiveMP)
					if (count(reachablePool) == 0 && useLib == 0 && strLevel == 0) continue

					// Build combo
					Combo? combo = ComboBuilder.buildForTargetPrefixed(
						ctx, enemy, reachablePool, useLib == 1, strPrefixes, mpBuffs)
					if (combo != null && (count(combo!.actions) > 0 || combo!.finalPosition!.score > 0)) {
						string name = "T:" + enemy.name
							+ (useLib == 1 ? "+L" : "")
							+ (strLevel > 0 ? "+S" + strLevel : "")
							+ (mpDist > ctx.initialMP ? "+M" + (mpDist - ctx.initialMP) : "")
						ctx.recordResult(ExplorerResult(combo!, name, "T"))
					}
				}
			}
		}
	}

	/*
	 * Compute useful MP levels for target exploration.
	 * Returns [0] + distinct distances beyond baseMP where damage actions exist.
	 * Sorted ascending so we try cheaper buffs first.
	 */
	static Array<integer> _computeUsefulMPLevels(ExplorationContext ctx, Array<Action> actions) {
		// Always include 0 (= use baseMP, no buff)
		Array<integer> levels = [0]
		Map<integer, boolean> seen = [:]

		for (Action a in actions) {
			if (a.from == Fight.selfCell) continue
			integer? dist = ctx.extendedReachableCells[a.from]
			if (dist != null && dist! > ctx.initialMP && !seen[dist!]) {
				push(levels, dist!)
				seen[dist!] = true
			}
		}

		// Sort ascending so we try cheaper buffs first
		if (count(levels) > 1) {
			levels = arraySort(levels, (integer a, integer b) => integer|real {
				return Sort.asc(a, b)
			}) as Array<integer>
		}

		return levels
	}

	// ════════════════════════════════════════════════════════════
	// PHASE I: INVERSION STRATEGIES
	// ════════════════════════════════════════════════════════════

	/*
	 * Explore inversion as a first-class strategy.
	 * Tries all inversion candidates, letting the scoring decide.
	 */
	static void phaseInversion(ExplorationContext ctx) {
		if (!Fight.inversionReady || Fight.inversionItem == null) return;

		Benchmark.start("ComboExplorer.phaseInversion")
		integer startOps = getOperations()

		// Consider all inversion candidates, let the scoring decide
		integer explored = 0
		for (MovementCandidate candidate in MapTactical.getInversionCandidates()) {
			if (ctx.shouldStop()) break
			explored++

			Combo? combo = ComboBuilder.buildWithInversion(ctx, candidate)
			if (combo != null && count(combo!.actions) > 0) {
				string tag = candidate.target.isFriend ? "Ally" : "Enemy"
				ctx.recordResult(ExplorerResult(combo!, "I:" + tag + "_" + candidate.target.name, "I"))
			}
		}
		debug("PhaseI: " + explored + "/" + count(MapTactical.getInversionCandidates()) + " candidates, cost=" + Benchmark.format(getOperations() - startOps))

		Benchmark.stop("ComboExplorer.phaseInversion")
	}

	/*
	 * Explore repotting (swap with allied bulb) as a strategy.
	 * Similar to phaseInversion but for bulb swaps only.
	 */
	static void phaseRepotting(ExplorationContext ctx) {
		if (!Fight.repottingReady || Fight.repottingItem == null) return;

		Benchmark.start("ComboExplorer.phaseRepotting")
		integer startOps = getOperations()

		integer explored = 0
		for (MovementCandidate candidate in MapTactical.getRepottingCandidates()) {
			if (ctx.shouldStop()) break
			explored++

			Combo? combo = ComboBuilder.buildWithRepotting(ctx, candidate)
			if (combo != null && count(combo!.actions) > 0) {
				ctx.recordResult(ExplorerResult(combo!, "R:" + candidate.target.name, "R"))
			}
		}
		debug("PhaseR: " + explored + "/" + count(MapTactical.getRepottingCandidates()) + " candidates, cost=" + Benchmark.format(getOperations() - startOps))

		Benchmark.stop("ComboExplorer.phaseRepotting")
	}

	// ════════════════════════════════════════════════════════════
	// PHASE A: SIMPLE ATTRACT (GRAPPLE)
	// ════════════════════════════════════════════════════════════

	/*
	 * Explore simple attract (grapple only) as a strategy.
	 * Pulls target toward us, then fills with post-attract actions.
	 */
	static void phaseAttract(ExplorationContext ctx) {
		if (!Fight.grappleReady || Fight.grappleItem == null) return;

		Benchmark.start("ComboExplorer.phaseAttract")
		integer startOps = getOperations()

		integer explored = 0
		Combo? bestCombo = null
		string bestName = ""
		for (MovementCandidate candidate in MapTactical.getGrappleCandidates()) {
			if (ctx.shouldStop()) break
			explored++

			Combo? combo = ComboBuilder.buildWithAttract(ctx, candidate)
			if (combo != null && count(combo!.actions) > 0) {
				string name = "A:" + candidate.target.name
				ctx.recordResult(ExplorerResult(combo!, name, "A"))
				if (bestCombo == null || combo!.getScore()! > bestCombo!.getScore()!) {
					bestCombo = combo
					bestName = name
				}
			}
		}
		debug("PhaseA: " + explored + "/" + count(MapTactical.getGrappleCandidates()) + " candidates, cost=" + Benchmark.format(getOperations() - startOps))
		if (bestCombo != null) {
			debug("PhaseA best: " + bestName + " score=" + round(bestCombo!.getScore()!) + " " + bestCombo!)
		}

		Benchmark.stop("ComboExplorer.phaseAttract")
	}

	// ════════════════════════════════════════════════════════════
	// PHASE P: SIMPLE PUSH (BOXING GLOVE)
	// ════════════════════════════════════════════════════════════

	/*
	 * Explore simple push (boxing glove only) as a strategy.
	 * Pushes target away from us, then fills with post-push actions.
	 */
	static void phasePush(ExplorationContext ctx) {
		if (!Fight.boxingGloveReady || Fight.boxingGloveItem == null) return;

		Benchmark.start("ComboExplorer.phasePush")
		integer startOps = getOperations()

		integer explored = 0
		Combo? bestCombo = null
		string bestName = ""
		for (MovementCandidate candidate in MapTactical.getBoxingGloveCandidates()) {
			if (ctx.shouldStop()) break
			explored++

			Combo? combo = ComboBuilder.buildWithPush(ctx, candidate)
			if (combo != null && count(combo!.actions) > 0) {
				string name = "P:" + candidate.target.name
				ctx.recordResult(ExplorerResult(combo!, name, "P"))
				if (bestCombo == null || combo!.getScore()! > bestCombo!.getScore()!) {
					bestCombo = combo
					bestName = name
				}
			}
		}
		debug("PhaseP: " + explored + "/" + count(MapTactical.getBoxingGloveCandidates()) + " candidates, cost=" + Benchmark.format(getOperations() - startOps))
		if (bestCombo != null) {
			debug("PhaseP best: " + bestName + " score=" + round(bestCombo!.getScore()!) + " " + bestCombo!)
		}

		Benchmark.stop("ComboExplorer.phasePush")
	}

	// ════════════════════════════════════════════════════════════
	// PHASE AP: ATTRACT-PUSH COMBOS
	// ════════════════════════════════════════════════════════════

	/*
	 * Explore attract-push combos (grapple + boxing glove).
	 * Pulls enemy toward ally barycenter, then pushes further in same direction.
	 * Supports both 90° (L-shape) and same-direction approaches.
	 */
	static void phaseAttractPush(ExplorationContext ctx) {
		if (!Fight.grappleReady || !Fight.boxingGloveReady) return;
		if (Fight.grappleItem == null || Fight.boxingGloveItem == null) return;

		Benchmark.start("ComboExplorer.phaseAttractPush")
		integer startOps = getOperations()

		integer explored = 0
		Combo? bestCombo = null
		string bestName = ""
		for (AttractPushCandidate candidate in MapTactical.getAttractPushCombos()) {
			if (ctx.shouldStop()) break
			explored++

			Combo? combo = ComboBuilder.buildWithAttractPush(ctx, candidate)
			if (combo != null && count(combo!.actions) > 0) {
				string name = "AP:" + candidate.target.name
				ctx.recordResult(ExplorerResult(combo!, name, "AP"))
				if (bestCombo == null || combo!.getScore()! > bestCombo!.getScore()!) {
					bestCombo = combo
					bestName = name
				}
			}
		}
		debug("PhaseAP: " + explored + "/" + count(MapTactical.getAttractPushCombos()) + " candidates, cost=" + Benchmark.format(getOperations() - startOps))
		if (bestCombo != null) {
			debug("PhaseAP best: " + bestName + " score=" + round(bestCombo!.getScore()!) + " " + bestCombo!)
		}

		Benchmark.stop("ComboExplorer.phaseAttractPush")
	}

	// ════════════════════════════════════════════════════════════
	// PHASE PIP: PULL-INVERSION-PUSH COMBOS
	// ════════════════════════════════════════════════════════════

	/*
	 * Explore pull-inversion-push combos (grapple + inversion + boxing glove).
	 * Maximum enemy displacement: pull, swap to get behind, push further.
	 */
	static void phasePullInvPush(ExplorationContext ctx) {
		if (!Fight.grappleReady || !Fight.inversionReady || !Fight.boxingGloveReady) return;
		if (Fight.grappleItem == null || Fight.inversionItem == null || Fight.boxingGloveItem == null) return;

		Benchmark.start("ComboExplorer.phasePullInvPush")
		integer startOps = getOperations()

		integer explored = 0
		Combo? bestCombo = null
		string bestName = ""
		for (PullInversionPushCandidate candidate in MapTactical.getPullInversionPushCombos()) {
			if (ctx.shouldStop()) break
			explored++

			Combo? combo = ComboBuilder.buildWithPullInvPush(ctx, candidate)
			if (combo != null && count(combo!.actions) > 0) {
				string name = "PIP:" + candidate.target.name
				ctx.recordResult(ExplorerResult(combo!, name, "PIP"))
				if (bestCombo == null || combo!.getScore()! > bestCombo!.getScore()!) {
					bestCombo = combo
					bestName = name
				}
			}
		}
		debug("PhasePIP: " + explored + "/" + count(MapTactical.getPullInversionPushCombos()) + " candidates, cost=" + Benchmark.format(getOperations() - startOps))
		if (bestCombo != null) {
			debug("PhasePIP best: " + bestName + " score=" + round(bestCombo!.getScore()!) + " " + bestCombo!)
		}

		Benchmark.stop("ComboExplorer.phasePullInvPush")
	}

	// ════════════════════════════════════════════════════════════
	// PHASE 0: STAY IN PLACE
	// ════════════════════════════════════════════════════════════

	static void phaseStay(ExplorationContext ctx) {
		Benchmark.start("ComboExplorer.phaseStay")

		Combo combo = ComboBuilder.buildAtCell(ctx, Fight.self.cell, 0)
		ctx.recordResult(ExplorerResult(combo, "P0:Stay", "0"))

		Benchmark.stop("ComboExplorer.phaseStay")
	}

	// ════════════════════════════════════════════════════════════
	// PHASE 1: SINGLE-CELL MP SAMPLING
	// ════════════════════════════════════════════════════════════

	static void phaseSingleCell(ExplorationContext ctx) {
		Benchmark.start("ComboExplorer.phaseSingleCell")

		integer maxMP = ctx.initialMP
		integer maxMPBuff = ctx.maxMPBuff

		// Phase 1a: Current MP range (no buffs needed)
		for (integer offenseMP = 1; offenseMP <= maxMP; offenseMP++) {
			if (ctx.shouldStop()) break

			// Find best cell at exactly this distance (each iteration explores a new ring)
			Cell? bestCell = ComboExplorer.findBestCellAtDistance(ctx, offenseMP)
			if (bestCell == null) continue

			// Reserve (maxMP - offenseMP) for defense
			integer reserveMP = maxMP - offenseMP
			Combo combo = ComboBuilder.buildAtCell(ctx, bestCell!, reserveMP)
			ctx.recordResult(ExplorerResult(combo, "P1:MP" + offenseMP, "1"))
		}

		// Phase 1b: Extended range (requires MP buffs)
		if (maxMPBuff > 0) {
			integer maxExtended = maxMP + maxMPBuff

			for (integer offenseMP = maxMP + 1; offenseMP <= maxExtended; offenseMP++) {
				if (ctx.shouldStop()) break

				// Find best cell at this extended distance
				Cell? bestCell = ComboExplorer.findBestCellAtExtendedDistance(ctx, offenseMP)
				if (bestCell == null) continue

				// Build combo with auto MP buffs
				Combo? combo = ComboBuilder.buildAtCellBuffed(ctx, bestCell!, offenseMP)
				if (combo != null) {
					ctx.recordResult(ExplorerResult(combo!, "P1:MP" + offenseMP + "B", "1"))
				}
			}
		}

		Benchmark.stop("ComboExplorer.phaseSingleCell")
	}

	/*
	 * Find the best cell at exactly the given MP distance.
	 * Each offenseMP value explores a new "ring" of cells, avoiding redundant
	 * evaluation of closer cells already covered by smaller budgets.
	 */
	static Cell? findBestCellAtDistance(ExplorationContext ctx, integer distance) {
		Cell? best = null
		real bestScore = -999999.0

		Map<Cell, integer> reachable = ctx.reachableCells

		for (Cell cell : real score in MapCellScore.cellScores) {
			integer? dist = reachable[cell]
			if (dist == null || dist! != distance) continue  // exact match only

			if (score > bestScore) {
				bestScore = score
				best = cell
			}
		}

		return best
	}

	/*
	 * Find the best cell at exactly the given extended distance.
	 * Used for cells beyond current MP that require MP buffs to reach.
	 * Only considers cells in the extended range (distance > currentMP).
	 */
	static Cell? findBestCellAtExtendedDistance(ExplorationContext ctx, integer distance) {
		Cell? best = null
		real bestScore = -999999.0

		Map<Cell, integer> reachable = ctx.extendedReachableCells

		for (Cell cell : real score in MapCellScore.cellScores) {
			integer? dist = reachable[cell]
			if (dist == null || dist! != distance) continue  // exact match only

			if (score > bestScore) {
				bestScore = score
				best = cell
			}
		}

		return best
	}

	// ════════════════════════════════════════════════════════════
	// PHASE 2: MULTI-CELL PAIRS
	// ════════════════════════════════════════════════════════════

	static void phaseMultiCell(ExplorationContext ctx) {
		Benchmark.start("ComboExplorer.phaseMultiCell")

		Array<Cell> interesting = MapCellScore.interestingCells
		integer n = count(interesting)

		// Try all pairs
		for (integer i = 0; i < n; i++) {
			if (ctx.shouldStop()) break

			for (integer j = i + 1; j < n; j++) {
				if (ctx.shouldStop()) break

				Cell cellA = interesting[i]
				Cell cellB = interesting[j]

				// Try both orderings
				ComboExplorer.tryPairOrder(ctx, cellA, cellB)
				if (ctx.shouldStop()) break
				ComboExplorer.tryPairOrder(ctx, cellB, cellA)
			}
		}

		Benchmark.stop("ComboExplorer.phaseMultiCell")
	}

	/*
	 * Try a specific pair ordering: first -> second
	 */
	static void tryPairOrder(ExplorationContext ctx, Cell first, Cell second) {
		Combo? combo = ComboBuilder.buildAcrossCells(ctx, [first, second], true)
		if (combo == null) return;

		string name = "P2:" + first.id + "->" + second.id
		ctx.recordResult(ExplorerResult(combo!, name, "2"))
	}

	// ════════════════════════════════════════════════════════════
	// PHASE 3: THREE-CELL COMBOS
	// ════════════════════════════════════════════════════════════

	static void phaseThreeCell(ExplorationContext ctx) {
		Benchmark.start("ComboExplorer.phaseThreeCell")

		Array<Cell> interesting = MapCellScore.interestingCells
		integer n = min(ExplorerConfig.INTERESTING_CELLS_K_PHASE3, count(interesting))

		// Try all triplets with all 6 orderings
		for (integer i = 0; i < n; i++) {
			if (ctx.shouldStop()) break
			for (integer j = i + 1; j < n; j++) {
				if (ctx.shouldStop()) break
				for (integer k = j + 1; k < n; k++) {
					if (ctx.shouldStop()) break

					Cell cellA = interesting[i]
					Cell cellB = interesting[j]
					Cell cellC = interesting[k]

					// Try all 6 orderings
					ComboExplorer.tryTripletOrder(ctx, cellA, cellB, cellC)
					if (ctx.shouldStop()) break
					ComboExplorer.tryTripletOrder(ctx, cellA, cellC, cellB)
					if (ctx.shouldStop()) break
					ComboExplorer.tryTripletOrder(ctx, cellB, cellA, cellC)
					if (ctx.shouldStop()) break
					ComboExplorer.tryTripletOrder(ctx, cellB, cellC, cellA)
					if (ctx.shouldStop()) break
					ComboExplorer.tryTripletOrder(ctx, cellC, cellA, cellB)
					if (ctx.shouldStop()) break
					ComboExplorer.tryTripletOrder(ctx, cellC, cellB, cellA)
				}
			}
		}

		Benchmark.stop("ComboExplorer.phaseThreeCell")
	}

	/*
	 * Try a specific triplet ordering: first -> second -> third
	 */
	static void tryTripletOrder(ExplorationContext ctx, Cell first, Cell second, Cell third) {
		Combo? combo = ComboBuilder.buildAcrossCells(ctx, [first, second, third], true)
		if (combo == null) return;

		string name = "P3:" + first.id + "->" + second.id + "->" + third.id
		ctx.recordResult(ExplorerResult(combo!, name, "3"))
	}

	// ════════════════════════════════════════════════════════════
	// LOGGING
	// ════════════════════════════════════════════════════════════

	static void logResults(ExplorationContext ctx) {
		// Sort top results
		ctx.topResults = arraySort(ctx.topResults, (ExplorerResult a, ExplorerResult b) => integer|real {
			return Sort.desc(a.score, b.score)
		}) as Array<ExplorerResult>

		// Log top 5 to Benchmark
		integer logged = 0
		for (ExplorerResult r in ctx.topResults) {
			if (logged >= ExplorerConfig.MAX_RESULTS_KEPT) break

			string desc = "EXP[" + r.name + "]:" + r.combo.describe()
			real posScore = r.combo.finalPosition != null ? r.combo.finalPosition!.score : 0.0
			real actionScore = r.score - posScore
			Benchmark.addCombo(r.score, count(r.combo.actions), desc, posScore, actionScore)
			logged++
		}

		// Log summary
		debug("ComboExplorer: " + ctx.combosEvaluated + " combos, best=" +
			(ctx.bestResult != null ? ctx.bestResult!.name : "none") +
			" score=" + (ctx.bestResult != null ? round(ctx.bestResult!.score) : 0) +
			(ctx.bestResult != null ? " " + ctx.bestResult!.combo : ""))
	}

}
