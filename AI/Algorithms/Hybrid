/*
 * Hybrid - Cell iteration wrappers for MCTS and BeamSearch
 *
 * Runs MCTS or BeamSearch over all reachable cells and returns the best combo.
 */
class Hybrid {

	/*
	 * Run pure MCTS on all reachable cells.
	 */
	static Combo runMCTSFull() {
		Benchmark.start("Hybrid.runMCTSFull")

		Map<Cell, Map<Item, Action>> mapBestAction = MapAction.getMapBestAction()
		Combo? bestCombo = null
		integer positionsExplored = 0

		for (Cell cell : integer mp in Fight.self.reachableCells) {
			// Always process current cell (mp=0), even if Fight.self.mp is 0 or negative (shackled)
			if (mp > 0 && mp > Fight.self.mp) break

			if (MCTS.shouldStop() && bestCombo != null) {
				debug("MCTS: Budget low, " + positionsExplored + " pos explored")
				break
			}

			positionsExplored++

			Map<Item, Action> cellActions = mapBestAction[cell] ? clone(mapBestAction[cell]!, 1) as Map<Item, Action> : [:]

			if (mapBestAction[Fight.selfCell]) {
				for (Item item : Action action in mapBestAction[Fight.selfCell]!) {
					if (!cellActions[item] || action.score! > cellActions[item]!.score!) {
						cellActions[item] = action
					}
				}
			}

			Combo combo = MCTS.search(
				cell,
				cellActions,
				Fight.self.tp,
				max(0, Fight.self.mp - mp),
				Fight.self.getWeaponInHand()
			)

			if (!bestCombo || bestCombo!.getScore()! < combo.getScore()!) {
				bestCombo = combo
			}
		}

		Benchmark.stop("Hybrid.runMCTSFull")

		if (bestCombo == null) {
			debugE("MCTS: No combo found!")
			Combo emergency = Combo()
			emergency.addFinalPosition(MapPosition.findBestPosition(Fight.self.cell, Fight.self.mp, Consequences()))
			return emergency
		}

		Benchmark.setMCTS(MCTS.lastIterations, MCTS.lastNodesCreated, positionsExplored, bestCombo!.getScore()!)
		Benchmark.setChosen(bestCombo!.getScore()!, count(bestCombo!.actions), bestCombo!.describe())

		return bestCombo!
	}

	/*
	 * Run pure BeamSearch on all reachable cells.
	 */
	static Combo runBeamFull() {
		Benchmark.start("Hybrid.runBeamFull")

		Map<Cell, Map<Item, Action>> mapBestAction = MapAction.getMapBestAction()
		Combo? bestCombo = null
		integer positionsExplored = 0

		for (Cell cell : integer mp in Fight.self.reachableCells) {
			// Always process current cell (mp=0), even if Fight.self.mp is 0 or negative (shackled)
			if (mp > 0 && mp > Fight.self.mp) break

			if (BeamSearch.shouldStop() && bestCombo != null) {
				debug("Beam: Budget low, " + positionsExplored + " pos explored")
				break
			}

			positionsExplored++

			Map<Item, Action> cellActions = mapBestAction[cell] ? clone(mapBestAction[cell]!, 1) as Map<Item, Action> : [:]

			if (mapBestAction[Fight.selfCell]) {
				for (Item item : Action action in mapBestAction[Fight.selfCell]!) {
					if (!cellActions[item] || action.score! > cellActions[item]!.score!) {
						cellActions[item] = action
					}
				}
			}

			Combo combo = BeamSearch.search(
				cell,
				cellActions,
				Fight.self.tp,
				max(0, Fight.self.mp - mp),
				Fight.self.getWeaponInHand()
			)

			if (!bestCombo || bestCombo!.getScore()! < combo.getScore()!) {
				bestCombo = combo
			}
		}

		Benchmark.stop("Hybrid.runBeamFull")

		if (bestCombo == null) {
			debugE("Beam: No combo found!")
			Combo emergency = Combo()
			emergency.addFinalPosition(MapPosition.findBestPosition(Fight.self.cell, Fight.self.mp, Consequences()))
			return emergency
		}

		// BeamSearch.search() already calls Benchmark.setBeam() with detailed stats
		Benchmark.setChosen(bestCombo!.getScore()!, count(bestCombo!.actions), bestCombo!.describe())

		return bestCombo!
	}
}
