/*
 * PTS - Priority Target Simulation
 *
 * Alternative to MCTS that iterates TARGET-first instead of CELL-first.
 *
 * Algorithm:
 * 1. OPPORTUNITY GENERATION: For each (target, item) pair, compute attack cells and base score
 * 2. COMBO BUILDING: Greedy selection with proper consequence chaining
 * 3. FINAL POSITIONING: Find best end-of-turn position
 *
 * Key differences from MCTS:
 * - No tree search: single greedy pass through sorted opportunities
 * - No deep cloning: sequential consequence chaining (no branching)
 * - Scales with targets (~8) not cells (~50+)
 * - Much faster: O(targets × items) vs O(cells × items × MCTS_iterations)
 *
 * Can be used standalone or to SEED other algorithms with cell priorities.
 */
class PTS {
	// Statistics for debugging
	static integer lastOpportunities = 0
	static integer lastActionsBuilt = 0
	static real lastScore = 0.0

	// Cell scores from last opportunity generation
	// Used by Hybrid modes to prioritize cell order
	// Maps Cell → best opportunity score achievable from that cell
	static Map<Cell, real> lastCellScores = [:]

	/*
	 * Generate all opportunities: (target, item) pairs with valid attack cells.
	 * Considers ALL targets: enemies, allies, and self.
	 * Also populates lastCellScores for prioritization.
	 */
	static Array<Opportunity> generateOpportunities() {
		Benchmark.start("PTS.generateOpportunities")
		Array<Opportunity> opportunities = []
		PTS.lastCellScores = [:]  // Reset cell scores

		// Iterate all items
		for (Item item in Fight.self.items) {
			// Skip items on cooldown
			if (getCooldown(item.id, Fight.self.id) > 0) continue

			// Get valid targets for this item
			Map<integer, Entity> targets = item.targetSet()

			// For each target
			for (Entity target in targets) {
				// Skip invincible enemies
				if (target.isInvincible && !target.isFriend) continue

				// Generate opportunity based on item type
				Opportunity? opp = PTS.createOpportunity(item, target)
				if (opp != null) {
					push(opportunities, opp!)

					// Track cell scores: for each attack cell, record best opportunity score
					// Skip self-cast opportunities (Fight.selfCell is a sentinel, not a real cell)
					if (!opp!.isSelfCast) {
						for (Cell cell in opp!.attackCells) {
							real currentBest = PTS.lastCellScores[cell] != null ? PTS.lastCellScores[cell]! : 0.0
							if (opp!.baseScore > currentBest) {
								PTS.lastCellScores[cell] = opp!.baseScore
							}
						}
					}
				}
			}
		}

		PTS.lastOpportunities = count(opportunities)
		Benchmark.stop("PTS.generateOpportunities")
		return opportunities
	}

	/*
	 * Create an opportunity for a (item, target) pair.
	 * Computes attack cells and base score.
	 */
	static Opportunity? createOpportunity(Item item, Entity target) {
		// Self-cast case: item targets self with minRange 0
		if (target == Fight.self && item.minRange == 0) {
			// Create a temporary action to get base score
			Action tempAction = Action(item, Fight.selfCell, Fight.selfCell)
			if (tempAction.score! <= 0) return null
			return Opportunity(target, item, tempAction.score!)
		}

		// Can't target self with minRange > 0
		if (target == Fight.self) return null

		// Get cells from which we can hit this target
		Array<Cell> attackCells
		Cell targetCell = target.cell
		Map<Cell, Cell>? cellToAim = null  // For AOE: attackCell → aimCell

		if (item.area == AREA_POINT) {
			attackCells = Targets.getCellsToUseItemOnCell(item, target.cell, [Fight.self.id])
		} else if (item.area == AREA_LASER_LINE) {
			attackCells = Targets.getLazerCellsToUseItemOnCell(item, target.cell)
		} else {
			// AOE: check ALL cells in target's area
			cellToAim = [:]
			for (Cell aoeCell in target.cell.getAreaCells(item.area)) {
				Array<Cell> cells = Targets.getCellsToUseItemOnCell(item, aoeCell, [Fight.self.id])
				for (Cell c in cells) {
					if (cellToAim![c] == null) {
						cellToAim![c] = aoeCell
					} else if (aoeCell == target.cell) {
						cellToAim![c] = aoeCell
					} else {
						integer curDist = getCellDistance(cellToAim![c]!.id, target.cell.id)
						integer newDist = getCellDistance(aoeCell.id, target.cell.id)
						if (newDist < curDist) {
							cellToAim![c] = aoeCell
						}
					}
				}
			}
			attackCells = []
			for (Cell c in cellToAim!) {
				push(attackCells, c)
			}
		}

		if (count(attackCells) == 0) return null

		// Filter to reachable cells only
		Array<Cell> reachableAttackCells = []
		for (Cell cell in attackCells) {
			if (Fight.self.reachableCells[cell] != null) {
				push(reachableAttackCells, cell)
			}
		}

		if (count(reachableAttackCells) == 0) return null

		// Compute base score using closest reachable cell
		Cell? bestCell = null
		integer bestDist = 99999
		for (Cell cell in reachableAttackCells) {
			integer dist = Fight.self.reachableCells[cell]!
			if (dist < bestDist) {
				bestDist = dist
				bestCell = cell
			}
		}

		if (bestCell == null) return null

		Cell aimCell = (cellToAim != null && cellToAim![bestCell!] != null) ? cellToAim![bestCell!]! : targetCell
		Action tempAction = Action(item, bestCell!, aimCell)
		if (tempAction.score! <= 0) return null

		if (cellToAim != null) {
			return Opportunity(target, item, reachableAttackCells, targetCell, tempAction.score!, cellToAim!)
		} else {
			return Opportunity(target, item, reachableAttackCells, targetCell, tempAction.score!)
		}
	}

	/*
	 * Build a combo from opportunities using greedy selection with consequence chaining.
	 * This is the core PTS algorithm.
	 */
	static Combo buildCombo() {
		Benchmark.start("PTS.buildCombo")

		// Phase 1: Generate opportunities
		Array<Opportunity> opportunities = PTS.generateOpportunities()

		// If no opportunities, return movement-only combo
		if (count(opportunities) == 0) {
			Combo combo = Combo()
			combo.addFinalPosition(MapPosition.findBestPosition(Fight.self.cell, Fight.self.mp, Consequences()))
			PTS.lastActionsBuilt = 0
			PTS.lastScore = combo.getScore()!
			Benchmark.stop("PTS.buildCombo")
			return combo
		}

		// Phase 2: Sort opportunities (self-cast first, then by score descending)
		Array<Opportunity> selfCast = []
		Array<Opportunity> other = []
		for (Opportunity opp in opportunities) {
			if (opp.isSelfCast) push(selfCast, opp)
			else push(other, opp)
		}

		Array<Opportunity> sortedOther = arraySort(other, (Opportunity a, Opportunity b) => integer|real {
			return Sort.desc(a.baseScore, b.baseScore)
		}) as Array<Opportunity>

		Array<Opportunity> selfCastSorted = arraySort(selfCast, (Opportunity a, Opportunity b) => integer|real {
			return Sort.desc(a.baseScore, b.baseScore)
		}) as Array<Opportunity>

		Array<Opportunity> sorted = []
		for (Opportunity o in selfCastSorted) push(sorted, o)
		for (Opportunity o in sortedOther) push(sorted, o)

		// Phase 3: Greedy combo building with consequence chaining
		Combo combo = Combo()
		Cell currentCell = Fight.self.cell
		integer currentTP = Fight.self.tp
		integer currentMP = Fight.self.mp
		Item? weaponInHand = Fight.self.getWeaponInHand()
		Map<Item, integer> usesThisTurn = [:]
		Map<Item, integer> cooldowns = [:]
		Map<Cell, integer> reachableCells = Fight.self.reachableCells

		integer actionsBuilt = 0

		for (Opportunity opp in sorted) {
			Consequences currentCsq = combo.getCurrentConsequences()

			if (!opp.canExecute(currentTP, usesThisTurn, cooldowns, currentCsq, weaponInHand)) {
				continue
			}

			Cell? attackCell = opp.findBestReachableCell(currentCell, currentMP, reachableCells)
			if (attackCell == null) continue

			integer moveCost = 0
			if (!opp.isSelfCast && attackCell != currentCell) {
				integer? cost = reachableCells[attackCell!]
				if (cost == null) continue
				moveCost = cost!
			}

			if (moveCost > currentMP) continue

			Cell aimCell = opp.getAimCell(attackCell!)
			Action action = Action(opp.item, attackCell!, aimCell)

			if (actionsBuilt == 0) {
				if (action.score! <= 0) continue
				push(combo.actions, action)
			} else {
				if (!combo.add(action)) continue
			}

			Action addedAction = combo.actions[count(combo.actions) - 1]
			Consequences newCsq = addedAction.consequences
			currentTP = newCsq.currentTP
			currentMP = newCsq.currentMP
			currentCell = newCsq.currentCell

			if (opp.item.isWeap && opp.item != weaponInHand) {
				currentTP -= 1
				weaponInHand = opp.item
			}

			usesThisTurn[opp.item] = (usesThisTurn[opp.item] != null ? usesThisTurn[opp.item]! : 0) + 1
			if (opp.item.haveCD) {
				cooldowns[opp.item] = opp.item.cdDuration
			}

			if (!opp.isSelfCast && attackCell != Fight.selfCell) {
				reachableCells = MapPath.getCachedReachableCells(currentCell, currentMP, Fight.self.cellsToIgnore)
			}

			actionsBuilt++
		}

		// Phase 4: Final positioning
		Consequences finalCsq = combo.getCurrentConsequences()
		combo.addFinalPosition(MapPosition.findBestPosition(currentCell, currentMP, finalCsq))

		PTS.lastActionsBuilt = actionsBuilt
		PTS.lastScore = combo.getScore()!

		Benchmark.setPTS(PTS.lastOpportunities, actionsBuilt, PTS.lastScore)

		string comboDesc = PTS.buildComboDesc(combo)
		real posScore = combo.finalPosition != null ? combo.finalPosition!.score : 0
		Benchmark.addCombo(combo.getScore()!, actionsBuilt, "PTS:" + comboDesc, posScore, PTS.lastScore - posScore)

		Benchmark.stop("PTS.buildCombo")
		return combo
	}

	/*
	 * Get the primary cell used in a combo (for seeding other algorithms).
	 */
	static Cell getComboStartCell(Combo combo) {
		for (Action action in combo.actions) {
			if (action.from != Fight.selfCell) {
				return action.from
			}
		}
		return Fight.self.cell
	}

	/*
	 * Build combo description for debugging.
	 */
	static string buildComboDesc(Combo combo) {
		string desc = ""
		for (Action a in combo.actions) {
			if (desc != "") desc += "→"
			desc += a.item.name + "(" + round(a.score!) + ")"
		}
		if (combo.finalPosition) {
			if (desc != "") desc += "→"
			desc += "mv(" + combo.finalPosition!.cell.id + ")"
		}
		if (desc == "") desc = "stay"
		return desc
	}
}
