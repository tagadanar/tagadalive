/*
 * PTS - Priority Target Simulation
 *
 * Alternative to MCTS that iterates TARGET-first instead of CELL-first.
 *
 * Algorithm:
 * 1. OPPORTUNITY GENERATION: Uses MapOpportunity (pre-built during init)
 * 2. COMBO BUILDING: Greedy selection with proper consequence chaining
 * 3. FINAL POSITIONING: Find best end-of-turn position
 *
 * Key differences from MCTS:
 * - No tree search: single greedy pass through sorted opportunities
 * - No deep cloning: sequential consequence chaining (no branching)
 * - Scales with targets (~8) not cells (~50+)
 * - Much faster: O(targets × items) vs O(cells × items × MCTS_iterations)
 *
 * Can be used standalone or to SEED other algorithms with cell priorities.
 *
 * DUAL-MODE TESTING: Builds combo twice (MODE_CLOSEST + MODE_BEST_SCORE)
 * and returns the one with better final score (including position).
 * - MODE_CLOSEST: Minimize MP usage → more MP for retreat → better position
 * - MODE_BEST_SCORE: Maximize action score → more damage → less MP for position
 */
class PTS {
	// Statistics for debugging
	static integer lastOpportunities = 0
	static integer lastActionsBuilt = 0
	static real lastScore = 0.0
	static string lastWinningMode = ""  // "CLOSEST" or "BEST_SCORE"

	// Cell priority scores - references MapOpportunity.cellScores
	// Used by Hybrid modes to prioritize MCTS/Beam cell exploration order
	// Maps Cell → weighted sum of top-3 opportunity scores (1.0, 0.7, 0.4 weights)
	// Cells with multiple good opportunities rank higher than single-opportunity cells
	static Map<Cell, real> lastCellScores = [:]

	/*
	 * Build the best combo by testing both cell selection modes.
	 * Returns the combo with higher final score (actions + position).
	 */
	static Combo buildCombo() {
		Benchmark.start("PTS.buildCombo")

		// Build combo with MODE_CLOSEST (save MP for retreat)
		Combo comboClosest = PTS.buildComboWithMode(Opportunity.MODE_CLOSEST)
		real scoreClosest = comboClosest.getScore()!

		// Build combo with MODE_BEST_SCORE (maximize damage)
		Combo comboBest = PTS.buildComboWithMode(Opportunity.MODE_BEST_SCORE)
		real scoreBest = comboBest.getScore()!

		// Pick winner
		Combo winner
		if (scoreBest > scoreClosest) {
			winner = comboBest
			PTS.lastWinningMode = "BEST"
		} else {
			winner = comboClosest
			PTS.lastWinningMode = "CLOSE"
		}

		PTS.lastActionsBuilt = count(winner.actions)
		PTS.lastScore = winner.getScore()!

		// Log both scores for analysis
		Benchmark.setPTS(PTS.lastOpportunities, PTS.lastActionsBuilt, PTS.lastScore)
		string comboDesc = PTS.buildComboDesc(winner) + "[" + PTS.lastWinningMode + " C:" + round(scoreClosest) + " B:" + round(scoreBest) + "]"
		real posScore = winner.finalPosition != null ? winner.finalPosition!.score : 0
		Benchmark.addCombo(winner.getScore()!, PTS.lastActionsBuilt, "PTS:" + comboDesc, posScore, PTS.lastScore - posScore)

		Benchmark.stop("PTS.buildCombo")
		return winner
	}

	/*
	 * Build a combo using specified cell selection mode.
	 * @param cellMode: Opportunity.MODE_CLOSEST or Opportunity.MODE_BEST_SCORE
	 */
	static Combo buildComboWithMode(integer cellMode) {

		// Phase 1: Get pre-built opportunities from MapOpportunity
		Array<Opportunity> sorted = MapOpportunity.getSortedOpportunities()
		PTS.lastCellScores = MapOpportunity.cellScores  // Reference shared cell scores
		PTS.lastOpportunities = MapOpportunity.totalOpportunities

		// If no opportunities, return movement-only combo
		if (count(sorted) == 0) {
			Combo combo = Combo()
			combo.addFinalPosition(MapPosition.findBestPosition(Fight.self.cell, Fight.self.mp, Consequences()))
			return combo
		}

		// Phase 2: Greedy combo building with consequence chaining
		// NOTE: Sorting is now done in MapOpportunity.refresh() (self-cast first, then by score)
		Combo combo = Combo()
		Cell currentCell = Fight.self.cell
		integer currentMP = Fight.self.mp
		Map<Item, integer> usesThisTurn = [:]
		Map<Item, integer> cooldowns = [:]
		// Use fresh reachableCells computed from current position/MP (not stale Fight.self.reachableCells)
		Map<Cell, integer> reachableCells = MapPath.getCachedReachableCells(
			Fight.self.cell, Fight.self.mp, Fight.self.cellsToIgnore)

		integer actionsBuilt = 0

		// Outer loop: restart from top after each action to handle multiple uses
		boolean foundValidAction = true
		while (foundValidAction) {
			foundValidAction = false

			for (Opportunity opp in sorted) {
				Consequences currentCsq = combo.getCurrentConsequences()

				if (!opp.canExecute(currentCsq.currentTP, usesThisTurn, cooldowns, currentCsq)) {
					continue
				}

				// Use cell selection mode to pick attack cell
				Cell? attackCell = opp.findCellByMode(cellMode, currentMP, reachableCells)
				if (attackCell == null) continue

				integer moveCost = 0
				if (!opp.isSelfCast && attackCell != currentCell) {
					integer? cost = reachableCells[attackCell!]
					if (cost == null) continue
					moveCost = cost!
				}

				if (moveCost > currentMP) continue

				// Get pre-computed action (avoids spurious warnings)
				Action? action = opp.attackActions[attackCell!]
				if (action == null) continue

				if (actionsBuilt == 0) {
					if (action!.score! <= 0) continue
					push(combo.actions, action!)
				} else {
					if (!combo.add(action!)) continue
				}

				Action lastAction = combo.actions[count(combo.actions) - 1]
				Consequences newCsq = lastAction.consequences
				currentMP = newCsq.currentMP
				currentCell = newCsq.currentCell

				usesThisTurn[opp.item] = (usesThisTurn[opp.item] != null ? usesThisTurn[opp.item]! : 0) + 1
				if (opp.item.haveCD) {
					cooldowns[opp.item] = opp.item.cdDuration
				}

				if (!opp.isSelfCast && attackCell != Fight.selfCell) {
					reachableCells = MapPath.getCachedReachableCells(currentCell, currentMP, Fight.self.cellsToIgnore)
				}

				actionsBuilt++
				foundValidAction = true
				break  // Restart from top to maintain priority order
			}
		}

		// Phase 4: Final positioning
		Consequences finalCsq = combo.getCurrentConsequences()
		combo.addFinalPosition(MapPosition.findBestPosition(currentCell, currentMP, finalCsq))

		return combo
	}

	/*
	 * Get the primary cell used in a combo (for seeding other algorithms).
	 */
	static Cell getComboStartCell(Combo combo) {
		for (Action action in combo.actions) {
			if (action.from != Fight.selfCell) {
				return action.from
			}
		}
		return Fight.self.cell
	}

	/*
	 * Build combo description for debugging.
	 */
	static string buildComboDesc(Combo combo) {
		string desc = ""
		for (Action a in combo.actions) {
			if (desc != "") desc += "→"
			desc += a.item.name + "(" + round(a.score!) + ")"
		}
		if (combo.finalPosition) {
			if (desc != "") desc += "→"
			desc += "mv(" + combo.finalPosition!.cell.id + ")"
		}
		if (desc == "") desc = "stay"
		return desc
	}
}
