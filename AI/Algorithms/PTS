/*
 * PTS - Priority Target Simulation
 *
 * Alternative to MCTS that iterates TARGET-first instead of CELL-first.
 *
 * Algorithm:
 * 1. OPPORTUNITY GENERATION: For each (target, item) pair, compute attack cells and base score
 * 2. COMBO BUILDING: Greedy selection with proper consequence chaining
 * 3. FINAL POSITIONING: Find best end-of-turn position
 *
 * Key differences from MCTS:
 * - No tree search: single greedy pass through sorted opportunities
 * - No deep cloning: sequential consequence chaining (no branching)
 * - Scales with targets (~8) not cells (~50+)
 * - Much faster: O(targets × items) vs O(cells × items × MCTS_iterations)
 *
 * Can be used standalone or to SEED other algorithms with cell priorities.
 */
class PTS {
	// Statistics for debugging
	static integer lastOpportunities = 0
	static integer lastActionsBuilt = 0
	static real lastScore = 0.0

	// Cell priority scores from last opportunity generation
	// Used by Hybrid modes to prioritize MCTS/Beam cell exploration order
	// Maps Cell → weighted sum of top-3 opportunity scores (1.0, 0.7, 0.4 weights)
	// Cells with multiple good opportunities rank higher than single-opportunity cells
	static Map<Cell, real> lastCellScores = [:]

	/*
	 * Generate all opportunities: (target, item) pairs with valid attack cells.
	 * Considers ALL targets: enemies, allies, and self.
	 * Also populates lastCellScores for prioritization.
	 */
	static Array<Opportunity> generateOpportunities() {
		Benchmark.start("PTS.generateOpportunities")
		Array<Opportunity> opportunities = []
		PTS.lastCellScores = [:]  // Reset cell scores

		// Temporary storage: collect all opportunity scores per cell
		Map<Cell, Array<real>> cellScoresCollector = [:]

		// Iterate all items
		for (Item item in Fight.self.items) {
			// Skip items on cooldown
			if (getCooldown(item.id, Fight.self.id) > 0) continue

			// Get valid targets for this item
			Map<integer, Entity> targets = item.targetSet()

			// For each target
			for (Entity target in targets) {
				// Skip invincible enemies
				if (target.isInvincible && !target.isFriend) continue

				// Generate opportunity based on item type
				Opportunity? opp = PTS.createOpportunity(item, target)
				if (opp != null) {
					push(opportunities, opp!)

					// Collect scores per cell for priority calculation
					// Skip self-cast opportunities (Fight.selfCell is a sentinel, not a real cell)
					if (!opp!.isSelfCast) {
						for (Cell cell in opp!.attackCells) {
							if (cellScoresCollector[cell] == null) {
								cellScoresCollector[cell] = []
							}
							push(cellScoresCollector[cell]!, opp!.baseScore)
						}
					}
				}
			}
		}

		// Compute weighted top-K sum for each cell
		// Cells with multiple high-scoring opportunities rank higher
		// Weights: 1.0 (best), 0.7 (2nd), 0.4 (3rd) - diminishing returns
		for (Cell cell : Array<real> scores in cellScoresCollector) {
			// Sort descending
			Array<real> sorted = arraySort(scores, (real a, real b) => integer|real {
				return Sort.desc(a, b)
			}) as Array<real>

			// Weighted sum of top 3
			real priority = 0.0
			integer k = min(3, count(sorted))
			for (integer i = 0; i < k; i++) {
				real weight = 1.0 - i * 0.3  // 1.0, 0.7, 0.4
				priority += sorted[i] * weight
			}
			PTS.lastCellScores[cell] = priority
		}

		PTS.lastOpportunities = count(opportunities)
		Benchmark.stop("PTS.generateOpportunities")
		return opportunities
	}

	/*
	 * Create an opportunity for a (item, target) pair.
	 * Computes attack cells and base score.
	 * Stores ALL valid attack cells (not filtered to current reachable) for use after movement.
	 */
	static Opportunity? createOpportunity(Item item, Entity target) {
		// Self-cast case: item targets self with minRange 0
		if (target == Fight.self && item.minRange == 0) {
			// Create a temporary action to get base score
			Action tempAction = Action(item, Fight.selfCell, Fight.selfCell)
			if (tempAction.score! <= 0) return null
			return Opportunity(target, item, tempAction.score!)
		}

		// Can't target self with minRange > 0
		if (target == Fight.self) return null

		// Get ALL cells from which we can hit this target (not filtered to reachable)
		Array<Cell> attackCells
		Cell targetCell = target.cell
		Map<Cell, Cell>? cellToAim = null  // For AOE: attackCell → aimCell

		if (item.area == AREA_POINT) {
			attackCells = Targets.getCellsToUseItemOnCell(item, target.cell, [Fight.self.id])
		} else if (item.area == AREA_LASER_LINE) {
			attackCells = Targets.getLazerCellsToUseItemOnCell(item, target.cell)
		} else {
			// AOE: check ALL cells in target's area
			cellToAim = [:]
			for (Cell aoeCell in target.cell.getAreaCells(item.area)) {
				Array<Cell> cells = Targets.getCellsToUseItemOnCell(item, aoeCell, [Fight.self.id])
				for (Cell c in cells) {
					if (cellToAim![c] == null) {
						cellToAim![c] = aoeCell
					} else if (aoeCell == target.cell) {
						// Only update if actually in range (the original aoeCell was validated by getCellsToUseItemOnCell)
						integer dist = getCellDistance(c.id, aoeCell.id)
						if (dist >= item.minRange && dist <= item.maxRange) {
							cellToAim![c] = aoeCell
						}
					} else {
						integer curDist = getCellDistance(cellToAim![c]!.id, target.cell.id)
						integer newDist = getCellDistance(aoeCell.id, target.cell.id)
						if (newDist < curDist) {
							// Only update if new aimCell is in range from attack cell
							integer dist = getCellDistance(c.id, aoeCell.id)
							if (dist >= item.minRange && dist <= item.maxRange) {
								cellToAim![c] = aoeCell
							}
						}
					}
				}
			}
			attackCells = []
			for (Cell c in cellToAim!) {
				push(attackCells, c)
			}
		}

		if (count(attackCells) == 0) return null

		// Find closest CURRENTLY reachable cell for base score calculation
		// But store ALL attack cells for later use (after movement, more may be reachable)
		Cell? bestReachableCell = null
		integer bestDist = 99999
		for (Cell cell in attackCells) {
			integer? dist = Fight.self.reachableCells[cell]
			if (dist != null && dist < bestDist) {
				bestDist = dist!
				bestReachableCell = cell
			}
		}

		// If no attack cell is currently reachable, skip this opportunity for now
		if (bestReachableCell == null) return null

		// Compute base score using closest reachable cell
		Cell aimCell = (cellToAim != null && cellToAim![bestReachableCell!] != null) ? cellToAim![bestReachableCell!]! : targetCell
		Action tempAction = Action(item, bestReachableCell!, aimCell)
		if (tempAction.score! <= 0) return null

		// Store FULL attackCells (not filtered) - filtering happens at use time in findBestReachableCell
		if (cellToAim != null) {
			return Opportunity(target, item, attackCells, targetCell, tempAction.score!, cellToAim!)
		} else {
			return Opportunity(target, item, attackCells, targetCell, tempAction.score!)
		}
	}

	/*
	 * Build a combo from opportunities using greedy selection with consequence chaining.
	 * This is the core PTS algorithm.
	 *
	 * Features:
	 * - Outer loop allows multiple uses of same item (e.g., firing weapon 3x)
	 * - Greedy selection: always picks first valid opportunity in priority order
	 */
	static Combo buildCombo() {
		Benchmark.start("PTS.buildCombo")

		// Phase 1: Generate opportunities
		Array<Opportunity> opportunities = PTS.generateOpportunities()

		// If no opportunities, return movement-only combo
		if (count(opportunities) == 0) {
			Combo combo = Combo()
			combo.addFinalPosition(MapPosition.findBestPosition(Fight.self.cell, Fight.self.mp, Consequences()))
			PTS.lastActionsBuilt = 0
			PTS.lastScore = combo.getScore()!
			Benchmark.stop("PTS.buildCombo")
			return combo
		}

		// Phase 2: Sort opportunities (self-cast first, then by score descending)
		Array<Opportunity> selfCast = []
		Array<Opportunity> other = []
		for (Opportunity opp in opportunities) {
			if (opp.isSelfCast) push(selfCast, opp)
			else push(other, opp)
		}

		Array<Opportunity> sortedOther = arraySort(other, (Opportunity a, Opportunity b) => integer|real {
			return Sort.desc(a.baseScore, b.baseScore)
		}) as Array<Opportunity>

		Array<Opportunity> selfCastSorted = arraySort(selfCast, (Opportunity a, Opportunity b) => integer|real {
			return Sort.desc(a.baseScore, b.baseScore)
		}) as Array<Opportunity>

		Array<Opportunity> sorted = []
		for (Opportunity o in selfCastSorted) push(sorted, o)
		for (Opportunity o in sortedOther) push(sorted, o)

		// Phase 3: Greedy combo building with consequence chaining
		Combo combo = Combo()
		Cell currentCell = Fight.self.cell
		integer currentTP = Fight.self.tp
		integer currentMP = Fight.self.mp
		Item? weaponInHand = Fight.self.getWeaponInHand()
		Map<Item, integer> usesThisTurn = [:]
		Map<Item, integer> cooldowns = [:]
		Map<Cell, integer> reachableCells = Fight.self.reachableCells

		integer actionsBuilt = 0

		// Outer loop: restart from top after each action to handle multiple uses
		boolean foundValidAction = true
		while (foundValidAction) {
			foundValidAction = false

			for (Opportunity opp in sorted) {
				Consequences currentCsq = combo.getCurrentConsequences()

				if (!opp.canExecute(currentTP, usesThisTurn, cooldowns, currentCsq, weaponInHand)) {
					continue
				}

				Cell? attackCell = opp.findBestReachableCell(currentCell, currentMP, reachableCells)
				if (attackCell == null) continue

				integer moveCost = 0
				if (!opp.isSelfCast && attackCell != currentCell) {
					integer? cost = reachableCells[attackCell!]
					if (cost == null) continue
					moveCost = cost!
				}

				if (moveCost > currentMP) continue

				// Use first valid opportunity (greedy selection)
				Cell aimCell = opp.getAimCell(attackCell!)
				Action action = Action(opp.item, attackCell!, aimCell)

				if (actionsBuilt == 0) {
					if (action.score! <= 0) continue
					push(combo.actions, action)
				} else {
					if (!combo.add(action)) continue
				}

				Action lastAction = combo.actions[count(combo.actions) - 1]
				Consequences newCsq = lastAction.consequences
				currentTP = newCsq.currentTP
				currentMP = newCsq.currentMP
				currentCell = newCsq.currentCell

				if (opp.item.isWeap && opp.item != weaponInHand) {
					currentTP -= 1
					weaponInHand = opp.item
				}

				usesThisTurn[opp.item] = (usesThisTurn[opp.item] != null ? usesThisTurn[opp.item]! : 0) + 1
				if (opp.item.haveCD) {
					cooldowns[opp.item] = opp.item.cdDuration
				}

				if (!opp.isSelfCast && attackCell != Fight.selfCell) {
					reachableCells = MapPath.getCachedReachableCells(currentCell, currentMP, Fight.self.cellsToIgnore)
				}

				actionsBuilt++
				foundValidAction = true
				break  // Restart from top to maintain priority order
			}
		}

		// Phase 4: Final positioning
		Consequences finalCsq = combo.getCurrentConsequences()
		combo.addFinalPosition(MapPosition.findBestPosition(currentCell, currentMP, finalCsq))

		PTS.lastActionsBuilt = actionsBuilt
		PTS.lastScore = combo.getScore()!

		Benchmark.setPTS(PTS.lastOpportunities, actionsBuilt, PTS.lastScore)

		string comboDesc = PTS.buildComboDesc(combo)
		real posScore = combo.finalPosition != null ? combo.finalPosition!.score : 0
		Benchmark.addCombo(combo.getScore()!, actionsBuilt, "PTS:" + comboDesc, posScore, PTS.lastScore - posScore)

		Benchmark.stop("PTS.buildCombo")
		return combo
	}

	/*
	 * Get the primary cell used in a combo (for seeding other algorithms).
	 */
	static Cell getComboStartCell(Combo combo) {
		for (Action action in combo.actions) {
			if (action.from != Fight.selfCell) {
				return action.from
			}
		}
		return Fight.self.cell
	}

	/*
	 * Build combo description for debugging.
	 */
	static string buildComboDesc(Combo combo) {
		string desc = ""
		for (Action a in combo.actions) {
			if (desc != "") desc += "→"
			desc += a.item.name + "(" + round(a.score!) + ")"
		}
		if (combo.finalPosition) {
			if (desc != "") desc += "→"
			desc += "mv(" + combo.finalPosition!.cell.id + ")"
		}
		if (desc == "") desc = "stay"
		return desc
	}
}
