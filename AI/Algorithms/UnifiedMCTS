/*
 * Unified MCTS - Single tree with cell selection integrated
 *
 * Unlike standard MCTS which runs separate searches per cell,
 * this version has cells as first-level children of the root.
 * UCB1 naturally allocates iterations to promising cells.
 *
 * Tree structure:
 * Root
 * ├── CellNode(cell1)
 * │   ├── ActionNode(A) → ActionNode(A2) → ...
 * │   └── ActionNode(B) → ...
 * ├── CellNode(cell2)
 * │   └── ActionNode(C) → ...
 * └── ...
 */

class UnifiedMCTSNode {
	UnifiedMCTSNode? parent
	Array<UnifiedMCTSNode> children = []

	// Node identity
	boolean isRoot = false
	boolean isCellNode = false
	Cell? cell                      // For cell nodes: which cell we moved to
	Action? action                  // For action nodes: which action taken

	// State (propagated down the tree)
	Consequences state
	integer remainingTP
	integer remainingMP
	Item? weaponInHand
	Cell currentCell                // Where we are (for action filtering)

	// MCTS stats
	integer visits = 0
	real totalValue = 0.0
	boolean isTerminal = false

	// Expansion tracking
	Array<Cell> untriedCells = []       // For ROOT only: cells to try
	Array<Action> untriedActions = []   // For cell/action nodes: actions to try

	/*
	 * Root node constructor
	 */
	constructor() {
		this.isRoot = true
		this.currentCell = Fight.self.cell
		this.remainingTP = Fight.self.tp
		this.remainingMP = max(0, Fight.self.mp)
		this.weaponInHand = Fight.self.getWeaponInHand()
		this.state = Consequences()
		this.state.currentCell = this.currentCell
		this.state.currentMP = this.remainingMP
	}

	/*
	 * Cell node constructor - represents moving to a cell before acting
	 */
	constructor(UnifiedMCTSNode parent, Cell cell, integer mpCost) {
		this.parent = parent
		this.isCellNode = true
		this.cell = cell
		this.currentCell = cell
		this.remainingTP = parent.remainingTP
		this.remainingMP = max(0, parent.remainingMP - mpCost)
		this.weaponInHand = parent.weaponInHand

		// Create state at this cell
		this.state = Consequences()
		this.state.currentCell = cell
		this.state.currentMP = this.remainingMP
	}

	/*
	 * Action node constructor - represents taking an action
	 */
	constructor(UnifiedMCTSNode parent, Action baseAction) {
		this.parent = parent

		// Create action with properly chained consequences
		Action chainedAction = Action(baseAction, parent.state)
		this.action = chainedAction
		this.state = chainedAction.consequences

		// Sync currentCell with actual position after chaining (action may have moved us)
		this.currentCell = this.state.currentCell

		// Update resources - IMPORTANT: switchCost must be reflected in BOTH
		// remainingTP (for TP checks) AND state.currentTP (for chaining next action)
		integer switchCost = baseAction.item.isWeap && baseAction.item != parent.weaponInHand ? 1 : 0
		this.state.currentTP -= switchCost  // Deduct from state so next action chains correctly
		this.remainingTP = this.state.currentTP
		this.weaponInHand = baseAction.item.isWeap ? baseAction.item : parent.weaponInHand
		this.remainingMP = max(0, this.state.currentMP)
	}

	/*
	 * Initialize untried actions for this node
	 */
	void initUntriedActions(Array<Action> actionsFromCell) {
		this.untriedActions = []

		for (Action baseAction in actionsFromCell) {
			// Skip if max uses reached for this item
			if (this.getUsageCount(baseAction.item) >= baseAction.item.maxUse) continue

			// Skip if target is dead (for non-self-cast)
			if (baseAction.to != Fight.selfCell) {
				Entity? target = Board.entityCells[baseAction.to]
				if (target != null && this.state.isKilled(target!)) continue
			}

			// Check TP cost
			integer switchCost = baseAction.item.isWeap && baseAction.item != this.weaponInHand ? 1 : 0
			if (baseAction.item.cost + switchCost > this.remainingTP) continue

			push(this.untriedActions, baseAction)
		}

		this.isTerminal = count(this.untriedActions) == 0
	}

	/*
	 * Count how many times an item has been used in this path
	 */
	integer getUsageCount(Item item) {
		integer usageCount = 0
		UnifiedMCTSNode? node = this
		while (node != null) {
			if (node!.action != null && node!.action!.item == item) usageCount++
			node = node!.parent
		}
		return usageCount
	}

	/*
	 * Check if this node is fully expanded
	 */
	boolean isFullyExpanded() {
		if (this.isRoot) return count(this.untriedCells) == 0
		return count(this.untriedActions) == 0
	}

	/*
	 * UCB1 score for selection
	 */
	real getUCBScore(real explorationConstant) {
		if (this.visits == 0) return 999999.0
		real exploitation = this.totalValue / this.visits
		real exploration = explorationConstant * sqrt(log(this.parent!.visits) / this.visits)
		return exploitation + exploration
	}

	/*
	 * Get average value of this node
	 */
	real getAverageValue() {
		if (this.visits == 0) return 0.0
		return this.totalValue / this.visits
	}

	/*
	 * Get the best child by visit count (for final selection)
	 */
	UnifiedMCTSNode? getBestChild() {
		UnifiedMCTSNode? best = null
		integer bestVisits = -1
		for (UnifiedMCTSNode child in this.children) {
			if (child.visits > bestVisits) {
				bestVisits = child.visits
				best = child
			}
		}
		return best
	}
}


class UnifiedMCTS {
	// Configuration
	static real EXPLORATION_CONSTANT = 1.414    // sqrt(2), standard UCB1
	static integer MAX_ITERATIONS = 100000       // Let budget be the real limit
	static integer MAX_ACTIONS_PER_CELL = 8     // Prune actions per cell
	static integer SAFETY_BUFFER = 250000       // Keep 250k ops for combo execution
	static boolean USE_PTS_SEEDING = true       // Enable PTS priors

	// Statistics for debugging
	static integer lastIterations = 0
	static integer lastNodesCreated = 0
	static integer lastCellsExplored = 0

	/*
	 * Check if we should stop (operation budget low)
	 */
	static boolean shouldStop() {
		return getOperations() > getMaxOperations() - UnifiedMCTS.SAFETY_BUFFER
	}

	/*
	 * Main entry point - runs unified MCTS with CalibratedPTS baseline
	 */
	static Combo run() {
		Benchmark.start("UnifiedMCTS.run")

		// 1. Run calibration (tests all MP budgets, finds best tradeoff)
		CalibratedPTS.calibrate()
		Combo ptsCombo = CalibratedPTS.getBestCombo()
		real ptsScore = CalibratedPTS.bestScore

		// 2. Check budget after calibration
		if (UnifiedMCTS.shouldStop()) {
			Benchmark.setAlgo("UNIFIED_MCTS", "PTS_ONLY")
			Benchmark.setChosen(ptsScore, count(ptsCombo.actions), "PTS:" + CalibratedPTS.buildComboDesc(ptsCombo))
			Benchmark.stop("UnifiedMCTS.run")
			return ptsCombo
		}

		// 3. Build unified tree
		Map<Cell, Map<Item, Action>> mapBestAction = MapAction.getMapBestAction()
		UnifiedMCTSNode root = UnifiedMCTS.buildTree(mapBestAction)

		// 4. Seed with calibration combos (all MP budget variants)
		UnifiedMCTS._seededCells = [:]  // Reset
		if (UnifiedMCTS.USE_PTS_SEEDING) {
			Array<Combo> seedCombos = CalibratedPTS.getSeedingCombos()
			UnifiedMCTS._seededCells = UnifiedMCTS.seedWithCombos(root, seedCombos, mapBestAction)
		}

		// 5. Run MCTS iterations
		integer iterations = 0
		integer nodesCreated = 1 + count(root.children)  // Root + seeded cells

		while (iterations < UnifiedMCTS.MAX_ITERATIONS) {
			iterations++

			// Selection
			UnifiedMCTSNode node = UnifiedMCTS.select(root)

			// Expansion
			if (!node.isTerminal && !node.isFullyExpanded()) {
				UnifiedMCTSNode expanded = UnifiedMCTS.expand(node, mapBestAction)
				if (expanded != node) {
					node = expanded
					nodesCreated++
				}
			}

			// Rollout
			real value = UnifiedMCTS.rollout(node, mapBestAction)

			// Backpropagation
			UnifiedMCTS.backpropagate(node, value)

			if (UnifiedMCTS.shouldStop()) break
		}

		// Count cells explored
		integer cellsExplored = 0
		for (UnifiedMCTSNode child in root.children) {
			if (child.visits > 0) cellsExplored++
		}

		UnifiedMCTS.lastIterations = iterations
		UnifiedMCTS.lastNodesCreated = nodesCreated
		UnifiedMCTS.lastCellsExplored = cellsExplored

		// 6. Extract best combo
		Combo mctsCombo = UnifiedMCTS.extractBestCombo(root)
		real mctsScore = mctsCombo.getScore()!

		Benchmark.setMCTS(iterations, nodesCreated, cellsExplored, mctsScore)
		Benchmark.stop("UnifiedMCTS.run")

		// 7. Return better of PTS vs MCTS
		if (mctsScore > ptsScore) {
			Benchmark.setAlgo("UNIFIED_MCTS", "MCTS")
			Benchmark.setChosen(mctsScore, count(mctsCombo.actions), UnifiedMCTS.buildComboDesc(mctsCombo))
			return mctsCombo
		} else {
			Benchmark.setAlgo("UNIFIED_MCTS", "PTS")
			Benchmark.setChosen(ptsScore, count(ptsCombo.actions), "PTS:" + CalibratedPTS.buildComboDesc(ptsCombo))
			return ptsCombo
		}
	}

	/*
	 * Build the initial tree structure with cells as first-level children
	 */
	static UnifiedMCTSNode buildTree(Map<Cell, Map<Item, Action>> mapBestAction) {
		UnifiedMCTSNode root = UnifiedMCTSNode()

		// Collect all reachable cells
		for (Cell cell : integer mpCost in Fight.self.reachableCells) {
			// Always allow current cell (mpCost=0), even if shackled
			if (mpCost > 0 && mpCost > Fight.self.mp) break

			// Only add cells that have actions available (or current cell for safety)
			if (mapBestAction[cell] != null || cell == Fight.self.cell) {
				push(root.untriedCells, cell)
			}
		}

		return root
	}

	/*
	 * Seed with calibration combos - traces each combo path through tree
	 * This seeds with actual action paths, not just cell scores.
	 * Returns map of seeded cells (to skip during regular expansion).
	 */
	static Map<Cell, boolean> seedWithCombos(UnifiedMCTSNode root, Array<Combo> combos, Map<Cell, Map<Item, Action>> mapBestAction) {
		Map<Cell, boolean> seededCells = [:]

		for (Combo combo in combos) {
			if (count(combo.actions) == 0) continue

			// Find the starting cell of this combo
			Cell startCell = Fight.self.cell
			for (Action a in combo.actions) {
				if (a.from != Fight.selfCell) {
					startCell = a.from
					break
				}
			}

			// Find or create cell node
			UnifiedMCTSNode? cellNode = null
			for (UnifiedMCTSNode child in root.children) {
				if (child.isCellNode && child.cell == startCell) {
					cellNode = child
					break
				}
			}

			if (cellNode == null) {
				integer? mpCost = Fight.self.reachableCells[startCell]
				if (mpCost == null) continue

				cellNode = UnifiedMCTSNode(root, startCell, mpCost!)
				Array<Action> cellActions = UnifiedMCTS.getActionsForCell(startCell, mapBestAction)
				cellNode!.initUntriedActions(cellActions)
				push(root.children, cellNode!)
			}

			seededCells[startCell] = true

			// Trace action path and give virtual visits
			real comboScore = combo.getScore()!
			UnifiedMCTSNode node = cellNode!

			for (Action action in combo.actions) {
				// Process all actions including self-cast (they affect state like MP/TP)

				// Find or create action node
				UnifiedMCTSNode? actionNode = null
				for (UnifiedMCTSNode child in node.children) {
					if (child.action != null &&
						child.action!.item == action.item &&
						child.action!.to == action.to) {
						actionNode = child
						break
					}
				}

				if (actionNode == null) {
					actionNode = UnifiedMCTSNode(node, action)
					Array<Action> nextActions = UnifiedMCTS.getActionsForCell(actionNode!.currentCell, mapBestAction)
					actionNode!.initUntriedActions(nextActions)
					push(node.children, actionNode!)
				}

				node = actionNode!
			}

			// Backpropagate virtual visits for this combo
			integer virtualVisits = 3
			UnifiedMCTSNode? current = node
			while (current != null) {
				current!.visits += virtualVisits
				current!.totalValue += comboScore * virtualVisits
				current = current!.parent
			}
		}

		return seededCells
	}

	/*
	 * Selection phase: traverse tree using UCB1 at all levels
	 */
	static UnifiedMCTSNode select(UnifiedMCTSNode root) {
		UnifiedMCTSNode node = root

		while (!node.isTerminal && node.isFullyExpanded() && count(node.children) > 0) {
			UnifiedMCTSNode? best = null
			real bestScore = -999999.0

			for (UnifiedMCTSNode child in node.children) {
				real score = child.getUCBScore(UnifiedMCTS.EXPLORATION_CONSTANT)
				if (score > bestScore) {
					bestScore = score
					best = child
				}
			}

			if (best == null) break
			node = best!
		}

		return node
	}

	// Track seeded cells to skip during expansion
	static Map<Cell, boolean> _seededCells = [:]

	/*
	 * Expansion phase: add one child node
	 */
	static UnifiedMCTSNode expand(UnifiedMCTSNode node, Map<Cell, Map<Item, Action>> mapBestAction) {
		// Root expansion: add a cell node
		if (node.isRoot) {
			// Find next untried cell that wasn't seeded
			while (count(node.untriedCells) > 0) {
				Cell cell = shift(node.untriedCells)

				// Skip if already seeded
				if (UnifiedMCTS._seededCells[cell]) continue

				integer? mpCost = Fight.self.reachableCells[cell]
				if (mpCost == null) continue

				UnifiedMCTSNode cellNode = UnifiedMCTSNode(node, cell, mpCost!)

				// Initialize actions for this cell
				Array<Action> cellActions = UnifiedMCTS.getActionsForCell(cell, mapBestAction)
				cellNode.initUntriedActions(cellActions)

				push(node.children, cellNode)
				return cellNode
			}
			return node
		}

		// Cell/Action node expansion: add an action node
		if (count(node.untriedActions) == 0) return node

		Action baseAction = shift(node.untriedActions)
		UnifiedMCTSNode actionNode = UnifiedMCTSNode(node, baseAction)

		// Initialize child's available actions (use child's position, not parent's)
		Array<Action> nextActions = UnifiedMCTS.getActionsForCell(actionNode.currentCell, mapBestAction)
		actionNode.initUntriedActions(nextActions)

		push(node.children, actionNode)
		return actionNode
	}

	/*
	 * Get pruned actions available from a cell (includes self-cast)
	 */
	static Array<Action> getActionsForCell(Cell cell, Map<Cell, Map<Item, Action>> mapBestAction) {
		Array<Action> actions = []

		// Add actions from this cell
		if (mapBestAction[cell] != null) {
			for (Item item : Action action in mapBestAction[cell]!) {
				push(actions, action)
			}
		}

		// Add self-cast actions
		if (mapBestAction[Fight.selfCell] != null) {
			for (Item item : Action action in mapBestAction[Fight.selfCell]!) {
				push(actions, action)
			}
		}

		// Prune to top actions if too many
		return UnifiedMCTS.pruneActions(actions)
	}

	/*
	 * Prune action space to top-K actions by score
	 * Self-cast actions are never pruned
	 */
	static Array<Action> pruneActions(Array<Action> actions) {
		// Filter out non-positive score actions
		Array<Action> viable = []
		for (Action act in actions) {
			if (act.score! > 0) push(viable, act)
		}
		if (count(viable) == 0) return []

		// Separate self-cast from other actions
		Array<Action> selfCast = []
		Array<Action> other = []
		for (Action act in viable) {
			if (act.from == Fight.selfCell) push(selfCast, act)
			else push(other, act)
		}

		// If other actions fit within limit, return all viable
		if (count(other) <= UnifiedMCTS.MAX_ACTIONS_PER_CELL) {
			return viable
		}

		// Sort other actions by score descending
		Array<Action> sorted = arraySort(other, (Action x, Action y) => integer|real {
			return Sort.desc(x.score!, y.score!)
		}) as Array<Action>

		// Take top K from other, keep all self-cast
		Array<Action> pruned = selfCast
		for (integer i = 0; i < UnifiedMCTS.MAX_ACTIONS_PER_CELL && i < count(sorted); i++) {
			push(pruned, sorted[i])
		}

		return pruned
	}

	/*
	 * Rollout phase: greedy simulation from node
	 */
	static real rollout(UnifiedMCTSNode node, Map<Cell, Map<Item, Action>> mapBestAction) {
		integer simTP = node.remainingTP
		Item? simWeapon = node.weaponInHand
		Consequences currentState = node.state

		// Track usage counts from tree path
		Map<Item, integer> usageCounts = [:]
		UnifiedMCTSNode? n = node
		while (n != null) {
			if (n!.action != null) {
				Item usedItem = n!.action!.item
				usageCounts[usedItem] = (usageCounts[usedItem] ? usageCounts[usedItem]! : 0) + 1
			}
			n = n!.parent
		}

		// Get actions for rollout
		Array<Action> actions = UnifiedMCTS.getActionsForCell(node.currentCell, mapBestAction)

		// Greedy rollout (max 3 steps)
		integer rolloutSteps = 0
		integer maxSteps = 3

		while (rolloutSteps < maxSteps && simTP > 0) {
			Action? bestAction = null

			for (Action baseAction in actions) {
				// Skip if max uses reached
				integer currentUses = usageCounts[baseAction.item] ? usageCounts[baseAction.item]! : 0
				if (currentUses >= baseAction.item.maxUse) continue

				// Skip if target dead (for non-self-cast)
				if (baseAction.to != Fight.selfCell) {
					Entity? target = Board.entityCells[baseAction.to]
					if (target != null && currentState.isKilled(target!)) continue
				}

				// Check TP
				integer switchCost = baseAction.item.isWeap && baseAction.item != simWeapon ? 1 : 0
				if (baseAction.item.cost + switchCost > simTP) continue

				// Found valid action
				bestAction = baseAction
				break
			}

			if (bestAction == null) break

			// Track TP before action
			integer prevCurrentTP = currentState.currentTP

			// Create chained action
			Action chainedAction = Action(bestAction!, currentState)

			// Only continue if score improved
			real prevScore = currentState.score == null ? 0.0 : currentState.score!
			if (chainedAction.score! <= prevScore) break

			// Apply action
			currentState = chainedAction.consequences
			integer switchCost = bestAction!.item.isWeap && bestAction!.item != simWeapon ? 1 : 0
			simTP += (currentState.currentTP - prevCurrentTP) - switchCost
			if (bestAction!.item.isWeap) simWeapon = bestAction!.item
			usageCounts[bestAction!.item] = (usageCounts[bestAction!.item] ? usageCounts[bestAction!.item]! : 0) + 1
			rolloutSteps++
		}

		// Final score = action score + estimated position value
		// Uses calibration data to estimate position value based on remaining MP
		real totalScore = currentState.score == null ? 0.0 : currentState.score!
		real positionEstimate = CalibratedPTS.estimatePositionValue(node.remainingMP)
		totalScore += positionEstimate

		return totalScore
	}

	/*
	 * Backpropagation phase: update node statistics up the tree
	 */
	static void backpropagate(UnifiedMCTSNode node, real value) {
		UnifiedMCTSNode? current = node
		while (current != null) {
			current!.visits++
			current!.totalValue += value
			current = current!.parent
		}
	}

	/*
	 * Extract the best combo by following most-visited path
	 */
	static Combo extractBestCombo(UnifiedMCTSNode root) {
		Combo combo = Combo()

		// 1. Find best cell (most visited)
		UnifiedMCTSNode? bestCellNode = root.getBestChild()
		if (bestCellNode == null) {
			// No cell explored - return movement-only combo
			combo.addFinalPosition(MapPosition.findBestPosition(Fight.self.cell, Fight.self.mp, Consequences()))
			return combo
		}

		// 2. Follow action path from that cell
		UnifiedMCTSNode? node = bestCellNode
		while (node != null) {
			UnifiedMCTSNode? bestChild = node!.getBestChild()
			if (bestChild == null) break

			if (bestChild!.action != null) {
				// Use combo.add() for proper chaining and usage validation
				if (!combo.add(bestChild!.action!)) break
			}

			node = bestChild
		}

		// 3. Add final position
		if (count(combo.actions) == 0) {
			// Movement-only: find best position from cell node's cell
			Cell fromCell = bestCellNode!.cell != null ? bestCellNode!.cell! : Fight.self.cell
			integer mp = bestCellNode!.remainingMP
			combo.addFinalPosition(MapPosition.findBestPosition(fromCell, mp, Consequences()))
		} else {
			combo.addFinalPosition(AI.findBestPosition(combo))
		}

		return combo
	}

	/*
	 * Build combo description for debugging
	 */
	static string buildComboDesc(Combo combo) {
		string desc = ""
		for (Action a in combo.actions) {
			if (desc != "") desc += "→"
			desc += a.item.name + "(" + round(a.score!) + ")"
		}
		if (combo.finalPosition) {
			if (desc != "") desc += "→"
			Position p = combo.finalPosition!
			desc += "mv(" + p.cell.id + ":" + round(p.score) + ")"
		}
		if (desc == "") desc = "stay"
		return desc
	}
}
