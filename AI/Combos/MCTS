/*
 * Monte Carlo Tree Search implementation for action sequence optimization
 * Replaces greedy combo building with principled exploration/exploitation
 */

class MCTSNode {
	MCTSNode? parent
	Array<MCTSNode> children = []
	Action? action                    // Action that led to this node (null for root)
	Consequences state               // Game state at this node
	integer remainingTP
	integer remainingMP
	Item? weaponInHand

	// MCTS statistics
	integer visits = 0
	real totalValue = 0.0
	Array<Action> untriedActions = []
	boolean isTerminal = false

	// For path reconstruction
	Cell startCell                   // Cell we moved to at start of turn

	/*
	 * Root node constructor - initial state at a given starting position
	 */
	constructor(Cell startCell, integer tp, integer mp, Item? weapon, Array<Action> availableActions) {
		this.parent = null
		this.action = null
		this.startCell = startCell
		this.remainingTP = tp
		this.remainingMP = mp
		this.weaponInHand = weapon
		this.untriedActions = availableActions
		this.isTerminal = count(availableActions) == 0

		// Create root state - position is the starting cell with adjusted MP
		this.state = Consequences()
		this.state.currentCell = startCell
		this.state.currentMP = mp
	}

	/*
	 * Child node constructor - after taking an action
	 * Creates a new Action chained with parent's consequences
	 */
	constructor(MCTSNode parent, Action baseAction) {
		this.parent = parent
		this.startCell = parent.startCell

		// Create action with properly chained consequences
		Action chainedAction = Action(baseAction, parent.state)
		this.action = chainedAction
		this.state = chainedAction.consequences

		// Update resources
		integer switchCost = baseAction.item.isWeap && baseAction.item != parent.weaponInHand ? 1 : 0
		this.remainingTP = this.state.currentTP - switchCost  // TP cost and boosts computed in Consequences
		this.weaponInHand = baseAction.item.isWeap ? baseAction.item : parent.weaponInHand

		// MP cost for movement (computed in Consequences)
		this.remainingMP = this.state.currentMP
	}

	/*
	 * Initialize untried actions for a child node
	 * Called during expansion to populate valid actions from this state
	 */
	void initUntriedActions(Array<Action> actionsFromCell) {
		this.untriedActions = []

		for (Action baseAction in actionsFromCell) {
			// Skip if max uses reached for this item
			if (this.getUsageCount(baseAction.item) >= baseAction.item.maxUse) continue

			// Skip if target is dead
			Entity? target = Board.entityCells[baseAction.to]
			if (target != null && this.state.isKilled(target!)) continue

			// Check TP cost
			integer switchCost = baseAction.item.isWeap && baseAction.item != this.weaponInHand ? 1 : 0
			if (baseAction.item.cost + switchCost > this.remainingTP) continue

			push(this.untriedActions, baseAction)
		}

		this.isTerminal = count(this.untriedActions) == 0
	}

	/*
	 * Count how many times an item has been used in this action sequence
	 */
	integer getUsageCount(Item item) {
		integer count = 0
		MCTSNode? node = this
		while (node != null) {
			if (node!.action != null && node!.action!.item == item) count++
			node = node!.parent
		}
		return count
	}

	/*
	 * UCB1 score for selection
	 */
	real getUCBScore(real explorationConstant) {
		if (this.visits == 0) return 999999.0  // Unvisited nodes have priority
		real exploitation = this.totalValue / this.visits
		real exploration = explorationConstant * sqrt(log(this.parent!.visits) / this.visits)
		return exploitation + exploration
	}

	/*
	 * Get average value of this node
	 */
	real getAverageValue() {
		if (this.visits == 0) return 0.0
		return this.totalValue / this.visits
	}

	/*
	 * Check if this node is fully expanded
	 */
	boolean isFullyExpanded() {
		return count(this.untriedActions) == 0
	}

	/*
	 * Get the best child by visit count (for final selection)
	 */
	MCTSNode? getBestChild() {
		MCTSNode? best = null
		integer bestVisits = -1
		for (MCTSNode child in this.children) {
			if (child.visits > bestVisits) {
				bestVisits = child.visits
				best = child
			}
		}
		return best
	}

	/*
	 * Get the best child by average value (alternative selection)
	 */
	MCTSNode? getBestChildByValue() {
		MCTSNode? best = null
		real bestValue = -999999.0
		for (MCTSNode child in this.children) {
			if (child.visits > 0) {
				real avg = child.getAverageValue()
				if (avg > bestValue) {
					bestValue = avg
					best = child
				}
			}
		}
		return best
	}
}


class MCTS {
	// Configuration
	static real EXPLORATION_CONSTANT = 1.414  // sqrt(2), standard UCB1
	static integer MAX_ACTIONS_TO_TRY = 8     // Prune action space
	static integer MAX_ITERATIONS = 150        // Maximum iterations per search
	static integer SAFETY_BUFFER = 200000     // Keep 200k ops for combo execution

	// Statistics for debugging
	static integer lastIterations = 0
	static integer lastNodesCreated = 0
	static integer totalOpsUsed = 0

	/*
	 * Check if we should stop (less than SAFETY_BUFFER ops remaining)
	 */
	static boolean shouldStop() {
		return getOperations() > getMaxOperations() - MCTS.SAFETY_BUFFER
	}

	/*
	 * Main MCTS search from a given starting position
	 * ALWAYS returns a combo - at minimum a movement-only combo with positioning
	 */
	static Combo search(Cell startCell, Map<Item, Action> actionsAtCell, integer tp, integer mp, Item? weapon) {
		integer startOps = getOperations()

		// Prune and prepare initial actions - computed ONCE and reused
		// This saves ~300 calls to pruneActions() over 150 iterations
		Array<Action> prunedActions = MCTS.pruneActions(mapValues(actionsAtCell))

		// If no actions available, return movement-only combo
		if (count(prunedActions) == 0) {
			Combo moveOnlyCombo = Combo()
			moveOnlyCombo.addFinalPosition(MCTS.findBestPositionFromCell(startCell, mp, Consequences()))
			return moveOnlyCombo
		}

		// Create root node
		MCTSNode root = MCTSNode(startCell, tp, mp, weapon, prunedActions)

		integer iterations = 0
		integer nodesCreated = 1

		// MCTS loop - run until we hit operation limit
		// Always do at least 1 iteration to have something to return
		while (iterations < MCTS.MAX_ITERATIONS) {
			Benchmark.start('MCTS.iter')
			iterations++

			// Selection: traverse tree using UCB
			MCTSNode node = MCTS.select(root)

			// Expansion: add a new child if not terminal
			if (!node.isTerminal && !node.isFullyExpanded()) {
				// Pass prunedActions instead of recalculating
				node = MCTS.expand(node, prunedActions)
				nodesCreated++
			}

			// Simulation: greedy rollout from this node
			// Pass prunedActions instead of recalculating
			real value = MCTS.rollout(node, prunedActions)

			// Backpropagation: update statistics
			MCTS.backpropagate(node, value)

			Benchmark.stop('MCTS.iter')

			// Check budget after at least 1 iteration
			if (MCTS.shouldStop()) {
				break
			}
		}

		MCTS.lastIterations = iterations
		MCTS.lastNodesCreated = nodesCreated
		MCTS.totalOpsUsed += getOperations() - startOps

		// Extract best path found - always returns a valid combo now
		Combo combo = MCTS.extractBestCombo(root, startCell)

		// Track combo for debugging
		real actScore = 0
		for (Action a in combo.actions) actScore += a.score!
		real posScore = combo.finalPosition ? combo.finalPosition!.score : 0
		Benchmark.addCombo(combo.getScore()!, count(combo.actions), MCTS.buildComboDesc(combo), posScore, actScore)

		return combo
	}

	/*
	 * Selection phase: traverse tree using UCB1
	 */
	static MCTSNode select(MCTSNode node) {
		while (!node.isTerminal && node.isFullyExpanded()) {
			MCTSNode? best = null
			real bestScore = -999999.0

			for (MCTSNode child in node.children) {
				real score = child.getUCBScore(MCTS.EXPLORATION_CONSTANT)
				if (score > bestScore) {
					bestScore = score
					best = child
				}
			}

			if (best == null) break
			node = best!
		}
		return node
	}

	/*
	 * Expansion phase: add one child node
	 * @param prunedActions Pre-computed pruned actions (optimization: avoids recalculating each iteration)
	 */
	static MCTSNode expand(MCTSNode node, Array<Action> prunedActions) {
		if (count(node.untriedActions) == 0) return node

		// Pick first untried action (deterministic)
		Action action = shift(node.untriedActions)

		// Create child node
		MCTSNode child = MCTSNode(node, action)

		// Initialize child's available actions using pre-computed prunedActions
		child.initUntriedActions(prunedActions)

		push(node.children, child)
		return child
	}

	/*
	 * Rollout phase: greedy simulation with chained consequences
	 * Properly chains actions to capture buff synergies (e.g., STR buff → higher damage)
	 * @param prunedActions Pre-computed pruned actions (optimization: avoids recalculating each iteration)
	 */
	static real rollout(MCTSNode node, Array<Action> prunedActions) {
		integer simTP = node.remainingTP
		Item? simWeapon = node.weaponInHand
		Consequences currentState = node.state  // Chain from this, no clone needed

		// Track usage counts from tree path
		Map<Item, integer> usageCounts = [:]
		MCTSNode? n = node
		while (n != null) {
			if (n!.action != null) {
				Item usedItem = n!.action!.item
				usageCounts[usedItem] = (usageCounts[usedItem] ? usageCounts[usedItem]! : 0) + 1
			}
			n = n!.parent
		}

		// Use pre-computed pruned actions (self-cast first, sorted by score)
		Array<Action> actions = prunedActions

		// Rollout with chained consequences - picks best valid action each step
		integer rolloutSteps = 0
		integer maxSteps = 3

		while (rolloutSteps < maxSteps && simTP > 0) {
			Action? bestAction = null

			for (Action baseAction in actions) {
				// Skip if max uses reached
				integer currentUses = usageCounts[baseAction.item] ? usageCounts[baseAction.item]! : 0
				if (currentUses >= baseAction.item.maxUse) continue

				// Skip if target dead (for non-self-cast)
				if (baseAction.to != Fight.selfCell) {
					Entity? target = Board.entityCells[baseAction.to]
					if (target != null && currentState.isKilled(target!)) continue
				}

				// Check TP
				integer switchCost = baseAction.item.isWeap && baseAction.item != simWeapon ? 1 : 0
				if (baseAction.item.cost + switchCost > simTP) continue

				// Found valid action (list is prioritized: self-cast first, then by score)
				bestAction = baseAction
				break
			}

			if (bestAction == null) break

			// Track TP before action (to compute delta including boosts)
			integer prevCurrentTP = currentState.currentTP

			// Create chained action to get proper score with consequences
			Action chainedAction = Action(bestAction!, currentState)

			// Only continue if score improved (positive delta)
			real prevScore = currentState.score == null ? 0.0 : currentState.score!
			if (chainedAction.score! <= prevScore) break

			// Apply action: update state and resources
			currentState = chainedAction.consequences
			integer switchCost = bestAction!.item.isWeap && bestAction!.item != simWeapon ? 1 : 0
			simTP += (currentState.currentTP - prevCurrentTP) - switchCost  // delta includes -cost +boost
			if (bestAction!.item.isWeap) simWeapon = bestAction!.item
			usageCounts[bestAction!.item] = (usageCounts[bestAction!.item] ? usageCounts[bestAction!.item]! : 0) + 1
			rolloutSteps++
		}

		// Final score = accumulated consequence score + danger at final position
		real totalScore = currentState.score == null ? 0.0 : currentState.score!
		Danger finalDanger = MapDanger.getCellDanger(currentState.currentCell, currentState)
		totalScore += finalDanger.score

		return totalScore
	}

	/*
	 * Backpropagation phase: update node statistics
	 */
	static void backpropagate(MCTSNode node, real value) {
		MCTSNode? current = node
		while (current != null) {
			current!.visits++
			current!.totalValue += value
			current = current!.parent
		}
	}

	/*
	 * Extract the best combo from the tree by following most-visited path
	 * ALWAYS returns a valid combo - even with 0 actions (movement-only turn)
	 */
	static Combo extractBestCombo(MCTSNode root, Cell startCell) {
		Combo combo = Combo()

		MCTSNode? node = root
		while (node != null) {
			MCTSNode? bestChild = node!.getBestChild()
			if (bestChild == null) break

			// Add action to combo using Combo.add() which handles chaining
			if (bestChild!.action != null) {
				// combo.add() will re-chain with combo's current consequences
				if (!combo.add(bestChild!.action!)) break
			}

			node = bestChild
		}

		// Add final position (includes danger + positioning score)
		// For 0-action combos, use the evaluated startCell as the reference point
		if (count(combo.actions) == 0) {
			// Movement-only turn: find best position from startCell
			Position pos = MCTS.findBestPositionFromCell(startCell, Fight.self.mp, Consequences())
			combo.addFinalPosition(pos)
		} else {
			combo.addFinalPosition(AI.findBestPosition(combo))
		}
		return combo
	}

	/*
	 * Prune action space to top-K actions by immediate score
	 * Self-cast actions are never pruned (heals, buffs, etc.)
	 */
	static Array<Action> pruneActions(Array<Action> actions) {
		// Filter out non-positive score actions (useless CD items, etc.)
		Array<Action> viable = []
		for (Action act in actions) {
			if (act.score! > 0) push(viable, act)
		}
		if (count(viable) == 0) return []

		// Separate self-cast from other actions
		Array<Action> selfCast = []
		Array<Action> other = []
		for (Action act in viable) {
			if (act.from == Fight.selfCell) push(selfCast, act)
			else push(other, act)
		}

		// If other actions fit within limit, return all viable
		if (count(other) <= MCTS.MAX_ACTIONS_TO_TRY) {
			return viable
		}

		// Sort other actions by score descending
		Array<Action> sorted = arraySort(other, (Action x, Action y) => integer|real {
			return Sort.desc(x.score!, y.score!)
		}) as Array<Action>

		// Take top K from other, keep all self-cast
		Array<Action> pruned = selfCast
		for (integer i = 0; i < MCTS.MAX_ACTIONS_TO_TRY && i < count(sorted); i++) {
			push(pruned, sorted[i])
		}

		return pruned
	}

	/*
	 * Find best position from a specific cell with given MP
	 * Used for movement-only turns where combo has 0 actions.
	 */
	static Position findBestPositionFromCell(Cell fromCell, integer mp, Consequences? state) {
		return MapPosition.findBestPosition(fromCell, mp, state)
	}

	/*
	 * Build a short description of a combo for debugging.
	 */
	static string buildComboDesc(Combo combo) {
		string desc = ""
		for (Action a in combo.actions) {
			if (desc != "") desc += "→"
			desc += a.item.name + "(" + round(a.score!) + ")"
		}
		if (combo.finalPosition) {
			if (desc != "") desc += "→"
			Position p = combo.finalPosition!
			desc += "mv(" + p.cell.id + ":" + round(p.score) + ")"
		}
		if (desc == "") desc = "stay"
		return desc
	}
}
