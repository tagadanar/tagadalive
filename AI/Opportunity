/*
 * Opportunity represents a potential action on a target.
 * Used by PTS (Priority Target Simulation) to build combos target-first.
 *
 * Instead of iterating cells then actions (like MCTS), we iterate:
 *   TARGET -> ITEM -> find valid CELLS
 *
 * This naturally filters irrelevant positions and scales with targets, not cells.
 *
 * Stores both closestCell (min MP) and bestScoreCell (max damage) to allow
 * algorithms to test both approaches and compare final combo scores.
 */
class Opportunity {
	Entity target              // The entity we want to affect
	Item item                  // The item to use
	Map<Cell, Cell> attackCells // attackCell → aimCell mapping (unified index)
	Map<Cell, real> attackScores // attackCell → score (for cell selection)
	Map<Cell, Action> attackActions // attackCell → pre-computed Action (avoids spurious warnings)
	real baseScore             // Best achievable score (from bestScoreCell)
	real closestScore          // Score from closestCell (conservative estimate)
	Cell? closestCell          // Cell with minimum MP cost
	Cell? bestScoreCell        // Cell with maximum score
	boolean isSelfCast         // True if self-cast action (buff/heal on self)

	// Cell selection modes for PTS dual-testing
	static integer MODE_CLOSEST = 0    // Minimize MP (more MP for retreat)
	static integer MODE_BEST_SCORE = 1 // Maximize damage

	/*
	 * Constructor for a standard opportunity (target + item + cells + scores + actions)
	 * attackCells maps each attack cell to its corresponding aim cell
	 * attackScores maps each attack cell to its action score
	 * attackActions maps each attack cell to its pre-computed Action
	 */
	constructor(Entity target, Item item, Map<Cell, Cell> attackCells, Map<Cell, real> attackScores, Map<Cell, Action> attackActions, Cell closestCell, Cell bestScoreCell) {
		this.target = target
		this.item = item
		this.attackCells = attackCells
		this.attackScores = attackScores
		this.attackActions = attackActions
		this.closestCell = closestCell
		this.bestScoreCell = bestScoreCell
		this.closestScore = attackScores[closestCell]!
		this.baseScore = attackScores[bestScoreCell]!
		this.isSelfCast = false
	}

	/*
	 * Constructor for self-cast opportunity
	 * Takes the pre-computed action to avoid recreating it later
	 */
	constructor(Entity target, Item item, Action action) {
		this.target = target
		this.item = item
		this.attackCells = [Fight.selfCell: Fight.selfCell]
		this.attackScores = [Fight.selfCell: action.score!]
		this.attackActions = [Fight.selfCell: action]
		this.closestCell = Fight.selfCell
		this.bestScoreCell = Fight.selfCell
		this.closestScore = action.score!
		this.baseScore = action.score!
		this.isSelfCast = true
	}

	/*
	 * Get the aim cell for a given attack cell.
	 * Falls back to target's cell if not found (same as old targetCell behavior).
	 */
	Cell getAimCell(Cell attackCell) {
		Cell? aim = this.attackCells[attackCell]
		return aim != null ? aim! : this.target.cell
	}

	/*
	 * Get preferred cell based on selection mode.
	 * MODE_CLOSEST: returns closestCell (minimize MP)
	 * MODE_BEST_SCORE: returns bestScoreCell (maximize damage)
	 */
	Cell? getCellByMode(integer mode) {
		if (this.isSelfCast) return Fight.selfCell
		return mode == MODE_CLOSEST ? this.closestCell : this.bestScoreCell
	}

	/*
	 * Find reachable cell based on mode preference.
	 * If preferred cell is not reachable, falls back to any reachable cell.
	 */
	Cell? findCellByMode(integer mode, integer availableMP, Map<Cell, integer> reachableCells) {
		if (this.isSelfCast) return Fight.selfCell

		// Try preferred cell first
		Cell? preferred = this.getCellByMode(mode)
		if (preferred != null) {
			integer? cost = reachableCells[preferred!]
			if (cost != null && cost! <= availableMP) {
				return preferred
			}
		}

		// Fallback: find any reachable cell (use opposite mode's cell or search)
		Cell? fallback = this.getCellByMode(mode == MODE_CLOSEST ? MODE_BEST_SCORE : MODE_CLOSEST)
		if (fallback != null) {
			integer? cost = reachableCells[fallback!]
			if (cost != null && cost! <= availableMP) {
				return fallback
			}
		}

		// Last resort: search all cells
		return this.findBestReachableCell(Fight.self.cell, availableMP, reachableCells)
	}

	/*
	 * Find the best reachable cell from a given position with available MP.
	 * Returns the cell with minimum movement cost, or null if none reachable.
	 */
	Cell? findBestReachableCell(Cell fromCell, integer availableMP, Map<Cell, integer> reachableCells) {
		// Self-cast: no movement needed
		if (this.isSelfCast) return Fight.selfCell

		Cell? bestCell = null
		integer bestCost = 99999

		for (Cell attackCell : Cell aimCell in this.attackCells) {
			integer? cost = reachableCells[attackCell]
			if (cost != null && cost <= availableMP && cost < bestCost) {
				bestCost = cost!
				bestCell = attackCell
			}
		}

		return bestCell
	}

	/*
	 * Find best cell prioritizing position score (when multiple cells have same MP cost)
	 * This is more expensive but gives better positioning choices.
	 */
	Cell? findBestReachableCellWithPositioning(Cell fromCell, integer availableMP, Map<Cell, integer> reachableCells, Consequences csq) {
		if (this.isSelfCast) return Fight.selfCell

		Cell? bestCell = null
		integer bestCost = 99999
		real bestPositionScore = -999999.0

		for (Cell attackCell : Cell aimCell in this.attackCells) {
			integer? cost = reachableCells[attackCell]
			if (cost != null && cost <= availableMP) {
				// Among cells with same cost, prefer better position score
				if (cost < bestCost) {
					bestCost = cost!
					bestCell = attackCell
					// Only compute position score if we found a new best cost
					Danger d = MapDanger.getCellDanger(attackCell, csq)
					bestPositionScore = d.score
				} else if (cost == bestCost) {
					// Same cost: compare position scores
					Danger d = MapDanger.getCellDanger(attackCell, csq)
					if (d.score > bestPositionScore) {
						bestPositionScore = d.score
						bestCell = attackCell
					}
				}
			}
		}

		return bestCell
	}

	/*
	 * Check if this opportunity can be executed given current state.
	 * Does NOT check reachability (caller should use findBestReachableCell first).
	 */
	boolean canExecute(integer availableTP, Map<Item, integer> usesThisTurn, Map<Item, integer> cooldowns, Consequences csq, Item? weaponInHand) {
		// Check cooldown
		integer cd = cooldowns[this.item] != null ? cooldowns[this.item]! : 0
		if (cd > 0) return false

		// Check uses this turn
		integer uses = usesThisTurn[this.item] != null ? usesThisTurn[this.item]! : 0
		if (uses >= this.item.maxUse) return false

		// Check target not dead
		if (csq.isKilled(this.target)) return false

		// Check TP (including weapon switch cost)
		integer switchCost = this.item.isWeap && this.item != weaponInHand ? 1 : 0
		if (availableTP < this.item.cost + switchCost) return false

		return true
	}

	string string() {
		return "<Opp " + this.item.name + "→" + this.target.name + " best:" + round(this.baseScore) + " close:" + round(this.closestScore) + " cells:" + mapSize(this.attackCells) + ">"
	}
}
