class Scoring {
	static Map<Entity, Map<integer, real>> _cache_coef = [:] // [entity:[key:value]]
	static Map<integer, integer> _cache_duration = [:] // [(rawDuration+1)*2 + turnOrderBit : effectiveDuration]

	static integer KILL_VALUE = 1000
	static integer DEATH_VALUE = -1000
	static integer MAX_FIGHT_TURNS = 66
	static integer MAX_DURATION = 8 // max index in duration_mitigation maps
	
	static Map<integer, real> defensive_duration_mitigation = [
		0 : 1.0,
		1 : 1.0,
		2 : 1.8,
		3 : 2.4,
		4 : 2.8,
		5 : 3.2,
		6 : 3.6,
		7 : 4.0,
		8 : 4.4,
	]
	
	static Map<integer, real> offensive_duration_mitigation = [
		0 : 1.0,
		1 : 1.0,
		2 : 1.8,
		3 : 2.4,
		4 : 2.8,
		5 : 3.2,
		6 : 3.6,
		7 : 4.0,
		8 : 4.4,
	]
	
	static Map<integer, Function<Entity => real>> computeCoef = [
		Stats.HP: (Entity entity) => real {
			if(Scoring._cache_coef[entity]![Stats.HP] == null) {
				real coef
				if(entity.isFriend){
					if(entity.isBulb) coef = 0.5
					else coef = 1.0
				} else {
					if(entity.isBulb) coef = -0.5
					else coef = -1.0
				}
				Scoring._cache_coef[entity]![Stats.HP] = coef
			}
			return Scoring._cache_coef[entity]![Stats.HP]!
		}
	]
	
	/*
	 * initialise les coefs de tout le monde, dummy values pour le moment, TODO function in array?
	 */
	static void refresh(){
		_cache_coef = [:]
		_cache_duration = [:]

		// Pre-compute effective durations for all raw values (-1 to MAX_DURATION)
		// Key formula: (rawDuration + 1) * 2 + (sourceAfterTarget ? 1 : 0)
		integer turnsLeft = MAX_FIGHT_TURNS - getTurn()
		for(integer raw = -1; raw <= MAX_DURATION; raw++){
			// For finite durations, cap to turnsLeft (can't benefit longer than fight lasts)
			integer base = raw == -1 ? turnsLeft : min(raw, turnsLeft)
			base = min(base, MAX_DURATION)
			// source plays before target → target gets full duration
			_cache_duration[(raw + 1) * 2] = max(base, 0)
			// source plays after target → target gets 1 less turn
			_cache_duration[(raw + 1) * 2 + 1] = max(base - 1, 0)
		}
		for(Entity entity in Fight.getAllAlive()){
			_cache_coef[entity] = [:]
			_cache_coef[entity]![Stats.HP] = entity.isFriend ? (entity.isBulb ? 0.5 : 1.0) 
																: (entity.isBulb ? -0.5 : -1.0) 
			_cache_coef[entity]![Stats.HPTIME] = entity.isFriend ? (entity.isBulb ? 0.2 : 1.0)
																	: (entity.isBulb ? -0.2 : -1.0)
			_cache_coef[entity]![Stats.HPMAX] = entity.isFriend ? (entity.isBulb ? 0.2 : 1.8)
																	: (entity.isBulb ? -0.2 : -1.0)
			_cache_coef[entity]![Stats.DEBUFF] = entity.isFriend ? (entity.isBulb ? 0.2 : 1.0)
																	: (entity.isBulb ? -0.2 : -1.0)
			_cache_coef[entity]![Stats.ANTIDOTE] = entity.isFriend ? (entity.isBulb ? 0.2 : 1.0)
																	: (entity.isBulb ? -0.2 : -1.0)
			_cache_coef[entity]![Stats.ABSSHIELD] = entity.isFriend ? (entity.isBulb ? 0.6 : 3.0)
																	: (entity.isBulb ? -0.6 : -3.0)
			_cache_coef[entity]![Stats.RELSHIELD] = entity.isFriend ? (entity.isBulb ? 1.2 : 6.0)
																	: (entity.isBulb ? -1.2 : -6.0)
			_cache_coef[entity]![Stats.DMGRETURN] = entity.isFriend ? (entity.isBulb ? 0.6 : 3.0)
																	: (entity.isBulb ? -0.6 : -3.0)
			_cache_coef[entity]![Stats.STR] = entity.isFriend ? (entity.isBulb ? 0.2 : 1.0)
																	: (entity.isBulb ? -0.2 : -1.0)
			_cache_coef[entity]![Stats.MGC] = entity.isFriend ? (entity.isBulb ? 0.2 : 1.0)
																	: (entity.isBulb ? -0.2 : -1.0)
			_cache_coef[entity]![Stats.RST] = entity.isFriend ? (entity.isBulb ? 0.2 : 1.0)
																	: (entity.isBulb ? -0.2 : -1.0)
			_cache_coef[entity]![Stats.WSD] = entity.isFriend ? (entity.isBulb ? 0.2 : 1.2)
																	: (entity.isBulb ? -0.2 : -1.0)
			_cache_coef[entity]![Stats.AGI] = entity.isFriend ? (entity.isBulb ? 0.2 : 1.0)
																	: (entity.isBulb ? -0.2 : -1.0)
			_cache_coef[entity]![Stats.TP] = entity.isFriend ? (entity.isBulb ? 2.0 : 10.0)
																	: (entity.isBulb ? -2.0 : -10.0)
			_cache_coef[entity]![Stats.MP] = entity.isFriend ? (entity.isBulb ? 2.0 : 10.0)
																	: (entity.isBulb ? -2.0 : -10.0)
			_cache_coef[entity]![Stats.PWR] = entity.isFriend ? (entity.isBulb ? 0.2 : 1.0)
																	: (entity.isBulb ? -0.2 : -1.0)
			// fonctionnement à part, peut être que ça restera pas ça...
			_cache_coef[entity]![Stats.KILL] = entity.isFriend ? (entity.isBulb ? -0.2 : -1.0)
																	: (entity.isBulb ? 0.2 : 1.0)
		}
	}
	
	/*
	 * retourne le coef d'une entity pour la key donnée
	 */
	static real getCoef(Entity entity, integer key){
		return _cache_coef[entity]![key]!
	}

	/*
	 * Retourne la durée effective d'un effet en tenant compte de:
	 * - La durée infinie (-1) convertie en tours restants
	 * - L'ordre de jeu (source avant/après target)
	 * - Le cap à MAX_DURATION pour les maps de mitigation
	 * @param rawDuration durée brute de l'effet (-1 = infini, ou 0-8)
	 * @param source entité qui applique l'effet
	 * @param target entité qui reçoit l'effet
	 * @return durée effective (0 à MAX_DURATION)
	 */
	static integer getEffectiveDuration(integer rawDuration, Entity source, Entity target){
		// Cap rawDuration to valid cache range (handles raw > MAX_DURATION)
		integer cappedRaw = rawDuration == -1 ? -1 : min(rawDuration, MAX_DURATION)
		integer key = (cappedRaw + 1) * 2 + (source.turnOrder > target.turnOrder ? 1 : 0)
		return _cache_duration[key]!
	}
}