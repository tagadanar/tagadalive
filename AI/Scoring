class Scoring {
	static Map<Entity, Map<integer, real>> _cache_coef = [:] // [entity:[key:value]]
	static Map<integer, integer> _cache_duration = [:] // [(rawDuration+1)*2 + turnOrderBit : effectiveDuration]

	static integer KILL_VALUE = 1000
	static integer DEATH_VALUE = -1000
	static integer MAX_FIGHT_TURNS = 66
	static integer MAX_DURATION = 8 // max index in duration_mitigation maps

	// === Position Scoring Weights (ML-tunable) ===

	// Danger weights - how much we penalize expected damage
	static real W_DANGER_BASE = 1.0           // base danger penalty per HP of damage
	static real W_DANGER_LOW_HP = 2.0         // multiplier when life < 60%
	static real W_DANGER_CRITICAL = 3.0       // multiplier when danger > life/2

	// Proximity weights - penalty for nearby enemies (excluding primary target)
	static real W_PROXIMITY_AREA1 = 150.0     // adjacent cell (distance 1)
	static real W_PROXIMITY_AREA2 = 20.0      // distance 2
	static real W_PROXIMITY_AREA3 = 10.0      // distance 3

	// Gravity weights - attraction to allies based on their role
	static real W_GRAVITY_ALLY_SUMMON = 80.0  // we're a summon, stay close to master
	static real W_GRAVITY_ALLY_SNC600 = 40.0  // high science ally (buffer/healer)
	static real W_GRAVITY_ALLY_SNC400 = 25.0  // science ally
	static real W_GRAVITY_ALLY_WIS400 = 25.0  // wisdom ally
	static real W_GRAVITY_ALLY_RST200 = 10.0  // tanky ally
	static real W_GRAVITY_ALLY_WIS200 = 8.0   // wisdom ally (lower)
	static real W_GRAVITY_ALLY_DEFAULT = 1.0  // default ally attraction

	// Bulb-specific gravity
	static real W_GRAVITY_METALLIC_NEED_ARMOR = 80.0  // metallic bulb when we need shields
	static real W_GRAVITY_METALLIC_DEFAULT = 6.0      // metallic bulb normally
	static real W_GRAVITY_HEALER_NEED_HEAL = 40.0     // healer bulb when hurt
	static real W_GRAVITY_HEALER_DEFAULT = 5.0        // healer bulb normally

	// Tactical weights
	static real W_LOCK_BONUS = 500.0          // bonus for locking enemy (only adjacent cell)
	static real W_CAC_IN_RANGE = 1000.0       // bonus if enemy can reach us for melee (we're CAC)
	static real W_COVID_LEEK = 10000.0      // big bonus for being near uninfected enemy leek
	static real W_COVID_SUMMON = 1000.0     // bonus for being near uninfected enemy summon

	// Shield weights - value of keeping shields active
	static real W_SHIELD_ABS = 3.0            // value per point of absolute shield
	static real W_SHIELD_REL = 6.0            // value per point of relative shield

	// MP efficiency
	static real W_MP_EFFICIENCY = 1.0         // bonus per MP saved

	// Distance weights for ranged vs melee
	static integer IDEAL_DIST_RANGED = -1     // calculated at first turn: self.mp + longest item range
	static integer IDEAL_DIST_CAC = 1         // ideal distance for melee (adjacent)
	static integer IDEAL_DIST_ALLY = 3        // default ideal distance to allies
	static integer IDEAL_DIST_CENTER = 4      // ideal distance to map center (cell 306)
	static integer IDEAL_DIST_METALLIC = 1    // stay close to metallic bulb
	static integer IDEAL_DIST_HEALER = 4      // healing range
	
	static Map<integer, real> defensive_duration_mitigation = [
		0 : 1.0,
		1 : 1.0,
		2 : 1.8,
		3 : 2.4,
		4 : 2.8,
		5 : 3.2,
		6 : 3.6,
		7 : 4.0,
		8 : 4.4,
	]
	
	static Map<integer, real> offensive_duration_mitigation = [
		0 : 1.0,
		1 : 1.0,
		2 : 1.8,
		3 : 2.4,
		4 : 2.8,
		5 : 3.2,
		6 : 3.6,
		7 : 4.0,
		8 : 4.4,
	]
	
	static Map<integer, Function<Entity => real>> computeCoef = [
		Stats.HP: (Entity entity) => real {
			if(Scoring._cache_coef[entity]![Stats.HP] == null) {
				real coef
				if(entity.isFriend){
					if(entity.isBulb) coef = 0.5
					else coef = 1.0
				} else {
					if(entity.isBulb) coef = -0.5
					else coef = -1.0
				}
				Scoring._cache_coef[entity]![Stats.HP] = coef
			}
			return Scoring._cache_coef[entity]![Stats.HP]!
		}
	]
	
	/*
	 * initialise les coefs de tout le monde, dummy values pour le moment, TODO function in array?
	 */
	static void refresh(){
		_cache_coef = [:]
		_cache_duration = [:]

		// Calculate IDEAL_DIST_RANGED once at first turn
		if (IDEAL_DIST_RANGED == -1) {
			integer longestRange = 0
			for (Item item in Fight.self.items) {
				if (item.maxRange > longestRange) {
					longestRange = item.maxRange
				}
			}
			IDEAL_DIST_RANGED = Fight.self.mp + longestRange
		}
		// Reduce every 10 turn to avoid stalemate
		if(getTurn()%10 == 0) IDEAL_DIST_RANGED--;

		// Pre-compute effective durations for all raw values (-1 to MAX_DURATION)
		// Key formula: (rawDuration + 1) * 2 + (sourceAfterTarget ? 1 : 0)
		integer turnsLeft = MAX_FIGHT_TURNS - getTurn()
		for(integer raw = -1; raw <= MAX_DURATION; raw++){
			// For finite durations, cap to turnsLeft (can't benefit longer than fight lasts)
			integer base = raw == -1 ? turnsLeft : min(raw, turnsLeft)
			base = min(base, MAX_DURATION)
			// source plays before target → target gets full duration
			_cache_duration[(raw + 1) * 2] = max(base, 0)
			// source plays after target → target gets 1 less turn
			_cache_duration[(raw + 1) * 2 + 1] = max(base - 1, 0)
		}
		for(Entity entity in Fight.getAllAlive()){
			_cache_coef[entity] = [:]
			_cache_coef[entity]![Stats.HP] = entity.isFriend ? (entity.isBulb ? 0.5 : 1.0) 
																: (entity.isBulb ? -0.5 : -1.5) 
			_cache_coef[entity]![Stats.HPTIME] = entity.isFriend ? (entity.isBulb ? 0.2 : 1.0)
																	: (entity.isBulb ? -0.2 : -1.0)
			_cache_coef[entity]![Stats.HPMAX] = entity.isFriend ? (entity.isBulb ? 0.2 : 1.8)
																	: (entity.isBulb ? -0.2 : -1.0)
			_cache_coef[entity]![Stats.DEBUFF] = entity.isFriend ? (entity.isBulb ? 0.2 : 1.0)
																	: (entity.isBulb ? -0.2 : -1.0)
			_cache_coef[entity]![Stats.ANTIDOTE] = entity.isFriend ? (entity.isBulb ? 0.2 : 1.0)
																	: (entity.isBulb ? -0.2 : -1.0)
			_cache_coef[entity]![Stats.ABSSHIELD] = entity.isFriend ? (entity.isBulb ? 0.6 : 3.0)
																	: (entity.isBulb ? -0.6 : -3.0)
			_cache_coef[entity]![Stats.RELSHIELD] = entity.isFriend ? (entity.isBulb ? 1.2 : 6.0)
																	: (entity.isBulb ? -1.2 : -6.0)
			_cache_coef[entity]![Stats.DMGRETURN] = entity.isFriend ? (entity.isBulb ? 0.6 : 3.0)
																	: (entity.isBulb ? -0.6 : -3.0)
			_cache_coef[entity]![Stats.STR] = entity.isFriend ? (entity.isBulb ? 0.2 : 1.0)
																	: (entity.isBulb ? -0.2 : -1.0)
			_cache_coef[entity]![Stats.MGC] = entity.isFriend ? (entity.isBulb ? 0.2 : 1.0)
																	: (entity.isBulb ? -0.2 : -1.0)
			_cache_coef[entity]![Stats.RST] = entity.isFriend ? (entity.isBulb ? 0.2 : 1.0)
																	: (entity.isBulb ? -0.2 : -1.0)
			_cache_coef[entity]![Stats.WSD] = entity.isFriend ? (entity.isBulb ? 0.2 : 1.2)
																	: (entity.isBulb ? -0.2 : -1.0)
			_cache_coef[entity]![Stats.AGI] = entity.isFriend ? (entity.isBulb ? 0.2 : 1.0)
																	: (entity.isBulb ? -0.2 : -1.0)
			_cache_coef[entity]![Stats.TP] = entity.isFriend ? (entity.isBulb ? 4.0 : 40.0)
																	: (entity.isBulb ? -4.0 : -40.0)
			_cache_coef[entity]![Stats.MP] = entity.isFriend ? (entity.isBulb ? 4.0 : 40.0)
																	: (entity.isBulb ? -4.0 : -40.0)
			_cache_coef[entity]![Stats.PWR] = entity.isFriend ? (entity.isBulb ? 0.2 : 1.0)
																	: (entity.isBulb ? -0.2 : -1.0)
			// fonctionnement à part, peut être que ça restera pas ça...
			_cache_coef[entity]![Stats.KILL] = entity.isFriend ? (entity.isBulb ? -0.2 : -1.0)
																	: (entity.isBulb ? 0.2 : 1.0)
		}
	}
	
	/*
	 * retourne le coef d'une entity pour la key donnée
	 */
	static real getCoef(Entity entity, integer key){
		return _cache_coef[entity]![key]!
	}

	/*
	 * Retourne la durée effective d'un effet en tenant compte de:
	 * - La durée infinie (-1) convertie en tours restants
	 * - L'ordre de jeu (source avant/après target)
	 * - Le cap à MAX_DURATION pour les maps de mitigation
	 * @param rawDuration durée brute de l'effet (-1 = infini, ou 0-8)
	 * @param source entité qui applique l'effet
	 * @param target entité qui reçoit l'effet
	 * @return durée effective (0 à MAX_DURATION)
	 */
	static integer getEffectiveDuration(integer rawDuration, Entity source, Entity target){
		// Cap rawDuration to valid cache range (handles raw > MAX_DURATION)
		integer cappedRaw = rawDuration == -1 ? -1 : min(rawDuration, MAX_DURATION)
		integer key = (cappedRaw + 1) * 2 + (source.turnOrder > target.turnOrder ? 1 : 0)
		return _cache_duration[key]!
	}
}