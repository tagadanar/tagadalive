class Scoring {
	static Map<Entity, Map<integer, real>> _cache_coef = [:] // [entity:[key:value]]
	static Map<integer, integer> _cache_duration = [:] // [(rawDuration+1)*2 + turnOrderBit : effectiveDuration]

	static integer KILL_VALUE = 1000
	static integer DEATH_VALUE = -1000
	static integer MAX_FIGHT_TURNS = 66
	static integer MAX_DURATION = 8 // max index in duration_mitigation maps

	// === Entity Type Coefficients ===
	// Format: [LEEK, BULB, TURRET, CHEST, MOB] - positive for allies, negated for enemies
	// For now: TURRET, CHEST, MOB use same values as LEEK
	static Map<integer, Array<real>> baseCoefs = [
		Stats.HP:        [1.0,  0.5,  1.0,  1.0,  1.0],
		Stats.HPTIME:    [1.0,  0.2,  1.0,  1.0,  1.0],
		Stats.HPMAX:     [2.0,  0.1,  2.0,  2.0,  2.0],
		Stats.DEBUFF:    [1.0,  0.2,  1.0,  1.0,  1.0],
		Stats.ANTIDOTE:  [1.0,  0.2,  1.0,  1.0,  1.0],
		Stats.ABSSHIELD: [3.0,  0.6,  3.0,  3.0,  3.0],
		Stats.RELSHIELD: [6.0,  1.2,  6.0,  6.0,  6.0],
		Stats.DMGRETURN: [3.0,  0.6,  3.0,  3.0,  3.0],
		Stats.STR:       [1.0,  0.2,  1.0,  1.0,  1.0],
		Stats.MGC:       [1.0,  0.2,  1.0,  1.0,  1.0],
		Stats.RST:       [0.5,  0.1,  0.5,  0.5,  0.5],
		Stats.WSD:       [0.5,  0.1,  0.5,  0.5,  0.5],
		Stats.AGI:       [0.5,  0.1,  0.5,  0.5,  0.5],
		Stats.TP:        [40.0, 4.0,  40.0, 40.0, 40.0],
		Stats.MP:        [40.0, 4.0,  40.0, 40.0, 40.0],
		Stats.PWR:       [1.0,  0.2,  1.0,  1.0,  1.0],
		Stats.KILL:      [1.0,  0.2,  1.0,  1.0,  1.0],
	]

	/*
	 * Returns coefficient for a stat based on entity type and allegiance
	 * @param entity The entity to get coefficient for
	 * @param stat The stat type (Stats.HP, Stats.STR, etc.)
	 * @return Positive for allies, negative for enemies
	 */
	static real getStatCoef(Entity entity, integer stat) {
		// Map entity type to array index: LEEK=0, BULB=1, TURRET=2, CHEST=3, MOB=4
		integer idx
		if (entity.entityType == ENTITY_LEEK) idx = 0
		else if (entity.entityType == ENTITY_BULB) idx = 1
		else if (entity.entityType == ENTITY_TURRET) idx = 2
		else if (entity.entityType == ENTITY_CHEST) idx = 3
		else idx = 4 // ENTITY_MOB or unknown

		real base = baseCoefs[stat]![idx]

		// KILL is inverted: killing enemy = good, losing ally = bad
		if (stat == Stats.KILL) {
			return entity.isFriend ? -base : base
		}
		return entity.isFriend ? base : -base
	}

	// === Position Scoring Weights (ML-tunable) ===

	// Danger weights - how much we penalize expected damage
	static real W_DANGER_BASE = 1.0           // base danger penalty per HP of damage
	static real W_DANGER_LOW_HP = 1.5         // multiplier when life < 60%
	static real W_DANGER_CRITICAL = 2.0       // multiplier when danger > life/2

	// Proximity weights - penalty for nearby enemies (excluding primary target)
	static real W_PROXIMITY_AREA1 = 150.0     // adjacent cell (distance 1)
	static real W_PROXIMITY_AREA2 = 20.0      // distance 2
	static real W_PROXIMITY_AREA3 = 10.0      // distance 3

	// Gravity weights - attraction to allies based on their role
	static real W_GRAVITY_ALLY_SUMMON = 80.0  // we're a summon, stay close to master
	static real W_GRAVITY_ALLY_SNC600 = 40.0  // high science ally (buffer/healer)
	static real W_GRAVITY_ALLY_SNC400 = 25.0  // science ally
	static real W_GRAVITY_ALLY_WIS400 = 25.0  // wisdom ally
	static real W_GRAVITY_ALLY_RST200 = 10.0  // tanky ally
	static real W_GRAVITY_ALLY_WIS200 = 8.0   // wisdom ally (lower)
	static real W_GRAVITY_ALLY_DEFAULT = 1.0  // default ally attraction

	// Bulb-specific gravity
	static real W_GRAVITY_METALLIC_NEED_ARMOR = 80.0  // metallic bulb when we need shields
	static real W_GRAVITY_METALLIC_DEFAULT = 6.0      // metallic bulb normally
	static real W_GRAVITY_HEALER_NEED_HEAL = 40.0     // healer bulb when hurt
	static real W_GRAVITY_HEALER_DEFAULT = 5.0        // healer bulb normally

	// Tactical weights
	static real W_LOCK_BONUS = 500.0          // bonus for locking enemy (only adjacent cell)
	static real W_CAC_IN_RANGE = 1000.0       // bonus if enemy can reach us for melee (we're CAC)
	static real W_COVID_LEEK = 10000.0      // big bonus for being near uninfected enemy leek
	static real W_COVID_SUMMON = 1000.0     // bonus for being near uninfected enemy summon

	// Shield weights - value of keeping shields active
	static real W_SHIELD_ABS = 3.0            // value per point of absolute shield
	static real W_SHIELD_REL = 6.0            // value per point of relative shield

	// Distance weights for ranged vs melee
	static integer IDEAL_DIST_RANGED = -1     // calculated at first turn: self.mp + longest item range
	static integer IDEAL_DIST_CAC = 1         // ideal distance for melee (adjacent)
	static integer IDEAL_DIST_ALLY = 3        // default ideal distance to allies
	static integer IDEAL_DIST_CENTER = 4      // ideal distance to map center (cell 306)
	static integer IDEAL_DIST_METALLIC = 1    // stay close to metallic bulb
	static integer IDEAL_DIST_HEALER = 4      // healing range
	
	static Map<integer, real> defensive_duration_mitigation = [
		0 : 1.0,
		1 : 1.0,
		2 : 1.8,
		3 : 2.4,
		4 : 2.8,
		5 : 3.2,
		6 : 3.6,
		7 : 4.0,
		8 : 4.4,
	]
	
	static Map<integer, real> offensive_duration_mitigation = [
		0 : 1.0,
		1 : 1.0,
		2 : 1.8,
		3 : 2.4,
		4 : 2.8,
		5 : 3.2,
		6 : 3.6,
		7 : 4.0,
		8 : 4.4,
	]
	
	/*
	 * Initialise les coefs de toutes les entités en vie.
	 * Appelé à chaque tour.
	 */
	static void refresh(){
		_cache_coef = [:]
		_cache_duration = [:]

		// Calculate IDEAL_DIST_RANGED once at first turn
		if (IDEAL_DIST_RANGED == -1) {
			integer longestRange = 0
			for (Item item in Fight.self.items) {
				if (item.maxRange > longestRange) {
					longestRange = item.maxRange
				}
			}
			IDEAL_DIST_RANGED = Fight.self.mp + longestRange
		}
		// Reduce every 10 turn to avoid stalemate
		if(getTurn()%5 == 0) IDEAL_DIST_RANGED--;

		// Pre-compute effective durations for all raw values (-1 to MAX_DURATION)
		// Key formula: (rawDuration + 1) * 2 + (sourceAfterTarget ? 1 : 0)
		integer turnsLeft = MAX_FIGHT_TURNS - getTurn()
		for(integer raw = -1; raw <= MAX_DURATION; raw++){
			// For finite durations, cap to turnsLeft (can't benefit longer than fight lasts)
			integer base = raw == -1 ? turnsLeft : min(raw, turnsLeft)
			base = min(base, MAX_DURATION)
			// source plays before target → target gets full duration
			_cache_duration[(raw + 1) * 2] = max(base, 0)
			// source plays after target → target gets 1 less turn
			_cache_duration[(raw + 1) * 2 + 1] = max(base - 1, 0)
		}
		for(Entity entity in Fight.getAllAlive()){
			_cache_coef[entity] = [:]
			_cache_coef[entity]![Stats.HP] = getStatCoef(entity, Stats.HP)
			_cache_coef[entity]![Stats.HPTIME] = getStatCoef(entity, Stats.HPTIME)
			_cache_coef[entity]![Stats.HPMAX] = getStatCoef(entity, Stats.HPMAX)
			_cache_coef[entity]![Stats.DEBUFF] = getStatCoef(entity, Stats.DEBUFF)
			_cache_coef[entity]![Stats.ANTIDOTE] = getStatCoef(entity, Stats.ANTIDOTE)
			_cache_coef[entity]![Stats.ABSSHIELD] = getStatCoef(entity, Stats.ABSSHIELD)
			_cache_coef[entity]![Stats.RELSHIELD] = getStatCoef(entity, Stats.RELSHIELD)
			_cache_coef[entity]![Stats.DMGRETURN] = getStatCoef(entity, Stats.DMGRETURN)
			_cache_coef[entity]![Stats.STR] = getStatCoef(entity, Stats.STR)
			_cache_coef[entity]![Stats.MGC] = getStatCoef(entity, Stats.MGC)
			_cache_coef[entity]![Stats.RST] = getStatCoef(entity, Stats.RST)
			_cache_coef[entity]![Stats.WSD] = getStatCoef(entity, Stats.WSD)
			_cache_coef[entity]![Stats.AGI] = getStatCoef(entity, Stats.AGI)
			_cache_coef[entity]![Stats.TP] = getStatCoef(entity, Stats.TP)
			_cache_coef[entity]![Stats.MP] = getStatCoef(entity, Stats.MP)
			_cache_coef[entity]![Stats.PWR] = getStatCoef(entity, Stats.PWR)
			_cache_coef[entity]![Stats.KILL] = getStatCoef(entity, Stats.KILL)
		}
	}
	
	/*
	 * retourne le coef d'une entity pour la key donnée
	 */
	static real getCoef(Entity entity, integer key){
		return _cache_coef[entity]![key]!
	}

	/*
	 * Retourne la durée effective d'un effet en tenant compte de:
	 * - La durée infinie (-1) convertie en tours restants
	 * - L'ordre de jeu (source avant/après target)
	 * - Le cap à MAX_DURATION pour les maps de mitigation
	 * @param rawDuration durée brute de l'effet (-1 = infini, ou 0-8)
	 * @param source entité qui applique l'effet
	 * @param target entité qui reçoit l'effet
	 * @return durée effective (0 à MAX_DURATION)
	 */
	static integer getEffectiveDuration(integer rawDuration, Entity source, Entity target){
		// Cap rawDuration to valid cache range (handles raw > MAX_DURATION)
		integer cappedRaw = rawDuration == -1 ? -1 : min(rawDuration, MAX_DURATION)
		integer key = (cappedRaw + 1) * 2 + (source.turnOrder > target.turnOrder ? 1 : 0)
		return _cache_duration[key]!
	}
}