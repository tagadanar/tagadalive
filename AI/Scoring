/*
 * Scoring - Main façade for action scoring system
 *
 * Provides cached coefficients and duration calculations for action evaluation.
 * Contains getDynamicCoef() which uses ScoringModifiers for coefficient adjustments.
 *
 * Architecture:
 * - ScoringConfig: ML-tunable constants and weights
 * - Entity: Bulb type constants (BULB_FIRE, etc.) and extendedType field
 * - EntityCoefs: Base coefficient tables per entity type
 * - BattleState: Per-turn team state (composition, flags, ratios)
 * - ScoringModifiers: Pure modifier functions
 * - Scoring: This class - façade, caches, and getDynamicCoef
 *
 * Used by: Consequences, MapAction, AI, MCTS
 */
class Scoring {

	// === Caches (recomputed each turn) ===
	static Map<Entity, Map<integer, real>> _cache_coef = [:] // [entity:[stat:coef]]
	static Map<integer, integer> _cache_duration = [:]       // [key:effectiveDuration]

	// === Dynamic Position Weights (computed in refresh) ===
	static real W_LOCK_BONUS = 1000.0         // bonus for locking enemy
	static integer IDEAL_DIST_RANGED = -1     // calculated at first turn: self.mp + longest item range

	/*
	 * Initialize all scoring data for the current turn.
	 * Delegates team state to BattleState, then computes local caches.
	 * Called once per turn before action evaluation.
	 */
	static void refresh() {
		// === Delegate team state computation to BattleState ===
		BattleState.refresh()

		// === Reset local caches ===
		_cache_coef = [:]
		_cache_duration = [:]

		// === Compute dynamic position weights ===
		// W_LOCK_BONUS: reduced when vulnerable (prioritize survival over locking)
		boolean notShielded = Fight.self.absShield <= 0 && Fight.self.relShield <= 0
		boolean notFullLife = Fight.self.life < Fight.self.totalLife
		if ((notShielded && BattleState.enemyHasStr) || notFullLife) {
			W_LOCK_BONUS = 500.0
		} else {
			W_LOCK_BONUS = 1000.0
		}

		// IDEAL_DIST_RANGED: calculated once at first turn, reduced every 5 turns
		if (IDEAL_DIST_RANGED == -1) {
			integer longestRange = 0
			for (Item item in Fight.self.items) {
				if (item.maxRange > longestRange) {
					longestRange = item.maxRange
				}
			}
			IDEAL_DIST_RANGED = Fight.self.mp + longestRange
		}
		if (getTurn() % 5 == 0) IDEAL_DIST_RANGED--

		// === Pre-compute effective durations ===
		// Key formula: (rawDuration + 1) * 2 + (sourceAfterTarget ? 1 : 0)
		integer turnsLeft = ScoringConfig.MAX_FIGHT_TURNS - getTurn()
		for (integer raw = -1; raw <= ScoringConfig.MAX_DURATION; raw++) {
			integer base = raw == -1 ? turnsLeft : min(raw, turnsLeft)
			base = min(base, ScoringConfig.MAX_DURATION)
			// source plays before target → target gets full duration
			_cache_duration[(raw + 1) * 2] = max(base, 0)
			// source plays after target → target gets 1 less turn
			_cache_duration[(raw + 1) * 2 + 1] = max(base - 1, 0)
		}

		// === Pre-compute base coefficients for all entities ===
		for (Entity entity in Fight.getAllAlive()) {
			_cache_coef[entity] = [:]
			_cache_coef[entity]![Stats.HP] = EntityCoefs.getStatCoef(entity, Stats.HP)
			_cache_coef[entity]![Stats.HPTIME] = EntityCoefs.getStatCoef(entity, Stats.HPTIME)
			_cache_coef[entity]![Stats.HPMAX] = EntityCoefs.getStatCoef(entity, Stats.HPMAX)
			_cache_coef[entity]![Stats.DEBUFF] = EntityCoefs.getStatCoef(entity, Stats.DEBUFF)
			_cache_coef[entity]![Stats.ANTIDOTE] = EntityCoefs.getStatCoef(entity, Stats.ANTIDOTE)
			_cache_coef[entity]![Stats.ABSSHIELD] = EntityCoefs.getStatCoef(entity, Stats.ABSSHIELD)
			_cache_coef[entity]![Stats.RELSHIELD] = EntityCoefs.getStatCoef(entity, Stats.RELSHIELD)
			_cache_coef[entity]![Stats.DMGRETURN] = EntityCoefs.getStatCoef(entity, Stats.DMGRETURN)
			_cache_coef[entity]![Stats.STR] = EntityCoefs.getStatCoef(entity, Stats.STR)
			_cache_coef[entity]![Stats.MGC] = EntityCoefs.getStatCoef(entity, Stats.MGC)
			_cache_coef[entity]![Stats.RST] = EntityCoefs.getStatCoef(entity, Stats.RST)
			_cache_coef[entity]![Stats.WSD] = EntityCoefs.getStatCoef(entity, Stats.WSD)
			_cache_coef[entity]![Stats.AGI] = EntityCoefs.getStatCoef(entity, Stats.AGI)
			_cache_coef[entity]![Stats.TP] = EntityCoefs.getStatCoef(entity, Stats.TP)
			_cache_coef[entity]![Stats.MP] = EntityCoefs.getStatCoef(entity, Stats.MP)
			_cache_coef[entity]![Stats.PWR] = EntityCoefs.getStatCoef(entity, Stats.PWR)
			_cache_coef[entity]![Stats.KILL] = EntityCoefs.getStatCoef(entity, Stats.KILL)
		}
	}

	/*
	 * Returns cached base coefficient for an entity and stat
	 * @param entity The entity
	 * @param key The stat type (Stats.HP, Stats.STR, etc.)
	 * @return Base coefficient (positive for allies, negative for enemies)
	 */
	static real getCoef(Entity entity, integer key) {
		return _cache_coef[entity]![key]!
	}

	/*
	 * Checks if an ally might die before their next turn
	 * Uses cached danger and current HP (accounting for consequences)
	 * @param entity The ally to check
	 * @param consequences Optional consequences for current HP calculation
	 * @return true if entity might die before they can act
	 */
	static boolean canDie(Entity entity, Consequences? consequences) {
		real? danger = BattleState.allyDanger[entity]
		if (danger == null) return false
		integer currentHP = entity.getCurrentHP(consequences)
		return currentHP < danger! * ScoringConfig.CANDIE_THRESHOLD
	}

	/*
	 * Returns dynamic coefficient with all modifiers applied
	 * Uses ScoringModifiers for individual modifier calculations
	 * @param entity The entity to get coefficient for
	 * @param stat The stat type (Stats.HP, Stats.STR, etc.)
	 * @param consequences Optional consequences to check current HP
	 * @return Coefficient with dynamic modifiers applied
	 */
	static real getDynamicCoef(Entity entity, integer stat, Consequences? consequences) {
		real base = getCoef(entity, stat)  // use cached base coefficient

		// Apply lifeRatio modifier to HP-related stats (both allies and enemies)
		if (stat == Stats.HP || stat == Stats.HPTIME) {
			base *= ScoringModifiers.getLifeRatioModifier(entity)

			// Apply winning modifier for allies (care less about HP when winning and safe)
			if (entity.isFriend) {
				base *= ScoringModifiers.getWinningModifier()
			}
		}

		// Apply modifiers for allies only (not self, not enemies)
		if (entity.isFriend && entity != Fight.self) {
			// canDie modifier: massive boost when ally might die
			if (stat == Stats.HP || stat == Stats.HPTIME || stat == Stats.ABSSHIELD || stat == Stats.RELSHIELD) {
				if (canDie(entity, consequences)) {
					base *= ScoringConfig.CANDIE_MODIFIER
				}
			}

			// levelRatio modifier: more valuable to buff high-level allies
			// Applies to heals, shields, and stat buffs
			if (stat == Stats.HP || stat == Stats.HPMAX || stat == Stats.ANTIDOTE ||
			    stat == Stats.ABSSHIELD || stat == Stats.RELSHIELD ||
			    stat == Stats.MGC || stat == Stats.MP || stat == Stats.AGI ||
			    stat == Stats.WSD || stat == Stats.RST) {
				base *= ScoringModifiers.getLevelRatioModifier(entity)
			}

			// maxHP comparison modifier: low maxHP allies benefit more from HPMAX boosts
			if (stat == Stats.HPMAX) {
				base *= ScoringModifiers.getMaxHPComparisonModifier(entity)
			}

			// teamComp modifier: adjust shield value based on team synergy (allies)
			if (stat == Stats.ABSSHIELD || stat == Stats.RELSHIELD) {
				base *= ScoringModifiers.getTeamCompModifier(entity, stat)
			}
		}

		// teamComp modifier for enemies: removing shields more valuable with offensive bulbs
		if (!entity.isFriend) {
			if (stat == Stats.ABSSHIELD || stat == Stats.RELSHIELD) {
				base *= ScoringModifiers.getTeamCompModifier(entity, stat)
			}
		}

		// shieldStatus modifier: adjust based on current shield levels
		if (BattleState.enemyHasStr && (stat == Stats.ABSSHIELD || stat == Stats.RELSHIELD)) {
			base *= ScoringModifiers.getShieldStatusModifier(entity, stat)
		}

		// STR/MGC modifier for allies: scales with current stat, prefer boosting allies over self
		if (entity.isFriend && (stat == Stats.STR || stat == Stats.MGC)) {
			integer currentStat = (stat == Stats.STR) ? entity.str : entity.mgc
			base *= ScoringModifiers.getStatScalingModifier(currentStat)
			// Prefer boosting allies over self
			if (entity != Fight.self) {
				base *= 1.1
			}
		}

		// TP modifier for allies: more valuable for high STR/MGC entities
		if (entity.isFriend && stat == Stats.TP) {
			base *= ScoringModifiers.getTPModifier(entity)
			// Prefer boosting allies over self
			if (entity != Fight.self) {
				base *= 1.1
			}
		}

		// AGI modifier for allies: bell curve with peak at 700
		if (entity.isFriend && stat == Stats.AGI) {
			base *= ScoringModifiers.getAGIModifier(entity)
			// Prefer boosting allies over self
			if (entity != Fight.self) {
				base *= 1.1
			}
		}

		// WSD/RST modifier for allies: more valuable when relevant chips are ready
		// Scale: 0.5x at 0 chips, 1.0x at 1, 1.5x at 3+
		if (entity.isFriend && (stat == Stats.WSD || stat == Stats.RST)) {
			base *= ScoringModifiers.getChipReadyModifier(entity, stat)
			// Prefer boosting allies over self
			if (entity != Fight.self) {
				base *= 1.1
			}
		}

		// MP modifier for allies: more valuable for high STR/MGC, and when low MP
		if (entity.isFriend && stat == Stats.MP) {
			base *= ScoringModifiers.getMPModifier(entity)
			// Prefer boosting allies over self
			if (entity != Fight.self) {
				base *= 1.1
			}
		}

		// DMGRETURN modifier for allies: valuable when enemy has STR, scaling with current level
		if (entity.isFriend && stat == Stats.DMGRETURN) {
			base *= ScoringModifiers.getDMGReturnModifier(entity)
		}

		return base
	}

	/*
	 * Returns effective duration of an effect considering:
	 * - Infinite duration (-1) converted to remaining turns
	 * - Turn order (source before/after target)
	 * - Cap to ScoringConfig.MAX_DURATION for mitigation maps
	 * @param rawDuration Raw effect duration (-1 = infinite, or 0-8)
	 * @param source Entity applying the effect
	 * @param target Entity receiving the effect
	 * @return Effective duration (0 to ScoringConfig.MAX_DURATION)
	 */
	static integer getEffectiveDuration(integer rawDuration, Entity source, Entity target) {
		// Cap rawDuration to valid cache range (handles raw > ScoringConfig.MAX_DURATION)
		integer cappedRaw = rawDuration == -1 ? -1 : min(rawDuration, ScoringConfig.MAX_DURATION)
		integer key = (cappedRaw + 1) * 2 + (source.turnOrder > target.turnOrder ? 1 : 0)
		return _cache_duration[key]!
	}
}
