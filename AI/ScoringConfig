/*
 * ScoringConfig - Configuration and constants for the scoring system
 *
 * Contains all ML-tunable weights, thresholds, and duration mitigation tables.
 * Centralizes configuration for easy tuning and experimentation.
 *
 * Used by: Scoring, ScoringModifiers, MapPosition, Position
 *
 * ┌─────────────────────────────────────────────────────────────────────────┐
 * │ POSITION SCORING ARCHITECTURE (3-file split):                          │
 * │  • AI/ScoringConfig (this file): Weight constants and thresholds       │
 * │  • Model/Combos/Position: Position class with score components         │
 * │  • Controlers/Maps/MapPosition: Search algorithm for best position     │
 * └─────────────────────────────────────────────────────────────────────────┘
 */
class ScoringConfig {

	// === Performance vs Accuracy Trade-off ===
	// When false: coefficients pre-computed at turn start (fast, ~4x fewer ops)
	// When true: coefficients computed dynamically using simulated HP (accurate, slower)
	static boolean DYNAMIC_COEFS = false

	// === Combat Values ===
	static integer KILL_VALUE = 5000
	static integer DEATH_VALUE = -5000
	static integer MAX_FIGHT_TURNS = 66
	static integer MAX_DURATION = 8 // max index in duration_mitigation maps

	// === CanDie Thresholds ===
	static real CANDIE_MODIFIER = 5.0   // massive boost when ally might die
	static real CANDIE_THRESHOLD = 0.8   // ally.hp < danger * threshold → canDie

	static real getIgnoreDangerRatio(Entity entity) {
		real winMod = ScoringModifiers.getWinningModifier()
		if (entity.isBulb) {
			// Bulb: 0.8 when losing/even, scale to 1.0 when winning
			if (winMod <= 1.0) return 0.8
			return min(1.0, 0.8 + 0.4 * (winMod - 1.0))  // 1.0 → 0.8, 1.5 → 1.0
		}
		if (winMod < 1) return 0.1
		return 0.1 + (winMod - 1)  // 1.0 → 0.1, 1.5 → 0.6
	}

	// === Ally Modifier ===
	// Slight boost for buffing allies (not self) - they benefit from our support
	static real ALLY_BUFF_MODIFIER = 1.1

	// === All Stats (for iteration) ===
	static Array<integer> ALL_STATS = [
		Stats.HP, Stats.HPTIME, Stats.HPMAX, Stats.DEBUFF, Stats.ANTIDOTE,
		Stats.ABSSHIELD, Stats.RELSHIELD, Stats.DMGRETURN,
		Stats.STR, Stats.MGC, Stats.RST, Stats.WSD, Stats.AGI,
		Stats.TP, Stats.MP, Stats.PWR, Stats.KILL
	]

	// === Chip Maps for WSD/RST Modifiers (O(1) lookup) ===
	static Map<integer, boolean> WSD_CHIPS = [CHIP_ELEVATION: true, CHIP_CURE: true, CHIP_VACCINE: true, CHIP_ARMORING: true, CHIP_REMISSION: true]
	static Map<integer, boolean> RST_CHIPS = [CHIP_HELMET: true, CHIP_SHIELD: true, CHIP_ARMOR: true, CHIP_WALL: true, CHIP_FORTRESS: true]

	// === Position Scoring Weights (ML-tunable) ===

	// Danger weights - how much we penalize expected damage
	static real W_DANGER_BASE = 1.0           // base danger penalty per HP of damage
	static real W_DANGER_LOW_HP = 1.5         // multiplier when life < 60%
	static real W_DANGER_CRITICAL = 2.0       // multiplier when danger > life/2

	// Proximity weights - penalty for nearby enemies (excluding primary target)
	static real W_PROXIMITY_AREA1 = 150.0     // adjacent cell (distance 1)
	static real W_PROXIMITY_AREA2 = 20.0      // distance 2
	static real W_PROXIMITY_AREA3 = 10.0      // distance 3

	// Tactical weights
	// Note: W_LOCK_BONUS is in Scoring (dynamically computed in refresh)
	static real W_CAC_IN_RANGE = 1000.0       // bonus if enemy can reach us for melee (we're CAC)
	static real W_COVID_LEEK = 10000.0        // big bonus for being near uninfected enemy leek
	static real W_COVID_SUMMON = 1000.0       // bonus for being near uninfected enemy summon

	// === Distance Weights ===
	// Note: IDEAL_DIST_RANGED is in Scoring (dynamically computed in refresh)
	static integer IDEAL_DIST_CAC = 1         // ideal distance for melee (adjacent)
	static integer IDEAL_DIST_ALLY = 3        // default ideal distance to allies/turret
	static integer IDEAL_DIST_CENTER = 4      // ideal distance to map center (cell 306)

	// === Duration Mitigation Tables ===
	// Maps effect duration to value multiplier (diminishing returns for long durations)

	static Map<integer, real> defensive_duration_mitigation = [
		0 : 1.0,
		1 : 1.0,
		2 : 1.8,
		3 : 2.4,
		4 : 2.8,
		5 : 3.2,
		6 : 3.6,
		7 : 4.0,
		8 : 4.4
	]

	static Map<integer, real> offensive_duration_mitigation = [
		0 : 1.0,
		1 : 1.0,
		2 : 1.8,
		3 : 2.4,
		4 : 2.8,
		5 : 3.2,
		6 : 3.6,
		7 : 4.0,
		8 : 4.4
	]

	// === Summon Values ===
	// Base value per bulb type (modified by turns remaining and duplicate count)
	static real SUMMON_VALUE_DEFAULT = 500.0
	static Map<integer, real> SUMMON_VALUES = [
		Entity.BULB_FIRE: 900.0,
		Entity.BULB_HEALER: 1000.0,
		Entity.BULB_METALLIC: 1200.0,
		Entity.BULB_ICED: 800.0,
		Entity.BULB_LIGHTNING: 1000.0,
		Entity.BULB_ROCKY: 600.0,
		Entity.BULB_WIZARD: 800.0,
		Entity.BULB_PUNY: 200.0,
		Entity.BULB_TACTICIAN: 1000.0,
		Entity.BULB_SAVANT: 800.0,
	]

	static integer getBulbTypeFromChip(integer chipId) {
		if (chipId == CHIP_FIRE_BULB) return Entity.BULB_FIRE
		if (chipId == CHIP_HEALER_BULB) return Entity.BULB_HEALER
		if (chipId == CHIP_METALLIC_BULB) return Entity.BULB_METALLIC
		if (chipId == CHIP_ICED_BULB) return Entity.BULB_ICED
		if (chipId == CHIP_LIGHTNING_BULB) return Entity.BULB_LIGHTNING
		if (chipId == CHIP_ROCKY_BULB) return Entity.BULB_ROCKY
		if (chipId == CHIP_WIZARD_BULB) return Entity.BULB_WIZARD
		if (chipId == CHIP_PUNY_BULB) return Entity.BULB_PUNY
		if (chipId == CHIP_TACTICIAN_BULB) return Entity.BULB_TACTICIAN
		if (chipId == CHIP_SAVANT_BULB) return Entity.BULB_SAVANT
		return ENTITY_BULB
	}
}
