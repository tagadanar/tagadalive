/*
 * BattleState - Combat context and team state
 *
 * Contains team composition, flags, ratios, and other contextual data
 * that is computed once per turn and used by Scoring modifiers.
 *
 * The refresh() method optimizes by combining multiple iterations into fewer loops.
 *
 * Used by: Scoring, ScoringModifiers, MapPosition
 */
class BattleState {

	// === Team Composition ===
	static integer countFire = 0      // ally fire bulbs
	static integer countMetal = 0     // ally metallic bulbs
	static integer countHealer = 0    // ally healer bulbs
	static integer countIced = 0      // ally iced bulbs
	static integer countLightning = 0 // ally lightning bulbs
	static integer countRocky = 0     // ally rocky bulbs
	static integer countWizard = 0    // ally wizard bulbs
	static integer countPuny = 0      // ally puny bulbs
	static integer countTactician = 0 // ally tactician bulbs
	static integer countSavant = 0    // ally savant bulbs
	static integer countStrBulbs = 0  // ally offensive bulbs (fire + iced + lightning + rocky)
	static integer allyLeekCount = 0 // alive ally leeks (non-bulb)

	// === Team Flags ===
	static boolean enemyHasStr = false // any enemy has STR >= 100
	static boolean enemyHasMgc = false // any enemy has MGC >= 100 (for antidote value)
	static boolean enemyHasSnc = false // any enemy has SNC >= 200 (for dmgReturn value)
	static boolean enemyHasOTK = false // any enemy has STR >= 400, AGI >= 400, SNC >= 400
	static boolean enemyHasHighAgi = false // any enemy has AGI >= 800 (bramble value in OTK)
	static boolean allyHasStr = false  // any ally has STR >= 100 (for vuln value)
	static boolean allyHasScience = false // any ally has SNC >= 200 (for rel vuln value)
	static boolean allyHasPsn = false  // any ally has MGC >= 100 (for enemy antidote map)
	static boolean allyHasRst = false  // any ally has RST >= 100 (for enemy liberation map)
	static real allyLeekMeanStr = 0.0 // mean STR of ally leeks (for enemy vuln scaling)

	// === Global State Ratios ===
	static real ratioHP = 1.0    // sum(ally life) / sum(enemy life)
	static real ratioCount = 1.0 // ally count / enemy count

	// === Ally maxHP Range (for HPMAX modifier) ===
	static integer minAllyMaxHP = 0
	static integer maxAllyMaxHP = 0

	// === Chip Readiness ===
	// Ready chip counts per ally (0.5 for cooldown=1, 1.0 for cooldown=0)
	static Map<integer, real> wsdReadyChips = [:] // entityId -> readyCount
	static Map<integer, real> rstReadyChips = [:] // entityId -> readyCount
	static Map<integer, real> agiReadyChips = [:] // entityId -> readyCount (BRAMBLE counts double)

	// === Ally Danger ===
	static Map<Entity, real> allyDanger = [:] // [ally: expectedDamageBeforeTheirTurn]

	// === Ally Damage Potential ===
	static Map<Entity, real> allyDamagePotential = [:] // [ally: estimated total raw damage output]

	// === Enemy Turn Position (relative to self) ===
	// Maps enemy â†’ position index (0 = plays first after self, higher = later)
	static Map<Entity, integer> enemyTurnPosition = [:]
	static integer enemyCount = 0
	static integer enemyLeekCount = 0

	/*
	 * Refresh all battle state data.
	 * Called once per turn before Scoring.refresh().
	 *
	 * Optimized: combines multiple loops into fewer iterations.
	 */
	static void refresh() {
		// Reset all state
		countFire = 0
		countMetal = 0
		countHealer = 0
		countIced = 0
		countLightning = 0
		countRocky = 0
		countWizard = 0
		countPuny = 0
		countTactician = 0
		countSavant = 0
		countStrBulbs = 0
		allyLeekCount = 0
		allyHasStr = false
		allyHasScience = false
		allyHasPsn = false
		allyHasRst = false
		allyLeekMeanStr = 0
		enemyHasStr = false
		enemyHasMgc = false
		enemyHasSnc = false
		enemyHasOTK = false
		enemyHasHighAgi = false
		wsdReadyChips = [:]
		rstReadyChips = [:]
		agiReadyChips = [:]
		allyDanger = [:]
		allyDamagePotential = [:]
		minAllyMaxHP = 999999
		maxAllyMaxHP = 0

		// === Combined ally loop ===
		// Handles: bulb counting, allyHasStr flag, leek STR mean, WSD/RST chips
		real sumAllyLife = 0.0
		integer sumAllyLeekStr = 0

		for (Entity entity in Fight.getAlliesAlive()) {
			// Count bulb types
			integer eType = entity.extendedType
			if (eType == Entity.BULB_FIRE) {
				countFire++
				countStrBulbs++
			} else if (eType == Entity.BULB_ICED) {
				countIced++
				countStrBulbs++
			} else if (eType == Entity.BULB_LIGHTNING) {
				countLightning++
				countStrBulbs++
			} else if (eType == Entity.BULB_METALLIC) {
				countMetal++
			} else if (eType == Entity.BULB_HEALER) {
				countHealer++
			} else if (eType == Entity.BULB_ROCKY) {
				countRocky++
				countStrBulbs++
			} else if (eType == Entity.BULB_WIZARD) {
				countWizard++
			} else if (eType == Entity.BULB_PUNY) {
				countPuny++
			} else if (eType == Entity.BULB_TACTICIAN) {
				countTactician++
			} else if (eType == Entity.BULB_SAVANT) {
				countSavant++
			}

			// Check for ally with significant strength
			if (!allyHasStr && entity.str >= 200) {
				allyHasStr = true
			}
			// Check for ally with significant science (for rel vuln value)
			if (!allyHasScience && entity.snc >= 400) {
				allyHasScience = true
			}
			// Check for ally with significant magic (for enemy antidote map)
			if (!allyHasPsn && entity.mgc >= 200) {
				allyHasPsn = true
			}
			// Check for ally with significant resistance (for enemy liberation map)
			if (!allyHasRst && entity.rst >= 200) {
				allyHasRst = true
			}

			// Count WSD/RST/AGI chips for this ally
			integer entityId = entity.id
			real wsdCount = 0.0
			real rstCount = 0.0
			real agiCount = 0.0
			for (Item item in entity.items) {
				if (item.isWeap) continue
				integer chipId = item.id

				real? wsdW = ScoringConfig.WSD_CHIPS[chipId]
				if (wsdW != null) {
					integer cd = getCooldown(chipId, entityId)!
					if (cd == 0) wsdCount += wsdW!
					else if (cd == 1) wsdCount += wsdW! * 0.5
				}
				real? rstW = ScoringConfig.RST_CHIPS[chipId]
				if (rstW != null) {
					integer cd = getCooldown(chipId, entityId)!
					if (cd == 0) rstCount += rstW!
					else if (cd == 1) rstCount += rstW! * 0.5
				}
				real? agiW = ScoringConfig.AGI_CHIPS[chipId]
				if (agiW != null) {
					integer cd = getCooldown(chipId, entityId)!
					if (cd == 0) agiCount += agiW!
					else if (cd == 1) agiCount += agiW! * 0.5
				}
			}
			wsdReadyChips[entityId] = wsdCount
			rstReadyChips[entityId] = rstCount
			agiReadyChips[entityId] = agiCount

			// For leeks only: compute ratios, maxHP range, and mean STR
			if (!entity.isBulb) {
				sumAllyLife += entity.life
				allyLeekCount++
				sumAllyLeekStr += entity.str
				if (entity.totalLife < minAllyMaxHP) minAllyMaxHP = entity.totalLife
				if (entity.totalLife > maxAllyMaxHP) maxAllyMaxHP = entity.totalLife
			}
		}

		// === Combined enemy loop ===
		// Handles: enemyHasStr flag, enemy life sum
		real sumEnemyLife = 0.0
		enemyLeekCount = 0

		for (Entity entity in Fight.getEnemiesAlive()) {
			// Check for enemy with significant strength
			if (!enemyHasStr && entity.str >= 200) {
				enemyHasStr = true
			}
			// Check for enemy with significant magic (for antidote value)
			if (!enemyHasMgc && entity.mgc >= 200) {
				enemyHasMgc = true
			}
			// Check for enemy with significant science (for dmgReturn value)
			if (!enemyHasSnc && entity.snc >= 400) {
				enemyHasSnc = true
			}
			// Check for enemy with OTK potential (high STR + AGI + SNC)
			if (!enemyHasOTK && entity.str >= 400 && entity.agi >= 400 && entity.snc >= 400) {
				enemyHasOTK = true
			}
			if (!enemyHasHighAgi && entity.agi >= 800) {
				enemyHasHighAgi = true
			}

			// For leeks only: compute ratios
			if (!entity.isBulb) {
				sumEnemyLife += entity.life
				enemyLeekCount++
			}
		}

		// Compute ratios and mean STR
		ratioHP = (sumEnemyLife > 0) ? sumAllyLife / sumEnemyLife : 1.0
		ratioCount = (enemyLeekCount > 0) ? (allyLeekCount * 1.0) / enemyLeekCount : 1.0
		allyLeekMeanStr = (allyLeekCount > 0) ? sumAllyLeekStr / allyLeekCount : 0

		// Cache enemy turn positions relative to self (0 = plays first after self)
		enemyTurnPosition = [:]
		integer pos = 0
		for (Entity e in Fight.getEntitiesAfterSelfInOrder()) {
			if (!e.isFriend) {
				enemyTurnPosition[e] = pos
				pos++
			}
		}
		enemyCount = pos
	}

	/*
	 * Returns the count of existing ally bulbs of a specific type.
	 * Used by summon scoring to reduce value of duplicate bulbs.
	 */
	static integer getBulbCount(integer bulbType) {
		if (bulbType == Entity.BULB_FIRE) return countFire
		if (bulbType == Entity.BULB_METALLIC) return countMetal
		if (bulbType == Entity.BULB_HEALER) return countHealer
		if (bulbType == Entity.BULB_ICED) return countIced
		if (bulbType == Entity.BULB_LIGHTNING) return countLightning
		if (bulbType == Entity.BULB_ROCKY) return countRocky
		if (bulbType == Entity.BULB_WIZARD) return countWizard
		if (bulbType == Entity.BULB_PUNY) return countPuny
		if (bulbType == Entity.BULB_TACTICIAN) return countTactician
		if (bulbType == Entity.BULB_SAVANT) return countSavant
		return 0
	}

	/*
	 * Computes expected danger for an ally from enemies who play before them
	 * Uses MapDanger's pre-computed damage maps
	 * @param ally The ally entity
	 * @return Expected damage the ally will take before their turn
	 */
	static real computeAllyDanger(Entity ally) {
		real totalDanger = 0.0
		// Get enemies who play before this ally
		for (Entity entity in ally.entitiesWhoPlayBefore) {
			if (entity.isFriend) continue // only enemies
			// Check each offensive item the enemy has
			Map<Item, Map<Cell, real>>? enemyMaps = MapDanger._map_entity_item_danger[entity]
			if (enemyMaps == null) continue
			integer tpLeft = entity.tp
			for (Item item in entity.offensiveItems) {
				Map<Cell, real>? itemMap = enemyMaps![item]
				if (itemMap == null) continue
				real? ratioDmg = itemMap![ally.cell]
				if (ratioDmg == null || ratioDmg <= 0) continue
				// Estimate damage from this item
				real itemDmg = Damages.getDamage(entity, ally, item, ratioDmg!, null)
				if (itemDmg > 0) {
					integer uses = 0
					while (item.cost <= tpLeft && uses < item.maxUse) {
						totalDanger += itemDmg
						tpLeft -= item.cost
						uses++
						if (item.haveCD) break
					}
				}
			}
		}
		return totalDanger
	}

	/*
	 * Compute ally danger for all allies (called after MapDanger is ready)
	 * Also sets canDie flag on each ally based on danger vs life threshold
	 */
	static void computeAllAllyDanger() {
		for (Entity entity in Fight.getAlliesAlive()) {
			if (entity != Fight.self) {
				real danger = computeAllyDanger(entity)
				allyDanger[entity] = danger
				// Set canDie flag: danger * threshold >= life means ally might die
				entity.canDie = (danger * ScoringConfig.CANDIE_THRESHOLD >= entity.life)
			}
		}
	}

	/*
	 * Estimates total raw damage an ally can deal to enemies this turn.
	 * Uses a greedy TP budget: iterates offensive items, uses each as many times as affordable.
	 * Averages damage across alive enemies (accounting for shields).
	 *
	 * @param ally The ally entity
	 * @return Estimated total damage output
	 */
	static real computeAllyDamagePotential(Entity ally) {
		real totalDmg = 0.0
		integer tpLeft = ally.tp
		real strMult = 1.0 + ally.str / 100.0
		real mgcMult = 1.0 + ally.mgc / 100.0
		real pwrMult = 1.0 + ally.pwr / 100.0
		real sncMult = 1.0 + ally.snc / 100.0

		// Compute average enemy shields for damage reduction
		real avgAbsShield = 0.0
		real avgRelShield = 0.0
		integer enemyAliveCount = 0
		for (Entity enemy in Fight.getEnemiesAlive()) {
			avgAbsShield += enemy.absShield
			avgRelShield += enemy.relShield
			enemyAliveCount++
		}
		if (enemyAliveCount > 0) {
			avgAbsShield /= enemyAliveCount
			avgRelShield /= enemyAliveCount
		}
		real relFactor = max(0.0, 1.0 - avgRelShield / 100.0)

		for (Item item in ally.items) {
			if (!item.isOffensive) continue
			if (item.haveCD && getCooldown(item.id, ally.id)! > 0) continue
			if (item.cost > tpLeft) continue

			// Estimate damage from this item's effects
			real itemDmg = 0.0
			for (ItemEffect effect in item.effects) {
				if (effect.type == EFFECT_DAMAGE) {
					real raw = effect.avg * strMult * pwrMult
					itemDmg += max(0.0, raw * relFactor - avgAbsShield)
				} else if (effect.type == EFFECT_POISON) {
					itemDmg += effect.avg * mgcMult * pwrMult
				} else if (effect.type == EFFECT_LIFE_DAMAGE) {
					itemDmg += effect.avg  // Life damage is flat
				} else if (effect.type == EFFECT_NOVA_DAMAGE) {
					itemDmg += effect.avg * sncMult * pwrMult
				}
			}

			if (itemDmg <= 0) continue

			// Greedy: use item as many times as TP allows
			integer uses = 0
			while (item.cost <= tpLeft && uses < item.maxUse) {
				totalDmg += itemDmg
				tpLeft -= item.cost
				uses++
				if (item.haveCD) break
			}
		}

		return totalDmg
	}

	/*
	 * Compute damage potential for all allies (called once per turn).
	 */
	static void computeAllAllyDamagePotential() {
		for (Entity entity in Fight.getAlliesAlive()) {
			if (entity != Fight.self) {
				allyDamagePotential[entity] = computeAllyDamagePotential(entity)
			}
		}
	}
}
