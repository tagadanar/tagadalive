/*
 * Objet qui contient l'ensemble des entités vivante alliée et ennemie
 */
class Fight {
	private static Map<integer, Entity> _aliveEnemies
	private static Map<integer, Entity> _aliveAllies
	private static Map<integer, Entity> _aliveAll
	private static Map<integer, Entity> _aliveAllLeeks
	private static Map<integer, Entity> _aliveAllBulbs
	private static Map<integer, Entity> _aliveEnemiesLeeks
	private static Map<integer, Entity> _aliveEnemiesBulbs
	private static Map<integer, Entity> _aliveAlliesLeeks
	private static Map<integer, Entity> _aliveAlliesBulbs
	static Map<string, integer> chestPwrGained = ["wood_chest":10, "iron_chest":50, "diamond_chest":100]
	static Array<integer> allEntitiesId
	static Entity self
	static Cell selfCell = Cell(Cell.SELF_CAST_ID)
	static boolean isBattleRoyale
	// Liberation availability for combo detection (computed in refresh)
	static boolean liberationReady = false
	static Item? liberationItem = null
	// Antidote availability for danger evaluation (computed in refresh)
	static boolean antidoteReady = false
	static Item? antidoteItem = null
	// Inversion availability for tactical positioning (computed in refresh)
	static boolean inversionReady = false
	static Item? inversionItem = null
	// Repotting availability for bulb swap positioning (computed in refresh)
	static boolean repottingReady = false
	static Item? repottingItem = null
	// Summon availability for operation buffer calculation (computed in refresh)
	static boolean canSummon = false

	// Cached turn order: entities that play after self, sorted by turn order
	// Reset in refresh(), computed lazily in getEntitiesAfterSelfInOrder()
	private static Array<Entity>? _entitiesAfterSelfInOrder = null

	/*
	 * Actualise les tableaux contenant les entités vivante alliée et ennemie ainsi que l'ensemble des entités alliées + ennemies
	 */
	static void refresh(){
		isBattleRoyale = getFightType() == FIGHT_TYPE_BATTLE_ROYALE
		_entitiesAfterSelfInOrder = null  // Reset turn order cache
		_aliveEnemies = [:]
		_aliveAllies = [:]
		_aliveAll = [:]
		_aliveAllLeeks = [:]
		_aliveAllBulbs = [:]
		_aliveEnemiesLeeks = [:]
		_aliveEnemiesBulbs = [:]
		_aliveAlliesLeeks = [:]
		_aliveAlliesBulbs = [:]
		allEntitiesId = []
		for(integer e in getAliveEnemies()) {
			Entity entity = Entity(e)
			_aliveEnemies[e] = entity
			_aliveAll[e] = entity
			if(entity.isBulb){
				_aliveEnemiesBulbs[e] = entity
				_aliveAllBulbs[e] = entity
			} else {
				_aliveEnemiesLeeks[e] = entity
				_aliveAllLeeks[e] = entity
			}
		}
		for(integer a in getAliveAllies()) {
			Entity entity = Entity(a)
			_aliveAllies[a] = entity
			_aliveAll[a] = entity
			if(entity.isBulb){
				_aliveAlliesBulbs[a] = entity
				_aliveAllBulbs[a] = entity
			} else {
				_aliveAlliesLeeks[a] = entity
				_aliveAllLeeks[a] = entity
			}
		}
		self = _aliveAll[getEntity()]!

		// Compute Liberation, Antidote, Inversion, and summon availability
		liberationReady = false
		liberationItem = null
		antidoteReady = false
		antidoteItem = null
		inversionReady = false
		inversionItem = null
		repottingReady = false
		repottingItem = null
		canSummon = false
		for (Item item in self.items) {
			if (item.id == CHIP_LIBERATION && getCooldown(item.id, self.id) == 0) {
				liberationReady = true
				liberationItem = item
			}
			if (item.id == CHIP_ANTIDOTE && getCooldown(item.id, self.id) == 0) {
				antidoteReady = true
				antidoteItem = item
			}
			if (item.id == CHIP_INVERSION && getCooldown(item.id, self.id) == 0) {
				inversionReady = true
				inversionItem = item
			}
			if (item.id == CHIP_REPOTTING && getCooldown(item.id, self.id) == 0) {
				repottingReady = true
				repottingItem = item
			}
			if (item.isSummon && getCooldown(item.id, self.id) == 0 && self.tp >= item.cost) {
				canSummon = true
			}
		}
	}
	
	/*
	 * initialise les entités, doit être call à la fin du refresh de la Map pour bien init les reachableCells avec les bonnes cases occupés dans la Map
	 */
	static void refreshEntities(){
		for(Entity entity in _aliveAll){
			entity.init()
			push(allEntitiesId, entity.id)
		}
	}

	/*
	 * Lightweight update for summon callbacks.
	 * Creates the new summon entity, updates Fight.self, and updates positions of all entities.
	 * Does NOT recreate existing entities (preserves offensiveItems, etc.).
	 */
	static void updateForSummon() {
		integer selfId = getEntity()

		// Create summon entity if it doesn't exist yet
		if (_aliveAll[selfId] == null) {
			Entity entity = Entity(selfId)
			_aliveAll[selfId] = entity
			push(allEntitiesId, entity.id)
			if (entity.isFriend) {
				_aliveAllies[selfId] = entity
				if (entity.isBulb) {
					_aliveAlliesBulbs[selfId] = entity
					_aliveAllBulbs[selfId] = entity
				} else {
					_aliveAlliesLeeks[selfId] = entity
					_aliveAllLeeks[selfId] = entity
				}
			} else {
				_aliveEnemies[selfId] = entity
				if (entity.isBulb) {
					_aliveEnemiesBulbs[selfId] = entity
					_aliveAllBulbs[selfId] = entity
				} else {
					_aliveEnemiesLeeks[selfId] = entity
					_aliveAllLeeks[selfId] = entity
				}
			}
		}

		// Update Fight.self to the current playing entity
		self = _aliveAll[selfId]!
		selfCell = Cell(Cell.SELF_CAST_ID)

		// Remove dead entities from all collections (they may have died during main leek's turn)
		// Collect IDs first to avoid modifying map while iterating
		Array<integer> deadIds = []
		for (integer id : Entity entity in _aliveAll) {
			if (!isAlive(id)) push(deadIds, id)
		}
		for (integer id in deadIds) {
			mapRemove(_aliveAll, id)
			mapRemove(_aliveAllies, id)
			mapRemove(_aliveEnemies, id)
			mapRemove(_aliveAllLeeks, id)
			mapRemove(_aliveAllBulbs, id)
			mapRemove(_aliveAlliesLeeks, id)
			mapRemove(_aliveAlliesBulbs, id)
			mapRemove(_aliveEnemiesLeeks, id)
			mapRemove(_aliveEnemiesBulbs, id)
		}

		// Update positions and state of all remaining alive entities from game state
		// refreshState() ensures entities have current HP/stats/effects after main leek's actions
		for (integer id : Entity entity in _aliveAll) {
			entity.updatePosition()
			// Refresh state for existing entities (not the newly created bulb)
			if (id != selfId) {
				entity.refreshState()
			}
		}
	}

	/*
	 * Renvoie Entity correspondant a l'id de l'entity demandée si elle est vivante
	 * @param entityId Id de l'Entity
	 * @return une Entity 
	 */
	static Entity getEntity(integer entityId) {
		return _aliveAll[entityId]!
	}
	
	/*
	 * Renvoie un tableau contenant les ennemis vivants
	 * @return un tableau d'Entity
	 */
	static Map<integer, Entity> getEnemiesAlive() {
		return _aliveEnemies
	}
	
	/*
	 * Renvoie un tableau contenant les ennemis non bulbes vivants
	 * @return un tableau d'Entity
	 */
	static Map<integer, Entity> getEnemiesLeeksAlive() {
		return _aliveEnemiesLeeks
	}
	
	/*
	 * Renvoie un tableau contenant les ennemis bulbes vivants
	 * @return un tableau d'Entity
	 */
	static Map<integer, Entity> getEnemiesBulbsAlive() {
		return _aliveEnemiesBulbs
	}
	
	/*
	 * Renvoie un tableau contenant les alliés vivants (moi compris dedans)
	 * @return un tableau d'Entity
	 */
	static Map<integer, Entity> getAlliesAlive() {
		return _aliveAllies
	}
	
	/*
	 * Renvoie un tableau contenant les alliés non bulbes vivants (moi compris dedans)
	 * @return un tableau d'Entity
	 */
	static Map<integer, Entity> getAlliesLeeksAlive() {
		return _aliveAlliesLeeks
	}
	
	/*
	 * Renvoie un tableau contenant les alliés bulbes vivants (moi compris dedans si je suis un bulbe)
	 * @return un tableau d'Entity
	 */
	static Map<integer, Entity> getAlliesBulbsAlive() {
		return _aliveAlliesBulbs
	}
	
	/*
	 * Renvoie un tableau contenant les ennemis et les alliés vivants (moi compris dedans)
	 * @return un tableau d'Entity
	 */
	static Map<integer, Entity> getAllAlive() {
		return _aliveAll
	}
	
	/*
	 * Renvoie un tableau contenant les ennemis et les alliés non bulbes vivants (moi compris dedans)
	 * @return un tableau d'Entity
	 */
	static Map<integer, Entity> getAllLeeksAlive() {
		return _aliveAllLeeks
	}
	
	/*
	 * Renvoie un tableau contenant les ennemis et les alliés bulbes vivants (moi compris dedans)
	 * @return un tableau d'Entity
	 */
	static Map<integer, Entity> getAllBulbsAlive() {
		return _aliveAllBulbs
	}
	
	/*
	 * Détecte les entités vivantes qui jouent avant l'entité entity en paramètre de la fonction
	 * cette fonction return une list avec @entity inclus, WORKING AS INTENDED !
	 * cette fonction est utile pour les cases à ignorer dans les fonctions de déplacement, je dois m'ignorer aussi
	 * ne devrait pas poser de problème ailleurs, mais je laisse ces commentaires pour qu'on y fasse attention
	 * quand on reviendra sur l'ordre de jeu, il est possible que cette fonction mérite un rename pour la distinguer d'une autre sans self
	 * @param entity Entity 
	 * @return liste des entités vivantes alliés et ennemies 
	 */
	static Array<Entity> getEntitiesWhoPlayBefore(Entity entity) {
		if(entity == self) return [self];
		Array<Entity>  list = [self]
		integer selfOrder = self.turnOrder
		integer limit = entity.turnOrder
		for(Entity e in _aliveAll) {
			if(selfOrder < limit){
				if(selfOrder < e.turnOrder && e.turnOrder < limit) push(list, e)
			} else {
				if(selfOrder < e.turnOrder) push(list, e)
				if(e.turnOrder < limit) push(list, e)
			}
		}
		return list;
	}

	/*
	 * Returns all entities (enemies + allies) that play after self, sorted by turn order.
	 * Wraps around: if self plays last, returns entities from start of next round.
	 * Excludes self. Used by computeDanger for proper turn order processing.
	 * Cached - computed once per turn.
	 */
	static Array<Entity> getEntitiesAfterSelfInOrder() {
		if (_entitiesAfterSelfInOrder != null) return _entitiesAfterSelfInOrder!

		integer selfOrder = self.turnOrder

		// Separate entities into those after self (this round) and before self (next round)
		Array<Entity> afterSelf = []   // turnOrder > selfOrder (play this round after self)
		Array<Entity> beforeSelf = []  // turnOrder < selfOrder (play next round before self)

		for (Entity e in _aliveAll) {
			if (e == self) continue
			if (e.turnOrder > selfOrder) {
				push(afterSelf, e)
			} else {
				push(beforeSelf, e)
			}
		}

		// Sort each group by turnOrder (ascending)
		afterSelf = arraySort(afterSelf, (Entity a, Entity b) -> a.turnOrder - b.turnOrder)
		beforeSelf = arraySort(beforeSelf, (Entity a, Entity b) -> a.turnOrder - b.turnOrder)

		// Concatenate: first those after self (this round), then wrap to those before (next round)
		Array<Entity> result = []
		for (Entity e in afterSelf) push(result, e)
		for (Entity e in beforeSelf) push(result, e)

		_entitiesAfterSelfInOrder = result
		return result
	}
}