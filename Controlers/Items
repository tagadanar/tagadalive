/*
 * Ensemble de méthodes et d'algorithmes permettant d'instancier les items de type Item et de les classer par ordre d'importance
 */
class Items {
	private static Map<integer, Item> _items = [:]
	private static Map<integer, Array<Item>> _stuff = [:]
	
	/*
	 * Initialise toutes les équipements disponible dans le jeu
	 */
	static void init() {
		for(integer i in getAllWeapons()+getAllChips()) {
			_items[i] = new Item(i)
		}
	}
	
	/*
	 * Renvoie toutes les informations de l'arme / puce en paramètre
	 * @param itemId id de l'item 
	 * @return Item 
	 */
	static Item? getItem(integer? itemId){
		if (itemId == null) return null
		return _items[itemId!]
	}
	
	/*
	 * Renvoie toutes les informations de l'arme / puce en paramètre
	 * @param itemId id de l'item 
	 * @return Item 
	 */
	static Map<integer, Item> getAllItems(){
		return _items
	}
	
	/*
	 * Renvoie un tableau d'items équipé sur une Entity 
	 * @param entityId id de l'Entity
	 * @return tableau d'Item
	 */
	static Array<Item> getItems(integer entityId) {
		if(!_stuff[entityId]){
			_stuff[entityId] = []
			Array<integer>? weapons = getWeapons(entityId)
			if (weapons != null) {
				for(integer itemId in weapons!){
					push(_stuff[entityId]!, _items[itemId]);
				}
			}
			Array<integer>? chips = getChips(entityId)
			if (chips != null) {
				for(integer itemId in chips!){
					push(_stuff[entityId]!, _items[itemId]);
				}
			}
		}
		return _stuff[entityId]!
	}
	
	/*
	 * Appel la fonction getOrderedOffensiveItems avec moi en guise de cible d'une entité en paramètre
	 * @param entity Entity ennemie
	 * @return tableau d'Item classé par dangerosité
	 */
	static Array<Item> getOrderedOffensiveItems(Entity entity) {
		return Items.getOrderedOffensiveItems(entity, Fight.self)
	}
	
	/*
	 * Classifie les Item items d'une Entity entity par dangerosité sur une Entity target
	 * @param entity Entity attaquant
	 * @param target Entity ciblé
	 * @return tableau d'Item classé par dangerosité
	 */
	static Array<Item> getOrderedOffensiveItems(Entity entity, Entity target) {
		real dmg
		Map<Item, real> dmgPerItem = [:]
		//Array<Item> stuff = Items.getItems(entity.id)
		integer absShield = target.absShield, relShield = target.relShield;
		// reminder le cd est décrément au début du round, donc 1 est utilisable next rnd, sauf pour moi même
		integer limitCD = entity == Fight.self ? 0 : 1
		for(Item item in entity.items){
			if(item.haveCD && getCooldown(item.id, entity.id)>limitCD) continue;
			dmg=0.0;
			for(ItemEffect e in item.effects){
				if(e.type == EFFECT_DAMAGE ){
					dmg += (e.avg*(1+(entity.str/100))*(1+(entity.pwr/100))*(1-(relShield/100)))-absShield;
				}
				else if(e.type == EFFECT_POISON){
					dmg += e.avg*(1+(entity.mgc/100))*(1+(entity.pwr/100))*e.duration;
				}
				else if(e.type == EFFECT_LIFE_DAMAGE){
					// Life damage: sourceLife * (avg%/100) * (1+pwr/100), then shields
					dmg += (entity.life*(e.avg/100)*(1+(entity.pwr/100))*(1-(relShield/100)))-absShield;
				}
				else if(e.type == EFFECT_HEAL){
					dmg -= e.avg*(1+(entity.wsd/100));
				}
				// ici add les effets d'entrave en score pts->dmg
			}
			if(dmg>0) dmgPerItem[item] = dmg/item.cost;
		}
		return arraySort(mapKeys(dmgPerItem), (Item a, Item b) => integer {	
			if(dmgPerItem[a]<dmgPerItem[b]) return 1;
			else if(dmgPerItem[a]>dmgPerItem[b]) return -1;
			return 0;
		}) as Array<Item>;
	}
	
	/*
	 * Calcule la valeur de support d'un item (heal + shield) pour protéger self.
	 * Utilise le système de scoring pour rendre les différents types d'effets comparables.
	 * @param entity Entity qui possède l'item (source du support)
	 * @param item Item à évaluer
	 * @return valeur de support scorée
	 */
	static real computeSupportValue(Entity entity, Item item) {
		real value = 0.0
		for (ItemEffect e in item.effects) {
			// Skip non-stackable effects already on self
			if (Items.isEffectAlreadyOnSelf(item, e)) continue

			integer duration = Scoring.getEffectiveDuration(e.duration, entity, Fight.self)
			real mitigation = ScoringConfig.offensive_duration_mitigation[duration]!

			// === HEAL EFFECTS ===
			if (e.type == EFFECT_HEAL) {
				real healValue = e.avg * (1 + entity.wsd / 100)
				real coef = Scoring.getDynamicCoef(Fight.self, Stats.HP, null)
				value += healValue * coef * mitigation
			}
			else if (e.type == EFFECT_BOOST_MAX_LIFE) {
				real boostValue = e.avg * (1 + entity.wsd / 100)
				real coef = Scoring.getDynamicCoef(Fight.self, Stats.HPMAX, null)
				value += boostValue * coef * mitigation
			}
			// === SHIELD EFFECTS ===
			else if (e.type == EFFECT_ABSOLUTE_SHIELD) {
				real shieldValue = e.avg * (1 + entity.rst / 100)
				real coef = Scoring.getDynamicCoef(Fight.self, Stats.ABSSHIELD, null)
				value += shieldValue * coef * mitigation
			}
			else if (e.type == EFFECT_RELATIVE_SHIELD) {
				real shieldValue = e.avg * (1 + entity.rst / 100)
				real coef = Scoring.getDynamicCoef(Fight.self, Stats.RELSHIELD, null)
				value += shieldValue * coef * mitigation
			}
			// === ANTIDOTE EFFECT ===
			else if (e.type == EFFECT_ANTIDOTE) {
				// When enemyHasMgc, use DEATH_VALUE to guarantee selection
				if (BattleState.enemyHasMgc) {
					value += ScoringConfig.DEATH_VALUE
				}
			}
		}
		return value
	}

	/*
	 * Check if a non-stackable effect from this item is already on self.
	 * @param item Item to check
	 * @param effect ItemEffect to check
	 * @return true if effect should be skipped (already on self and non-stackable)
	 */
	static boolean isEffectAlreadyOnSelf(Item item, ItemEffect effect) {
		if (effect.stackable) return false
		if (effect.duration <= 1) return false
		Array<EffectOverTime>? existing = Fight.self.items_effectOverTime[item]
		return existing != null && count(existing!) > 0
	}

	/*
	 * Classifie les items de support (heal + shield) d'une Entity par valeur pour protéger self.
	 * Utilise le système de scoring pour rendre les différents types d'effets comparables.
	 * Considère: EFFECT_HEAL, EFFECT_BOOST_MAX_LIFE, EFFECT_RAW_HEAL, EFFECT_ABSOLUTE_SHIELD, EFFECT_RELATIVE_SHIELD
	 * @param entity Entity qui possède les items
	 * @param limit Nombre max d'items à retourner (0 = unlimited)
	 * @return tableau d'Item classé par efficacité de support (value/cost)
	 */
	static Array<Item> getOrderedSupportItems(Entity entity, integer limit = 0) {
		Map<Item, real> valuePerItem = [:]
		// CD is decremented at round start, so 1 means usable next round (except for self)
		integer limitCD = entity == Fight.self ? 0 : 1

		for (Item item in entity.items) {
			if (item.haveCD && getCooldown(item.id, entity.id) > limitCD) continue
			real value = Items.computeSupportValue(entity, item)
			if (value > 0) valuePerItem[item] = value / item.cost
		}

		// Sort by efficiency (value per TP)
		Array<Item> sorted = arraySort(mapKeys(valuePerItem), (Item a, Item b) => integer {
			if (valuePerItem[a] < valuePerItem[b]) return 1
			else if (valuePerItem[a] > valuePerItem[b]) return -1
			return 0
		}) as Array<Item>

		// Limit to top N items
		if (limit > 0 && count(sorted) > limit) {
			Array<Item> limited = []
			for (integer i = 0; i < limit; i++) {
				push(limited, sorted[i])
			}
			return limited
		}
		return sorted
	}

	/*
	 * Classifie les armes offensives d'une Entity par efficacite (dommages/TP)
	 * Ne considere que les ARMES (pas les chips) avec EFFECT_DAMAGE ou EFFECT_POISON
	 * @param entity Entity qui possede les armes
	 * @param limit Nombre max d'armes a retourner (0 = unlimited)
	 * @return tableau d'Item armes classe par efficacite
	 */
	static Array<Item> getOrderedWeaponItems(Entity entity, integer limit = 0) {
		real dmg
		Map<Item, real> dmgPerItem = [:]
		// reminder le cd est decrement au debut du round, donc 1 est utilisable next rnd, sauf pour moi meme
		integer limitCD = entity == Fight.self ? 0 : 1
		for(Item item in entity.items) {
			// Ne garder que les armes
			if (!item.isWeap) continue
			if(item.haveCD && getCooldown(item.id, entity.id) > limitCD) continue
			dmg = 0.0
			for(ItemEffect e in item.effects) {
				if(e.type == EFFECT_DAMAGE) {
					dmg += e.avg * (1 + (entity.str / 100)) * (1 + (entity.pwr / 100))
				}
				else if(e.type == EFFECT_POISON) {
					dmg += e.avg * (1 + (entity.mgc / 100)) * (1 + (entity.pwr / 100)) * e.duration
				}
			}
			if(dmg > 0) dmgPerItem[item] = dmg / item.cost
		}
		Array<Item> sorted = arraySort(mapKeys(dmgPerItem), (Item a, Item b) => integer {
			if(dmgPerItem[a] < dmgPerItem[b]) return 1
			else if(dmgPerItem[a] > dmgPerItem[b]) return -1
			return 0
		}) as Array<Item>
		// Limit to top N items (0 = unlimited)
		if(limit > 0 && count(sorted) > limit) {
			Array<Item> limited = []
			for(integer i = 0; i < limit; i++) {
				push(limited, sorted[i])
			}
			return limited
		}
		return sorted
	}

	/*
	 * Classifie les Item items d'une Entity entity par effet bénéfique défensif
	 * @param entity Entity
	 * @return tableau d'Item classé par effet bénéfique défensif
	 */
	static Array<Item> getOrderedDefensiveItems(Entity entity){
		real dmg
		Map<Item, real> dmgPerItem = [:]
		integer absShield = entity.absShield, relShield = entity.relShield;
		for(Item item in entity.items){
			// reminder le cd est décrément au début du round, donc 1 est utilisable next rnd
			if(item.haveCD && getCooldown(item.id, entity.id)>1) continue;
			dmg=0.0;
			for(ItemEffect e in item.effects){
				if(e.type == EFFECT_HEAL){
					dmg+= e.avg*(1+(entity.wsd/100));
				}
				else if(e.type == EFFECT_ABSOLUTE_SHIELD){
					dmg += e.avg*(1+(entity.rst/100)) *e.duration;
				}
				else if(e.type == EFFECT_RELATIVE_SHIELD){
					dmg += e.avg*(1+(entity.rst/100)) *e.duration *4; // FIXME le *4 devrait être une global de ratio abs/rel
				}
			}
			if(dmg>0) dmgPerItem[item] = dmg/item.cost;
		}
		return arraySort(mapKeys(dmgPerItem), (Item a, Item b) => integer {	
			if(dmgPerItem[a]<dmgPerItem[b]) return 1;
			else if(dmgPerItem[a]>dmgPerItem[b]) return -1;
			return 0;
		}) as Array<Item>;
	}
}
