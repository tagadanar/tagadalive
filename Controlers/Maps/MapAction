class MapAction {
	static Map<Item, Map<Cell, Array<Action>>> _item_cell_actions // [item:[cell:[actions]]]
	static Map<Cell, Map<Item, Array<Action>>> _cell_item_actions // [cell:[item:[actions]]]
	static Map<Cell, Map<Item, Action>> _cell_item_bestAction // [cell:[item:action]]
	// PTS index: [item][entityId][attackCell] = aimCell for O(1) lookup
	// Unified index - attackCell maps directly to its aimCell (no separate aimCells map)
	static Map<Item, Map<integer, Map<Cell, Cell>>> _item_entityId_attackCells
	// Score index: stores best score per (item, entityId, attackCell) - keeps best aimCell
	static Map<Item, Map<integer, Map<Cell, real>>> _item_entityId_scores

	static void refresh() {
		// remise à zéro des maps
		_item_cell_actions = [:]
		_cell_item_actions = [:]
		_cell_item_bestAction = [:]
		_item_entityId_attackCells = [:]
		_item_entityId_scores = [:]
		// Clear effect cache for new turn
		EffectCache.clear()
		// pour chaque item
		for(Item item in Fight.self.items){
			// si j'ai le cooldown
			if(getCooldown(item.id, Fight.self.id) > 0) continue
			// Handle summon chips as self-cast (cell chosen at execution time)
			if (item.isSummon) {
				MapAction.addAction(item, Fight.selfCell, Fight.selfCell)
				continue
			}
			// selon l'area de l'item
			if(item.area == AREA_POINT){
				// pour chaque cible valide de l'item
				for(Entity entity in item.targetSet()){
					if(entity.isInvincible && !entity.isFriend) continue // skip invincible enemies
					if(entity==Fight.self){
						// si c'est moi la cible, je peux le lancer sur moi même que si la minrange le permet
						if(item.minRange == 0){
							Action? action = MapAction.addAction(item, Fight.selfCell, Fight.selfCell)
							if(action != null) {
								MapAction.addEntityIndex(item, entity.id, Fight.selfCell, Fight.selfCell, action!.score!)
							}
						}
					} else {
						// sinon je liste toutes les cases depuis lesquelles je peux tirer sur la cible
						Array<Cell> cells = Targets.getCellsToUseItemOnCell(item, entity.cell, [Fight.self.id])
						for(Cell c in cells) {
							Action? action = MapAction.addAction(item, c, entity.cell)
							if(action != null) {
								MapAction.addEntityIndex(item, entity.id, c, entity.cell, action!.score!)
							}
						}
					}
				}
			}else if(item.area == AREA_LASER_LINE){
				for(Entity entity in item.targetSet()){
					if(entity.isInvincible && !entity.isFriend) continue // skip invincible enemies
					if(entity==Fight.self) continue; // on peut jamais se tirer dessus au lazer
					Array<Cell> cellsFrom = Targets.getLazerCellsToUseItemOnCell(item, entity.cell)
					for(Cell cell in cellsFrom){
						Action? action = MapAction.addAction(item, cell, entity.cell)
						if(action != null) {
							MapAction.addEntityIndex(item, entity.id, cell, entity.cell, action!.score!)
						}
					}
				}
				// maybe here I should handle AREA_FIRST_INLINE ?
			}else{ // every aoe
				for(Entity entity in item.targetSet()){
					if(entity.isInvincible && !entity.isFriend) continue // skip invincible enemies
					if(entity==Fight.self) continue
					// TODO réfléchir à l'implem de ce genre de move sur case vide..
					// si c'est moi la cible, si la minrange le permet, visez les cells proche ?
					// if(entity==Fight.self && item.minRange <= ?){}
					for(Cell aimCell in entity.cell.getAreaCells(item.area)){
						Array<Cell> cells = Targets.getCellsToUseItemOnCell(item, aimCell, [Fight.self.id])
						for(Cell c in cells) {
							Action? action = MapAction.addAction(item, c, aimCell)
							if(action != null) {
								MapAction.addEntityIndex(item, entity.id, c, aimCell, action!.score!)
							}
						}
					}
				}
			}
		}
		// Log cache stats at end of action pool creation
		EffectCache.logStats()
	}

	static Map<Cell, Map<Item, Action>> getMapBestAction(){
		return _cell_item_bestAction
	}
	
	/*
	 * Add entity index for PTS O(1) lookup
	 * @param item The item being used
	 * @param entityId The target entity's ID
	 * @param fromCell The cell from which the action can be performed
	 * @param aimCell The cell to aim at (entity.cell for point/laser, specific cell for AOE)
	 * @param score The action score - keeps aimCell with best score per (item, entity, attackCell)
	 */
	static void addEntityIndex(Item item, integer entityId, Cell fromCell, Cell aimCell, real score) {
		// Initialize nested maps if needed
		if (!_item_entityId_attackCells[item]) _item_entityId_attackCells[item] = [:]
		if (!_item_entityId_attackCells[item]![entityId]) _item_entityId_attackCells[item]![entityId] = [:]
		if (!_item_entityId_scores[item]) _item_entityId_scores[item] = [:]
		if (!_item_entityId_scores[item]![entityId]) _item_entityId_scores[item]![entityId] = [:]

		// Keep aimCell with best score (fixes AOE: best aimCell instead of first)
		real? existingScore = _item_entityId_scores[item]![entityId]![fromCell]
		if (existingScore == null || score > existingScore!) {
			_item_entityId_attackCells[item]![entityId]![fromCell] = aimCell
			_item_entityId_scores[item]![entityId]![fromCell] = score
		}
	}

	/*
	 * Get attack cells for a specific (item, entityId) pair - used by PTS
	 * Returns Map<Cell, Cell> where key=attackCell, value=aimCell
	 * Returns null if no valid attack cells exist
	 */
	static Map<Cell, Cell>? getAttackCellsForEntity(Item item, integer entityId) {
		if (_item_entityId_attackCells[item] == null) return null
		return _item_entityId_attackCells[item]![entityId]
	}

	/*
	 * Get scores for a specific (item, entityId) pair
	 * Returns Map<Cell, real> where key=attackCell, value=best score from that cell
	 */
	static Map<Cell, real>? getScoresForEntity(Item item, integer entityId) {
		if (_item_entityId_scores[item] == null) return null
		return _item_entityId_scores[item]![entityId]
	}

	static Action? addAction(Item item, Cell from, Cell targetCell){
		// Accept cells reachable with current MP OR with MP buffs (extendedReachableCells)
		if(targetCell != Fight.selfCell &&
		   Fight.self.extendedReachableCells[from] == null) return null
		Benchmark.start("addAction")

		// Try to use cached EffectSnapshot for efficiency
		Action action
		if (item.area == AREA_LASER_LINE) {
			// Laser: cache by target set hash
			EffectSnapshot? snapshot = EffectCache.getOrComputeLaser(item, from, targetCell)
			if (snapshot != null) {
				action = new Action(item, from, targetCell, snapshot!)
			} else {
				// No targets or not cacheable - create without cache
				action = new Action(item, from, targetCell)
			}
		} else {
			// Non-laser: cache by (item, aimCell)
			EffectSnapshot? snapshot = EffectCache.getOrCompute(item, targetCell, from)
			if (snapshot != null) {
				action = new Action(item, from, targetCell, snapshot!)
			} else {
				// Not cacheable (self-cast, onCaster AOE) - create without cache
				action = new Action(item, from, targetCell)
			}
		}

		// ajout dans la map par item puis cells
		if(!_item_cell_actions[item]) _item_cell_actions[item] = [:]
		if(!_item_cell_actions[item]![from]) _item_cell_actions[item]![from] = []
		push(_item_cell_actions[item]![from]!, action)

		// ajout dans la map par cell puis items
		if(!_cell_item_actions[from]) _cell_item_actions[from] = [:]
		if(!_cell_item_actions[from]![item]) _cell_item_actions[from]![item] = []
		push(_cell_item_actions[from]![item]!, action)

		// ici, je ne set sur chaque case, pour chaque item, que la meilleure action et pas les autres:
		// => réduction forte de la complexité
		// => pas de perte normalement si j'ai déjà check avant les effets qui change drastiquement le scoring, genre kill un leek
		// limitation > changement drastique de score après certain effet, genre libération.
		// maybe solution > implem un préscoring envisageant l'action précédente de debuff, doit pas y en avoir 40
		if(!_cell_item_bestAction[from]) _cell_item_bestAction[from] = [:]
		if(!_cell_item_bestAction[from]![item]) _cell_item_bestAction[from]![item] = action
		else if(_cell_item_bestAction[from]![item]!.score < action.score) _cell_item_bestAction[from]![item] = action
		Benchmark.stop("addAction")
		return action
	}
}