/*
 * ItemTarget: tuple for sorted exploration
 * Holds (item, target, score) for priority ordering
 */
class ItemTarget {
	Item item
	Entity target
	real score

	constructor(Item item, Entity target, real score) {
		this.item = item
		this.target = target
		this.score = score
	}
}

class MapAction {
	static Map<Item, Map<Cell, Array<Action>>> _item_cell_actions // [item:[cell:[actions]]]
	static Map<Cell, Map<Item, Array<Action>>> _cell_item_actions // [cell:[item:[actions]]]
	static Map<Cell, Map<Item, Action>> _cell_item_bestAction // [cell:[item:action]]
	// PTS index: [item][entityId][attackCell] = aimCell for O(1) lookup
	// Unified index - attackCell maps directly to its aimCell (no separate aimCells map)
	static Map<Item, Map<integer, Map<Cell, Cell>>> _item_entityId_attackCells
	// Score index: stores best score per (item, entityId, attackCell) - keeps best aimCell
	static Map<Item, Map<integer, Map<Cell, real>>> _item_entityId_scores

	// Budget: 80% of max operations
	static real BUDGET_RATIO = 0.8
	// Counter for actions created during refresh (for guaranteed minimum)
	static integer _actionsCreated = 0

	static void refresh() {
		// Reset maps
		_item_cell_actions = [:]
		_cell_item_actions = [:]
		_cell_item_bestAction = [:]
		_item_entityId_attackCells = [:]
		_item_entityId_scores = [:]
		_actionsCreated = 0
		// Clear effect cache for new turn
		EffectCache.clear()

		// Compute budget threshold
		integer actionBudget = (getMaxOperations() * BUDGET_RATIO) as integer

		// ═══════════════════════════════════════════════════════════════════
		// PHASE 1: Score all (item, target) pairs
		// ═══════════════════════════════════════════════════════════════════
		Array<ItemTarget> tuples = []

		for (Item item in Fight.self.items) {
			// Skip if on cooldown
			if (getCooldown(item.id, Fight.self.id) > 0) continue

			// Handle summon chips immediately (self-cast, no target scoring)
			if (item.isSummon) {
				MapAction.addAction(item, Fight.selfCell, Fight.selfCell)
				continue
			}

			// Score each valid target for this item
			for (Entity entity in item.targetSet()) {
				// Skip invincible enemies
				if (entity.isInvincible && !entity.isFriend) continue

				// Compute score using direct hit on target
				EffectSnapshot? snapshot = EffectCache.getOrCompute(item, entity.cell, Fight.selfCell)
				real score = snapshot != null ? snapshot!.effectScore : 0

				push(tuples, new ItemTarget(item, entity, score))
			}
		}

		// ═══════════════════════════════════════════════════════════════════
		// PHASE 2: Sort by score descending
		// ═══════════════════════════════════════════════════════════════════
		arraySort(tuples, (ItemTarget a, ItemTarget b) -> b.score - a.score)

		// ═══════════════════════════════════════════════════════════════════
		// PHASE 3: Populate actions (budget-aware)
		// ═══════════════════════════════════════════════════════════════════
		integer totalTuples = count(tuples)
		integer processed = 0

		for (ItemTarget tuple in tuples) {
			// Guarantee at least 3 actual actions (for bulbs starting late), then check budget
			if (_actionsCreated >= 3 && getOperations() > actionBudget) {
				MapAction._logEarlyExit(processed, totalTuples)
				EffectCache.logStats()
				return
			}

			MapAction._populateActionsForTarget(tuple.item, tuple.target)
			processed++
		}

		// Log cache stats at end of action pool creation
		EffectCache.logStats()
	}

	/*
	 * Log early exit due to budget exhaustion
	 */
	static void _logEarlyExit(integer processed, integer total) {
		string msg = "T" + getTurn() + " MapAction early exit @" + Benchmark.format(getOperations())
		msg += " | tuples:" + processed + "/" + total + " | actions:" + _actionsCreated
		debugW(msg)
	}

	/*
	 * Populate actions for a specific (item, target) pair
	 * Handles area-specific logic (POINT, LASER, AOE)
	 */
	static void _populateActionsForTarget(Item item, Entity entity) {
		if (item.area == AREA_POINT) {
			MapAction._populatePointActions(item, entity)
		} else if (item.area == AREA_LASER_LINE) {
			MapAction._populateLaserActions(item, entity)
		} else {
			MapAction._populateAoeActions(item, entity)
		}
	}

	/*
	 * AREA_POINT: single target actions
	 */
	static void _populatePointActions(Item item, Entity entity) {
		if (entity == Fight.self) {
			// Self-cast only if minRange allows
			if (item.minRange == 0) {
				Action? action = MapAction.addAction(item, Fight.selfCell, Fight.selfCell)
				if (action != null) {
					MapAction.addEntityIndex(item, entity.id, Fight.selfCell, Fight.selfCell, action!.score!)
				}
			}
			return
		}

		// Pre-compute snapshot for efficiency (shared across all cells)
		EffectSnapshot? snapshot = EffectCache.getOrCompute(item, entity.cell, Fight.selfCell)

		// Get all cells from which we can hit this target
		Array<Cell> cells = Targets.getCellsToUseItemOnCell(item, entity.cell, [Fight.self.id])
		for (Cell c in cells) {
			Action? action = MapAction.addActionWithSnapshot(item, c, entity.cell, snapshot)
			if (action != null) {
				MapAction.addEntityIndex(item, entity.id, c, entity.cell, action!.score!)
			}
		}
	}

	/*
	 * AREA_LASER_LINE: laser actions (targets depend on fromCell)
	 */
	static void _populateLaserActions(Item item, Entity entity) {
		// Can't laser self
		if (entity == Fight.self) return;

		Array<Cell> cellsFrom = Targets.getLazerCellsToUseItemOnCell(item, entity.cell)
		for (Cell cell in cellsFrom) {
			Action? action = MapAction.addAction(item, cell, entity.cell)
			if (action != null) {
				MapAction.addEntityIndex(item, entity.id, cell, entity.cell, action!.score!)
			}
		}
	}

	/*
	 * AOE: area of effect actions (multiple aimCells per target)
	 */
	static void _populateAoeActions(Item item, Entity entity) {
		// Can't AOE self
		if (entity == Fight.self) return;

		for (Cell aimCell in entity.cell.getAreaCells(item.area)) {
			// Pre-compute snapshot for efficiency (shared across all cells)
			EffectSnapshot? snapshot = EffectCache.getOrCompute(item, aimCell, Fight.selfCell)

			Array<Cell> cells = Targets.getCellsToUseItemOnCell(item, aimCell, [Fight.self.id])
			for (Cell c in cells) {
				Action? action = MapAction.addActionWithSnapshot(item, c, aimCell, snapshot)
				if (action != null) {
					MapAction.addEntityIndex(item, entity.id, c, aimCell, action!.score!)
				}
			}
		}
	}

	static Map<Cell, Map<Item, Action>> getMapBestAction(){
		return _cell_item_bestAction
	}

	/*
	 * Add entity index for PTS O(1) lookup
	 * @param item The item being used
	 * @param entityId The target entity's ID
	 * @param fromCell The cell from which the action can be performed
	 * @param aimCell The cell to aim at (entity.cell for point/laser, specific cell for AOE)
	 * @param score The action score - keeps aimCell with best score per (item, entity, attackCell)
	 */
	static void addEntityIndex(Item item, integer entityId, Cell fromCell, Cell aimCell, real score) {
		// Initialize nested maps if needed
		if (!_item_entityId_attackCells[item]) _item_entityId_attackCells[item] = [:]
		if (!_item_entityId_attackCells[item]![entityId]) _item_entityId_attackCells[item]![entityId] = [:]
		if (!_item_entityId_scores[item]) _item_entityId_scores[item] = [:]
		if (!_item_entityId_scores[item]![entityId]) _item_entityId_scores[item]![entityId] = [:]

		// Keep aimCell with best score (fixes AOE: best aimCell instead of first)
		real? existingScore = _item_entityId_scores[item]![entityId]![fromCell]
		if (existingScore == null || score > existingScore!) {
			_item_entityId_attackCells[item]![entityId]![fromCell] = aimCell
			_item_entityId_scores[item]![entityId]![fromCell] = score
		}
	}

	/*
	 * Get attack cells for a specific (item, entityId) pair - used by PTS
	 * Returns Map<Cell, Cell> where key=attackCell, value=aimCell
	 * Returns null if no valid attack cells exist
	 */
	static Map<Cell, Cell>? getAttackCellsForEntity(Item item, integer entityId) {
		if (_item_entityId_attackCells[item] == null) return null
		return _item_entityId_attackCells[item]![entityId]
	}

	/*
	 * Get scores for a specific (item, entityId) pair
	 * Returns Map<Cell, real> where key=attackCell, value=best score from that cell
	 */
	static Map<Cell, real>? getScoresForEntity(Item item, integer entityId) {
		if (_item_entityId_scores[item] == null) return null
		return _item_entityId_scores[item]![entityId]
	}

	/*
	 * Core logic: create action, add to maps.
	 * Called after reachability check and snapshot computation.
	 * Caller must call Benchmark.start("addAction") before; this handles stop.
	 */
	static Action? addActionCore(Item item, Cell from, Cell targetCell, EffectSnapshot? snapshot) {
		Action action
		if (snapshot != null) {
			action = new Action(item, from, targetCell, snapshot!)
		} else {
			action = new Action(item, from, targetCell)
		}

		// ajout dans la map par item puis cells
		if(!_item_cell_actions[item]) _item_cell_actions[item] = [:]
		if(!_item_cell_actions[item]![from]) _item_cell_actions[item]![from] = []
		push(_item_cell_actions[item]![from]!, action)

		// ajout dans la map par cell puis items
		if(!_cell_item_actions[from]) _cell_item_actions[from] = [:]
		if(!_cell_item_actions[from]![item]) _cell_item_actions[from]![item] = []
		push(_cell_item_actions[from]![item]!, action)

		// ici, je ne set sur chaque case, pour chaque item, que la meilleure action et pas les autres
		if(!_cell_item_bestAction[from]) _cell_item_bestAction[from] = [:]
		if(!_cell_item_bestAction[from]![item]) _cell_item_bestAction[from]![item] = action
		else if(_cell_item_bestAction[from]![item]!.score < action.score) _cell_item_bestAction[from]![item] = action

		_actionsCreated++
		Benchmark.stop("addAction")
		return action
	}

	/*
	 * Add action with pre-fetched snapshot (avoids redundant cache lookup)
	 * Used when caller already checked snapshot for early filtering
	 */
	static Action? addActionWithSnapshot(Item item, Cell from, Cell targetCell, EffectSnapshot? snapshot) {
		if (targetCell != Fight.selfCell && Fight.self.extendedReachableCells[from] == null) return null
		Benchmark.start("addAction")
		return MapAction.addActionCore(item, from, targetCell, snapshot)
	}

	static Action? addAction(Item item, Cell from, Cell targetCell) {
		if (targetCell != Fight.selfCell && Fight.self.extendedReachableCells[from] == null) return null
		Benchmark.start("addAction")

		EffectSnapshot? snapshot = null
		if (item.area == AREA_LASER_LINE) {
			snapshot = EffectCache.getOrComputeLaser(item, from, targetCell)
		} else {
			snapshot = EffectCache.getOrCompute(item, targetCell, from)
		}

		return MapAction.addActionCore(item, from, targetCell, snapshot)
	}
}
