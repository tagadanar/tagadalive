class MapAction {
	static Map<Item, Map<Cell, Array<Action>>> _item_cell_actions // [item:[cell:[actions]]]
	static Map<Cell, Map<Item, Array<Action>>> _cell_item_actions // [cell:[item:[actions]]]
	static Map<Cell, Map<Item, Action>> _cell_item_bestAction // [cell:[item:action]]
	// PTS index: [item][entityId] = attackCells for O(1) lookup
	static Map<Item, Map<integer, Map<Cell, Cell>>> _item_entityId_attackCells
	// PTS index for AOE: [item][entityId][fromCell] = aimCell
	static Map<Item, Map<integer, Map<Cell, Cell>>> _item_entityId_aimCells

	static void refresh() {
		// remise à zéro des maps
		_item_cell_actions = [:]
		_cell_item_actions = [:]
		_cell_item_bestAction = [:]
		_item_entityId_attackCells = [:]
		_item_entityId_aimCells = [:]
		// pour chaque item
		for(Item item in Fight.self.items){
			// si j'ai le cooldown
			if(getCooldown(item.id, Fight.self.id) > 0) continue
			// selon l'area de l'item
			if(item.area == AREA_POINT){
				// pour chaque cible valide de l'item
				for(Entity entity in item.targetSet()){
					if(entity.isInvincible && !entity.isFriend) continue // skip invincible enemies
					if(entity==Fight.self){
						// si c'est moi la cible, je peux le lancer sur moi même que si la minrange le permet
						if(item.minRange == 0){
							if(MapAction.addAction(item, Fight.selfCell, Fight.selfCell)) {
								MapAction.addEntityIndex(item, entity.id, Fight.selfCell, null)
							}
						}
					} else {
						// sinon je liste toutes les cases depuis lesquelles je peux tirer sur la cible
						Array<Cell> cells = Targets.getCellsToUseItemOnCell(item, entity.cell, [Fight.self.id])
						for(Cell c in cells) {
							if(MapAction.addAction(item, c, entity.cell)) {
								MapAction.addEntityIndex(item, entity.id, c, null)
							}
						}
					}
				}
			}else if(item.area == AREA_LASER_LINE){
				for(Entity entity in item.targetSet()){
					if(entity.isInvincible && !entity.isFriend) continue // skip invincible enemies
					if(entity==Fight.self) continue; // on peut jamais se tirer dessus au lazer
					Array<Cell> cellsFrom = Targets.getLazerCellsToUseItemOnCell(item, entity.cell)
					for(Cell cell in cellsFrom){
						if(MapAction.addAction(item, cell, entity.cell)) {
							MapAction.addEntityIndex(item, entity.id, cell, null)
						}
					}
				}
				// maybe here I should handle AREA_FIRST_INLINE ?
			}else{ // every aoe
				for(Entity entity in item.targetSet()){
					if(entity.isInvincible && !entity.isFriend) continue // skip invincible enemies
					if(entity==Fight.self) continue
					// TODO réfléchir à l'implem de ce genre de move sur case vide..
					// si c'est moi la cible, si la minrange le permet, visez les cells proche ?
					// if(entity==Fight.self && item.minRange <= ?){}
					for(Cell aimCell in entity.cell.getAreaCells(item.area)){
						Array<Cell> cells = Targets.getCellsToUseItemOnCell(item, aimCell, [Fight.self.id])
						for(Cell c in cells) {
							if(MapAction.addAction(item, c, aimCell)) {
								MapAction.addEntityIndex(item, entity.id, c, aimCell)
							}
						}
					}
				}
			}
		}
	}
	
	static Map<Cell, Map<Item, Action>> getMapBestAction(){
		return _cell_item_bestAction
	}
	
	/*
	 * Add entity index for PTS O(1) lookup
	 * @param item The item being used
	 * @param entityId The target entity's ID
	 * @param fromCell The cell from which the action can be performed
	 * @param aimCell For AOE: the cell to aim at (null for AREA_POINT/LASER)
	 */
	static void addEntityIndex(Item item, integer entityId, Cell fromCell, Cell? aimCell) {
		// Initialize nested maps if needed
		if (!_item_entityId_attackCells[item]) _item_entityId_attackCells[item] = [:]
		if (!_item_entityId_attackCells[item]![entityId]) _item_entityId_attackCells[item]![entityId] = [:]

		// Add attack cell - Map auto-deduplicates (O(1) vs O(n) linear search)
		_item_entityId_attackCells[item]![entityId]![fromCell] = fromCell

		// For AOE: store the best aimCell (closest to target entity)
		if (aimCell != null) {
			if (!_item_entityId_aimCells[item]) _item_entityId_aimCells[item] = [:]
			if (!_item_entityId_aimCells[item]![entityId]) _item_entityId_aimCells[item]![entityId] = [:]
			// Only set if not already set (first aimCell found is used)
			if (_item_entityId_aimCells[item]![entityId]![fromCell] == null) {
				_item_entityId_aimCells[item]![entityId]![fromCell] = aimCell
			}
		}
	}

	/*
	 * Get attack cells for a specific (item, entityId) pair - used by PTS
	 * Returns null if no valid attack cells exist
	 * Returns Map<Cell, Cell> for O(1) dedup - iterate directly with for(Cell c in map)
	 */
	static Map<Cell, Cell>? getAttackCellsForEntity(Item item, integer entityId) {
		if (_item_entityId_attackCells[item] == null) return null
		return _item_entityId_attackCells[item]![entityId]
	}

	/*
	 * Get aim cell for AOE items from a specific attack cell - used by PTS
	 * Returns null for non-AOE items or if no mapping exists
	 */
	static Cell? getAimCellForEntity(Item item, integer entityId, Cell fromCell) {
		if (_item_entityId_aimCells[item] == null) return null
		if (_item_entityId_aimCells[item]![entityId] == null) return null
		return _item_entityId_aimCells[item]![entityId]![fromCell]
	}

	static boolean addAction(Item item, Cell from, Cell targetCell){
		if(targetCell != Fight.selfCell &&
		   (Fight.self.reachableCells[from]==null || Fight.self.reachableCells[from] > Fight.self.mp)) return false
		Benchmark.start("addAction")
		Action action = new Action(item, from, targetCell)

		// ajout dans la map par item puis cells
		if(!_item_cell_actions[item]) _item_cell_actions[item] = [:]
		if(!_item_cell_actions[item]![from]) _item_cell_actions[item]![from] = []
		push(_item_cell_actions[item]![from]!, action)

		// ajout dans la map par cell puis items
		if(!_cell_item_actions[from]) _cell_item_actions[from] = [:]
		if(!_cell_item_actions[from]![item]) _cell_item_actions[from]![item] = []
		push(_cell_item_actions[from]![item]!, action)

		// ici, je ne set sur chaque case, pour chaque item, que la meilleure action et pas les autres:
		// => réduction forte de la complexité
		// => pas de perte normalement si j'ai déjà check avant les effets qui change drastiquement le scoring, genre kill un leek
		// limitation > changement drastique de score après certain effet, genre libération.
		// maybe solution > implem un préscoring envisageant l'action précédente de debuff, doit pas y en avoir 40
		if(!_cell_item_bestAction[from]) _cell_item_bestAction[from] = [:]
		if(!_cell_item_bestAction[from]![item]) _cell_item_bestAction[from]![item] = action
		else if(_cell_item_bestAction[from]![item]!.score < action.score) _cell_item_bestAction[from]![item] = action
		Benchmark.stop("addAction")
		return true
	}
}