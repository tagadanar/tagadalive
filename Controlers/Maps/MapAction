class MapAction {
	static Map<Item, Map<Cell, Array<Action>>> _item_cell_actions // [item:[cell:[actions]]]
	static Map<Cell, Map<Item, Array<Action>>> _cell_item_actions // [cell:[item:[actions]]]
	static Map<Cell, Map<Item, Action>> _cell_item_bestAction // [cell:[item:action]]
	// PTS index: [item][entityId][attackCell] = aimCell for O(1) lookup
	// Unified index - attackCell maps directly to its aimCell (no separate aimCells map)
	static Map<Item, Map<integer, Map<Cell, Cell>>> _item_entityId_attackCells
	// Score index: stores best score per (item, entityId, attackCell) - keeps best aimCell
	static Map<Item, Map<integer, Map<Cell, real>>> _item_entityId_scores

	static void refresh() {
		// remise à zéro des maps
		_item_cell_actions = [:]
		_cell_item_actions = [:]
		_cell_item_bestAction = [:]
		_item_entityId_attackCells = [:]
		_item_entityId_scores = [:]
		// Clear effect cache for new turn
		EffectCache.clear()
		// pour chaque item
		for(Item item in Fight.self.items){
			// si j'ai le cooldown
			if(getCooldown(item.id, Fight.self.id) > 0) continue
			// Handle summon chips as self-cast (cell chosen at execution time)
			if (item.isSummon) {
				MapAction.addAction(item, Fight.selfCell, Fight.selfCell)
				continue
			}
			// selon l'area de l'item
			if(item.area == AREA_POINT){
				// pour chaque cible valide de l'item
				for(Entity entity in item.targetSet()){
					if(entity.isInvincible && !entity.isFriend) continue // skip invincible enemies
					if(entity==Fight.self){
						// si c'est moi la cible, je peux le lancer sur moi même que si la minrange le permet
						if(item.minRange == 0){
							Action? action = MapAction.addAction(item, Fight.selfCell, Fight.selfCell)
							if(action != null) {
								MapAction.addEntityIndex(item, entity.id, Fight.selfCell, Fight.selfCell, action!.score!)
							}
						}
					} else {
						// Pre-check snapshot before cells loop (optimization)
						EffectSnapshot? snapshot = EffectCache.getOrCompute(item, entity.cell, Fight.selfCell)
						if (snapshot != null && MapAction.shouldFilterSnapshot(snapshot!)) continue // Skip entire target

						// sinon je liste toutes les cases depuis lesquelles je peux tirer sur la cible
						Array<Cell> cells = Targets.getCellsToUseItemOnCell(item, entity.cell, [Fight.self.id])
						for(Cell c in cells) {
							Action? action = MapAction.addActionWithSnapshot(item, c, entity.cell, snapshot)
							if(action != null) {
								MapAction.addEntityIndex(item, entity.id, c, entity.cell, action!.score!)
							}
						}
					}
				}
			}else if(item.area == AREA_LASER_LINE){
				for(Entity entity in item.targetSet()){
					if(entity.isInvincible && !entity.isFriend) continue // skip invincible enemies
					if(entity==Fight.self) continue; // on peut jamais se tirer dessus au lazer
					Array<Cell> cellsFrom = Targets.getLazerCellsToUseItemOnCell(item, entity.cell)
					for(Cell cell in cellsFrom){
						Action? action = MapAction.addAction(item, cell, entity.cell)
						if(action != null) {
							MapAction.addEntityIndex(item, entity.id, cell, entity.cell, action!.score!)
						}
					}
				}
				// maybe here I should handle AREA_FIRST_INLINE ?
			}else{ // every aoe
				for(Entity entity in item.targetSet()){
					if(entity.isInvincible && !entity.isFriend) continue // skip invincible enemies
					if(entity==Fight.self) continue
					// TODO réfléchir à l'implem de ce genre de move sur case vide..
					// si c'est moi la cible, si la minrange le permet, visez les cells proche ?
					// if(entity==Fight.self && item.minRange <= ?){}
					for(Cell aimCell in entity.cell.getAreaCells(item.area)){
						// Pre-check snapshot before cells loop (optimization)
						EffectSnapshot? snapshot = EffectCache.getOrCompute(item, aimCell, Fight.selfCell)
						if (snapshot != null && MapAction.shouldFilterSnapshot(snapshot!)) continue // Skip this aimCell

						Array<Cell> cells = Targets.getCellsToUseItemOnCell(item, aimCell, [Fight.self.id])
						for(Cell c in cells) {
							Action? action = MapAction.addActionWithSnapshot(item, c, aimCell, snapshot)
							if(action != null) {
								MapAction.addEntityIndex(item, entity.id, c, aimCell, action!.score!)
							}
						}
					}
				}
			}
		}
		// Log cache stats at end of action pool creation
		EffectCache.logStats()
	}

	static Map<Cell, Map<Item, Action>> getMapBestAction(){
		return _cell_item_bestAction
	}

	/*
	 * Add entity index for PTS O(1) lookup
	 * @param item The item being used
	 * @param entityId The target entity's ID
	 * @param fromCell The cell from which the action can be performed
	 * @param aimCell The cell to aim at (entity.cell for point/laser, specific cell for AOE)
	 * @param score The action score - keeps aimCell with best score per (item, entity, attackCell)
	 */
	static void addEntityIndex(Item item, integer entityId, Cell fromCell, Cell aimCell, real score) {
		// Initialize nested maps if needed
		if (!_item_entityId_attackCells[item]) _item_entityId_attackCells[item] = [:]
		if (!_item_entityId_attackCells[item]![entityId]) _item_entityId_attackCells[item]![entityId] = [:]
		if (!_item_entityId_scores[item]) _item_entityId_scores[item] = [:]
		if (!_item_entityId_scores[item]![entityId]) _item_entityId_scores[item]![entityId] = [:]

		// Keep aimCell with best score (fixes AOE: best aimCell instead of first)
		real? existingScore = _item_entityId_scores[item]![entityId]![fromCell]
		if (existingScore == null || score > existingScore!) {
			_item_entityId_attackCells[item]![entityId]![fromCell] = aimCell
			_item_entityId_scores[item]![entityId]![fromCell] = score
		}
	}

	/*
	 * Get attack cells for a specific (item, entityId) pair - used by PTS
	 * Returns Map<Cell, Cell> where key=attackCell, value=aimCell
	 * Returns null if no valid attack cells exist
	 */
	static Map<Cell, Cell>? getAttackCellsForEntity(Item item, integer entityId) {
		if (_item_entityId_attackCells[item] == null) return null
		return _item_entityId_attackCells[item]![entityId]
	}

	/*
	 * Get scores for a specific (item, entityId) pair
	 * Returns Map<Cell, real> where key=attackCell, value=best score from that cell
	 */
	static Map<Cell, real>? getScoresForEntity(Item item, integer entityId) {
		if (_item_entityId_scores[item] == null) return null
		return _item_entityId_scores[item]![entityId]
	}

	/*
	 * Check if a snapshot should be filtered out (score < 0 with no Liberation combo potential)
	 */
	static boolean shouldFilterSnapshot(EffectSnapshot snapshot) {
		if (snapshot.effectScore >= 0) return false
		// Score < 0: check if Liberation could help (has raw damage blocked by shields)
		if (Fight.liberationReady && snapshot.rawEnemyDamage > 0) return false
		return true
	}

	/*
	 * Core logic: create action, filter, add to maps.
	 * Called after reachability check and snapshot computation.
	 * Caller must call Benchmark.start("addAction") before; this handles stop.
	 */
	static Action? addActionCore(Item item, Cell from, Cell targetCell, EffectSnapshot? snapshot) {
		Action action
		if (snapshot != null) {
			action = new Action(item, from, targetCell, snapshot!)
		} else {
			action = new Action(item, from, targetCell)
		}

		// Filter negative score actions (but keep if Liberation combo potential)
		if (action.score != null && action.score! < 0) {
			if (snapshot == null || !Fight.liberationReady || snapshot!.rawEnemyDamage <= 0) {
				Benchmark.stop("addAction")
				return null
			}
		}

		// ajout dans la map par item puis cells
		if(!_item_cell_actions[item]) _item_cell_actions[item] = [:]
		if(!_item_cell_actions[item]![from]) _item_cell_actions[item]![from] = []
		push(_item_cell_actions[item]![from]!, action)

		// ajout dans la map par cell puis items
		if(!_cell_item_actions[from]) _cell_item_actions[from] = [:]
		if(!_cell_item_actions[from]![item]) _cell_item_actions[from]![item] = []
		push(_cell_item_actions[from]![item]!, action)

		// ici, je ne set sur chaque case, pour chaque item, que la meilleure action et pas les autres
		if(!_cell_item_bestAction[from]) _cell_item_bestAction[from] = [:]
		if(!_cell_item_bestAction[from]![item]) _cell_item_bestAction[from]![item] = action
		else if(_cell_item_bestAction[from]![item]!.score < action.score) _cell_item_bestAction[from]![item] = action
		Benchmark.stop("addAction")
		return action
	}

	/*
	 * Add action with pre-fetched snapshot (avoids redundant cache lookup)
	 * Used when caller already checked snapshot for early filtering
	 */
	static Action? addActionWithSnapshot(Item item, Cell from, Cell targetCell, EffectSnapshot? snapshot) {
		if (targetCell != Fight.selfCell && Fight.self.extendedReachableCells[from] == null) return null
		Benchmark.start("addAction")
		return MapAction.addActionCore(item, from, targetCell, snapshot)
	}

	static Action? addAction(Item item, Cell from, Cell targetCell) {
		if (targetCell != Fight.selfCell && Fight.self.extendedReachableCells[from] == null) return null
		Benchmark.start("addAction")

		EffectSnapshot? snapshot = null
		if (item.area == AREA_LASER_LINE) {
			snapshot = EffectCache.getOrComputeLaser(item, from, targetCell)
			if (snapshot != null && MapAction.shouldFilterSnapshot(snapshot!)) {
				Benchmark.stop("addAction")
				return null
			}
		} else {
			snapshot = EffectCache.getOrCompute(item, targetCell, from)
		}

		return MapAction.addActionCore(item, from, targetCell, snapshot)
	}
}
