/*
 * ItemTarget: tuple for sorted exploration
 * Holds (item, target, score) for priority ordering
 */
class ItemTarget {
	Item item
	Entity target
	real score

	constructor(Item item, Entity target, real score) {
		this.item = item
		this.target = target
		this.score = score
	}
}

class MapAction {
	static Map<Item, Map<Cell, Array<Action>>> _item_cell_actions // [item:[cell:[actions]]]
	static Map<Cell, Map<Item, Array<Action>>> _cell_item_actions // [cell:[item:[actions]]]
	static Map<Cell, Map<Item, Action>> _cell_item_bestAction // [cell:[item:action]]
	// PTS index: [item][entityId][attackCell] = aimCell for O(1) lookup
	// Unified index - attackCell maps directly to its aimCell (no separate aimCells map)
	static Map<Item, Map<integer, Map<Cell, Cell>>> _item_entityId_attackCells
	// Score index: stores best score per (item, entityId, attackCell) - keeps best aimCell
	static Map<Item, Map<integer, Map<Cell, real>>> _item_entityId_scores
	// Entity items index: entityId -> Set of items that can target this entity (for post-inversion pool)
	static Map<integer, Set<Item>> _entityTargetedItems

	// Budget: 80% of max operations
	static real BUDGET_RATIO = 0.8
	// Counter for actions created during refresh (for guaranteed minimum)
	static integer _actionsCreated = 0

	static void refresh() {
		// Reset maps
		_item_cell_actions = [:]
		_cell_item_actions = [:]
		_cell_item_bestAction = [:]
		_item_entityId_attackCells = [:]
		_item_entityId_scores = [:]
		_entityTargetedItems = [:]
		_actionsCreated = 0
		// Clear effect cache for new turn
		EffectCache.clear()

		// Compute budget threshold
		integer actionBudget = (getMaxOperations() * BUDGET_RATIO) as integer

		// ═══════════════════════════════════════════════════════════════════
		// PHASE 1: Score all (item, target) pairs
		// ═══════════════════════════════════════════════════════════════════
		Array<ItemTarget> tuples = []

		for (Item item in Fight.self.items) {
			// Skip if on cooldown
			if (getCooldown(item.id, Fight.self.id) > 0) continue

			// Handle resurrection: find safe cell for dead ally
			if (item.id == CHIP_RESURRECTION) {
				PendingResurrect? candidate = MapSummon.getResurrectionCandidate()
				if (candidate != null) {
					// Don't use addSummonAction - it uses bulb scoring which returns 0
					// Use resurrection-specific scoring: KILL_VALUE * 10
					Action? resAction = MapAction.addResurrectionAction(item, candidate!.fromCell, candidate!.spawnCell)
					if (resAction != null) {
						debug("RESU ACTION: score=" + resAction!.score + " from=c" + candidate!.fromCell.id + " to=c" + candidate!.spawnCell.id + " target=e" + candidate!.entityId)
					}
				} else {
					debug("RESU: no candidate (ready=" + Fight.resurrectionReady + " targetId=" + Fight.resurrectTargetId + ")")
				}
				continue
			}

			// Handle summon chips: use MapSummon's best target cells, find fromCells like other items
			if (item.isSummon) {
				Array<SummonCandidate> candidates = MapSummon.getBestCells(item.id, 5)

				// If no candidates, create self-cast action (delayed spawn at final position)
				// Works for both defensive and offensive summons - bulb spawns at farthest valid cell
				if (count(candidates) == 0) {
					MapAction.addSummonAction(item, Fight.self.cell, Fight.selfCell)
					continue
				}

				for (SummonCandidate c in candidates) {
					// Get cells from which we can cast summon ON the target cell
					Array<Cell> fromCells = Targets.getCellsToUseItemOnCell(item, c.cell, [Fight.self.id])

					// Manually add selfCell if in range (getCellsToUseItemOnCell excludes occupied cells)
					integer distToTarget = getCellDistance(Fight.self.cell.id, c.cell.id)
					if (distToTarget >= item.minRange && distToTarget <= item.maxRange) {
						if (!item.needLOS || lineOfSight(Fight.self.cell.id, c.cell.id, [Fight.self.id])) {
							// Insert selfCell at beginning (most accessible)
							Array<Cell> withSelf = [Fight.self.cell]
							for (Cell fc in fromCells) push(withSelf, fc)
							fromCells = withSelf
						}
					}

					// Create actions for each reachable fromCell
					for (Cell fromCell in fromCells) {
						// Check reachability (selfCell always reachable, others need extendedReachableCells)
						if (fromCell != Fight.self.cell && Fight.self.maxExtendedReachableCells[fromCell] == null) continue
						MapAction.addSummonAction(item, fromCell, c.cell)
					}
				}
				continue
			}

			// Skip tactical chips (handled by MapTactical)
			if (item.isTactical) continue

			// Score each valid target for this item
			for (Entity entity in item.targetSet()) {
				// Skip invincible enemies unless item works on invincible (shackles)
				if (entity.isInvincible && !entity.isFriend && !item.worksOnInvincible) continue
				if (BossFennel.shouldNotTarget(entity)) continue

				// Compute score using direct hit on target
				EffectSnapshot? snapshot = EffectCache.getOrCompute(item, entity.cell, Fight.selfCell)
				real score = snapshot != null ? snapshot!.effectScore : 0

				push(tuples, new ItemTarget(item, entity, score))
			}
		}

		// ═══════════════════════════════════════════════════════════════════
		// PHASE 2: Sort by score descending
		// ═══════════════════════════════════════════════════════════════════
		tuples = arraySort(tuples, (ItemTarget a, ItemTarget b) -> b.score - a.score) as Array<ItemTarget>

		// ═══════════════════════════════════════════════════════════════════
		// PHASE 3: Populate actions (budget-aware)
		// ═══════════════════════════════════════════════════════════════════
		integer totalTuples = count(tuples)
		integer processed = 0

		for (ItemTarget tuple in tuples) {
			// Guarantee at least 3 actual actions (for bulbs starting late), then check budget
			if (_actionsCreated >= 3 && getOperations() > actionBudget) {
				MapAction._logEarlyExit(processed, totalTuples)
				EffectCache.logStats()
				return;
			}

			MapAction._populateActionsForTarget(tuple.item, tuple.target)
			processed++
		}

		// Log cache stats at end of action pool creation
		EffectCache.logStats()

	}

	/*
	 * Log early exit due to budget exhaustion
	 */
	static void _logEarlyExit(integer processed, integer total) {
		string entity = Fight.self.isBulb ? "bulb" : "leek"
		string msg = entity + " T" + getTurn() + " MapAction early exit @" + Benchmark.format(getOperations())
		msg += " | tuples:" + processed + "/" + total + " | actions:" + _actionsCreated
		debugW(msg)
	}

	/*
	 * Populate actions for a specific (item, target) pair
	 * Handles area-specific logic (POINT, LASER, AOE)
	 */
	static void _populateActionsForTarget(Item item, Entity entity) {
		if (item.area == AREA_POINT) {
			MapAction._populatePointActions(item, entity)
		} else if (item.area == AREA_LASER_LINE) {
			MapAction._populateLaserActions(item, entity)
		} else {
			MapAction._populateAoeActions(item, entity)
		}
	}

	/*
	 * AREA_POINT: single target actions
	 */
	static void _populatePointActions(Item item, Entity entity) {
		if (entity == Fight.self) {
			// Self-cast only if minRange allows
			if (item.minRange == 0) {
				Action? action = MapAction.addAction(item, Fight.selfCell, Fight.selfCell)
				if (action != null) {
					MapAction.addEntityIndex(item, entity.id, Fight.selfCell, Fight.selfCell, action!.score!)
				}
			}
			return;
		}

		// Pre-compute snapshot for efficiency (shared across all cells)
		EffectSnapshot? snapshot = EffectCache.getOrCompute(item, entity.cell, Fight.selfCell)

		// Early exit: if base score (before movement) is <= 0, skip all fromCells
		// For POINT items, snapshot is only null for self-cast (handled above)
		if (snapshot == null) return;
		if (snapshot!.effectScore - snapshot!.opportunityCost <= 0) return;

		// Get all cells from which we can hit this target
		Array<Cell> cells = Targets.getCellsToUseItemOnCell(item, entity.cell, [Fight.self.id])
		for (Cell c in cells) {
			Action? action = MapAction.addActionWithSnapshot(item, c, entity.cell, snapshot)
			if (action != null) {
				MapAction.addEntityIndex(item, entity.id, c, entity.cell, action!.score!)
			}
		}
	}

	/*
	 * AREA_LASER_LINE: laser actions (targets depend on fromCell)
	 */
	static void _populateLaserActions(Item item, Entity entity) {
		// Can't laser self
		if (entity == Fight.self) return;

		Array<Cell> cellsFrom = Targets.getLazerCellsToUseItemOnCell(item, entity.cell)
		for (Cell cell in cellsFrom) {
			Action? action = MapAction.addAction(item, cell, entity.cell)
			if (action != null) {
				MapAction.addEntityIndex(item, entity.id, cell, entity.cell, action!.score!)
			}
		}
	}

	/*
	 * AOE: area of effect actions (multiple aimCells per target)
	 */
	static void _populateAoeActions(Item item, Entity entity) {
		// Self-cast AoE only if minRange == 0 and item can target caster
		if (entity == Fight.self) {
			if (item.minRange == 0 && item.onCaster) {
				Action? action = MapAction.addAction(item, Fight.selfCell, Fight.selfCell)
				if (action != null) {
					MapAction.addEntityIndex(item, entity.id, Fight.selfCell, Fight.selfCell, action!.score!)
				}
			}
			return;
		}

		for (Cell aimCell in entity.cell.getAreaCells(item.area)) {
			// Pre-compute snapshot for efficiency (shared across all cells)
			EffectSnapshot? baseSnapshot = EffectCache.getOrCompute(item, aimCell, Fight.selfCell)

			// Early exit: if snapshot exists and base score is <= 0, skip all fromCells
			// Note: null snapshot means not cacheable (e.g., onCaster with self in AOE) - must still process
			if (baseSnapshot != null && baseSnapshot!.effectScore - baseSnapshot!.opportunityCost <= 0) continue

			// For onCaster AOE: pre-compute area cells to check if fromCell is inside AOE
			// (snapshot excludes self, but if fromCell is in AOE, self should be included)
			Set<Cell>? aoeCells = null
			if (item.onCaster) {
				aoeCells = aimCell.getAreaCells(item.area)
			}

			Array<Cell> cells = Targets.getCellsToUseItemOnCell(item, aimCell, [Fight.self.id])
			for (Cell c in cells) {
				EffectSnapshot? snapshot = baseSnapshot
				// Invalidate cache if this fromCell is inside AOE (self-damage not in snapshot)
				if (aoeCells != null && setContains(aoeCells!, c)) {
					snapshot = null
				}
				Action? action = MapAction.addActionWithSnapshot(item, c, aimCell, snapshot)
				if (action != null) {
					MapAction.addEntityIndex(item, entity.id, c, aimCell, action!.score!)
				}
			}
		}
	}

	static Map<Cell, Map<Item, Action>> getMapBestAction(){
		return _cell_item_bestAction
	}

	/*
	 * Get all items that can target a specific entity.
	 * Used by MapTactical for post-inversion pool generation.
	 */
	static Set<Item>? getItemsTargetingEntity(Entity entity) {
		return _entityTargetedItems[entity.id]
	}

	/*
	 * Add entity index for PTS O(1) lookup
	 * @param item The item being used
	 * @param entityId The target entity's ID
	 * @param fromCell The cell from which the action can be performed
	 * @param aimCell The cell to aim at (entity.cell for point/laser, specific cell for AOE)
	 * @param score The action score - keeps aimCell with best score per (item, entity, attackCell)
	 */
	static void addEntityIndex(Item item, integer entityId, Cell fromCell, Cell aimCell, real score) {
		// Initialize nested maps if needed
		if (!_item_entityId_attackCells[item]) _item_entityId_attackCells[item] = [:]
		if (!_item_entityId_attackCells[item]![entityId]) _item_entityId_attackCells[item]![entityId] = [:]
		if (!_item_entityId_scores[item]) _item_entityId_scores[item] = [:]
		if (!_item_entityId_scores[item]![entityId]) _item_entityId_scores[item]![entityId] = [:]

		// Keep aimCell with best score (fixes AOE: best aimCell instead of first)
		real? existingScore = _item_entityId_scores[item]![entityId]![fromCell]
		if (existingScore == null || score > existingScore!) {
			_item_entityId_attackCells[item]![entityId]![fromCell] = aimCell
			_item_entityId_scores[item]![entityId]![fromCell] = score
		}
	}

	/*
	 * Get attack cells for a specific (item, entityId) pair - used by PTS
	 * Returns Map<Cell, Cell> where key=attackCell, value=aimCell
	 * Returns null if no valid attack cells exist
	 */
	static Map<Cell, Cell>? getAttackCellsForEntity(Item item, integer entityId) {
		if (_item_entityId_attackCells[item] == null) return null
		return _item_entityId_attackCells[item]![entityId]
	}

	/*
	 * Get scores for a specific (item, entityId) pair
	 * Returns Map<Cell, real> where key=attackCell, value=best score from that cell
	 */
	static Map<Cell, real>? getScoresForEntity(Item item, integer entityId) {
		if (_item_entityId_scores[item] == null) return null
		return _item_entityId_scores[item]![entityId]
	}

	/*
	 * Register an action into all lookup maps.
	 */
	static void _registerAction(Item item, Cell from, Action action) {
		if(!_item_cell_actions[item]) _item_cell_actions[item] = [:]
		if(!_item_cell_actions[item]![from]) _item_cell_actions[item]![from] = []
		push(_item_cell_actions[item]![from]!, action)

		if(!_cell_item_actions[from]) _cell_item_actions[from] = [:]
		if(!_cell_item_actions[from]![item]) _cell_item_actions[from]![item] = []
		push(_cell_item_actions[from]![item]!, action)

		if(!_cell_item_bestAction[from]) _cell_item_bestAction[from] = [:]
		if(!_cell_item_bestAction[from]![item]) _cell_item_bestAction[from]![item] = action
		else if(_cell_item_bestAction[from]![item]!.score! < action.score!) _cell_item_bestAction[from]![item] = action

		_actionsCreated++
	}

	/*
	 * Core logic: create action, add to maps.
	 * Called after reachability check and snapshot computation.
	 * Caller must call Benchmark.start("addAction") before; this handles stop.
	 */
	static Action? addActionCore(Item item, Cell from, Cell targetCell, EffectSnapshot? snapshot) {
		Action action
		if (snapshot != null) {
			action = new Action(item, from, targetCell, snapshot!)
		} else {
			action = new Action(item, from, targetCell)
		}

		// Filter out actions with score <= 0 (not worth adding to maps)
		if (action.score <= 0) {
			Benchmark.stop("addAction")
			return null
		}

		MapAction._registerAction(item, from, action)

		// Index action and item by target entities (for inversion filtering)
		// Index items by target entity (for post-inversion ally support)
		for (Entity target in action.consequences.targets) {
			if (_entityTargetedItems[target.id] == null) {
				_entityTargetedItems[target.id] = <>
			}
			setPut(_entityTargetedItems[target.id]!, item)
		}

		Benchmark.stop("addAction")
		return action
	}

	/*
	 * Add action with pre-fetched snapshot (avoids redundant cache lookup)
	 * Used when caller already checked snapshot for early filtering
	 */
	static Action? addActionWithSnapshot(Item item, Cell from, Cell targetCell, EffectSnapshot? snapshot) {
		if (targetCell != Fight.selfCell && Fight.self.maxExtendedReachableCells[from] == null) return null
		Benchmark.start("addAction")
		return MapAction.addActionCore(item, from, targetCell, snapshot)
	}

	static Action? addAction(Item item, Cell from, Cell targetCell) {
		if (targetCell != Fight.selfCell && Fight.self.maxExtendedReachableCells[from] == null) return null
		Benchmark.start("addAction")

		EffectSnapshot? snapshot = null
		if (item.area == AREA_LASER_LINE) {
			snapshot = EffectCache.getOrComputeLaser(item, from, targetCell)
		} else {
			snapshot = EffectCache.getOrCompute(item, targetCell, from)
		}

		return MapAction.addActionCore(item, from, targetCell, snapshot)
	}

	/*
	 * Add summon action with direct score computation (bypasses EffectCache).
	 * Summons don't target existing entities, so we compute score from EffectHandlers.summon().
	 */
	static Action? addSummonAction(Item item, Cell from, Cell targetCell) {
		if (from != Fight.self.cell && Fight.self.maxExtendedReachableCells[from] == null) return null
		Benchmark.start("addAction")

		// Create action without snapshot (summons don't affect existing entities)
		Action action = new Action(item, from, targetCell)

		// Set score directly from summon scoring logic (includes expected damage)
		action.score = EffectHandlers.summon(item, Fight.self.level, targetCell)

		// Filter out actions with score <= 0 (not worth adding to maps)
		if (action.score! <= 0) {
			Benchmark.stop("addAction")
			return null
		}

		MapAction._registerAction(item, from, action)
		Benchmark.stop("addAction")
		return action
	}

	/*
	 * Add resurrection action with proper scoring.
	 * Unlike summons, resurrection uses KILL_VALUE scoring (inverse of ally death).
	 */
	static Action? addResurrectionAction(Item item, Cell from, Cell targetCell) {
		if (from != Fight.self.cell && Fight.self.maxExtendedReachableCells[from] == null) return null
		Benchmark.start("addAction")

		Action action = new Action(item, from, targetCell)

		// Resurrection score (inverse of ally death, discounted)
		action.score = ScoringConfig.RESURRECT_VALUE

		MapAction._registerAction(item, from, action)
		Benchmark.stop("addAction")
		return action
	}

	/*
	 * Generate buff actions that can target a specific cell (for pending entity).
	 * Called by ComboBuilder after a summon or resurrection action creates a
	 * PendingBulb or PendingResurrect at the target cell.
	 *
	 * @param targetCell Cell where the pending entity will appear
	 * @param fromCell Current cell of the caster
	 * @param remainingMP Available MP for movement
	 * @param remainingTP Available TP for buffs
	 * @param usesThisTurn Items already used (to respect maxUse)
	 * @param cellsToIgnore Cells to ignore in pathfinding
	 * @return Array of buff Actions targeting the cell
	 */
	static Array<Action> getPendingBuffActions(
		Cell targetCell,
		Cell fromCell,
		integer remainingMP,
		integer remainingTP,
		Map<Item, integer> usesThisTurn,
		Set<Cell> cellsToIgnore
	) {
		Array<Action> result = []

		// Get reachable cells from current position
		Map<Cell, integer> reachable = MapPath.getCachedReachableCells(fromCell, remainingMP, cellsToIgnore)

		for (Item chip in Fight.self.items) {
			// Skip weapons, summons, and tactical chips
			if (chip.isWeap || chip.isSummon || chip.isTactical) continue

			// Skip if on cooldown
			if (getCooldown(chip.id, Fight.self.id) > 0) continue

			// Skip if already used >= maxUse
			integer uses = usesThisTurn[chip] != null ? usesThisTurn[chip]! : 0
			if (uses >= chip.maxUse) continue

			// Skip if cost > remaining TP
			if (chip.cost > remainingTP) continue

			// Get cells from which we can target the pending entity cell
			// Use getTargetableCells which includes occupied cells (the bulb is at targetCell)
			Array<Cell> castCells = Targets.getTargetableCells(chip, targetCell, [Fight.self.id])

			// Find reachable cast cells
			for (Cell castCell in castCells) {
				// Check if castCell is reachable
				integer? dist = reachable[castCell]
				boolean castCellReachable = (castCell == fromCell) || (dist != null && dist! <= remainingMP)
				if (!castCellReachable) continue

				// Create action targeting the pending entity cell
				Action action = Action(chip, castCell, targetCell)
				push(result, action)
				break  // Only need one cast cell per chip (best is closest which we'll find)
			}
		}

		return result
	}

}
