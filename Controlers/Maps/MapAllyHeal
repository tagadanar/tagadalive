/*
 * Ensemble de méthodes et d'algorithmes permettant de calculer le heal potentiel des alliés sur chaque case
 * Similaire à MapDanger mais pour les heals alliés (ignore les entités dans la LOS, comme MapDanger)
 */
class MapAllyHeal {
	// === Configuration ===
	// Nombre max d'items de heal par allié à considérer (0 = illimité/tous les items)
	static integer HEAL_ITEMS_LIMIT = 4

	// Cache du heal estimé sur la case, reset à chaque tour
	static Map<Cell, HealPotential> _heal = [:] // [cell:HealPotential]
	static Map<integer, Map<Cell, HealPotential>> _hash_heal = [:] // [consequences.hash:[cell:HealPotential]]

	// Cache contenant pour chaque item, pour chaque case, les cases ciblables
	// Ignore les entités dans la LOS (comme MapDanger) - cache global car le résultat ne dépend pas de l'allié
	static Map<Item, Map<Cell, Array<Cell>>> _cache_item_targetableCells = [:] // [item:[fromCell:[targetCells]]]

	// Cache pour chaque allié des maps des cases où il peut heal
	// Refresh à chaque tour
	static Map<Entity, Map<Item, Map<Cell, real>>> _map_ally_item_heal = [:] // [ally:[item:[cell:ratio]]]

	// Items de heal par allié (configuré via ScoringConfig.ALLY_HEAL_ITEMS_LIMIT)
	static Map<Entity, Array<Item>> _ally_heal_items = [:] // [ally:[items]]

	// === Allies array (populated by collectAllies, used by processRound) ===
	static Array<Entity> _allies = []

	/*
	 * Reset per-turn caches. Called by MapDanger.refresh() at start.
	 * Note: _cache_item_targetableCells is NOT reset (valid across turns)
	 */
	static void resetCaches() {
		_heal = [:]
		_hash_heal = [:]
		_map_ally_item_heal = [:]
		_ally_heal_items = [:]
		_allies = []
	}

	/*
	 * Collect allies and prepare their heal items.
	 * Called by MapDanger.refresh() during Phase 1.
	 * @return maxItems - maximum number of heal items across all allies
	 */
	static integer collectAllies() {
		integer maxItems = 0
		for (Entity ally in Fight.getAlliesAlive()) {
			if (ally == Fight.self) continue

			_map_ally_item_heal[ally] = [:]
			Array<Item> healItems = Items.getOrderedHealItems(ally, HEAL_ITEMS_LIMIT)
			_ally_heal_items[ally] = healItems
			push(_allies, ally)
			integer itemCount = count(healItems)
			if (itemCount > maxItems) maxItems = itemCount
		}
		return maxItems
	}

	/*
	 * Process round i: compute heal map for item[i] of all allies.
	 * Called by MapDanger.refresh() in interleaved round-robin.
	 * @param i - item index to process
	 */
	static void processRound(integer i) {
		for (Entity ally in _allies) {
			Array<Item>? healItems = _ally_heal_items[ally]
			if (healItems != null && i < count(healItems!)) {
				Item item = healItems![i]
				_map_ally_item_heal[ally]![item] = MapAllyHeal.getAllyHealMap(ally, item)
			}
		}
	}

	/*
	 * Build early exit stats string for allies.
	 * Called by MapDanger.refresh() when budget exceeded.
	 * @param round - current round number (0-indexed)
	 * @return stats string like "Bulb1:2/3 Bulb2:2/4"
	 */
	static string getEarlyExitStats(integer round) {
		string stats = ""
		for (Entity ally in _allies) {
			Array<Item>? items = _ally_heal_items[ally]
			integer total = items != null ? count(items!) : 0
			integer done = min(round + 1, total)
			if (stats != "") stats += " "
			stats += ally.name + ":" + done + "/" + total
		}
		return stats
	}

	/*
	 * Standalone refresh (for testing or when not using interleaved mode).
	 * In production, MapDanger.refresh() orchestrates both maps.
	 */
	static void refresh() {
		MapAllyHeal.resetCaches()
		integer maxItems = MapAllyHeal.collectAllies()
		for (integer i = 0; i < maxItems; i++) {
			MapAllyHeal.processRound(i)
		}
	}

	/*
	 * Pour les cellules accessibles par l'allié, initialise un tableau contenant les cases qu'il peut cibler avec l'item
	 * @info Ignore les entités dans la LOS (comme MapDanger.getEnemiesDmgMap)
	 * @param ally Entity allié
	 * @param item Item de heal
	 * @return map de Cells ciblables avec ratio (1.0 pour hit direct)
	 */
	static Map<Cell, real> getAllyHealMap(Entity ally, Item item) {
		Map<Cell, real> map = [:]

		for (Cell cell : integer dist in ally.reachableCells) {
			if (dist > ally.mp) break
			Array<Cell> targetableCells = MapAllyHeal.getAllyTargetableCells(item, cell)
			for (Cell c in targetableCells) {
				if (map[c] == null) {
					map[c] = 1.0 // ratio
				}
			}
		}

		// Expansion AOE pour les heals de zone
		if (item.area == AREA_CIRCLE_1 || item.area == AREA_CIRCLE_2 || item.area == AREA_CIRCLE_3) {
			for (integer distance = 1; distance <= item.area - 2; distance++) {
				real ratio = 1 - 0.2 * distance
				if (ratio <= 0) break
				Array<Cell> circle = []
				for (Cell c : real value in map) {
					if (value > 0) {
						for (Cell neighbor in c.neighborsObstacles) {
							if (map[neighbor] == null || map[neighbor] == 0) {
								push(circle, neighbor)
							}
						}
					}
				}
				for (Cell cell in circle) {
					map[cell] = ratio
				}
			}
		}

		return map
	}

	/*
	 * Retourne les Cells pouvant être ciblées depuis la @cell avec l'@item (ignore les entités dans la LOS)
	 * @param item Item de heal
	 * @param cell Cellule depuis laquelle l'allié tire
	 * @return Array de cellules ciblables
	 */
	static Array<Cell> getAllyTargetableCells(Item item, Cell cell) {
		// Init du cache si nécessaire
		if (_cache_item_targetableCells[item] == null) {
			_cache_item_targetableCells[item] = [:]
		}
		if (_cache_item_targetableCells[item]![cell] == null) {
			// Ignore toutes les entités dans la LOS (comme MapDanger.getEnemiesTargetableCells)
			_cache_item_targetableCells[item]![cell] = Targets.getTargetableCells(item, cell, Fight.allEntitiesId)
		}

		return _cache_item_targetableCells[item]![cell]!
	}

	/*
	 * Calcule le heal potentiel d'une Cell, version sans Conséquences
	 * @param cell la case sur laquelle on veut le heal potentiel
	 * @return HealPotential
	 */
	static HealPotential getCellHeal(Cell cell) {
		return MapAllyHeal.getCellHeal(cell, null)
	}

	/*
	 * Renvoie le cache du heal potentiel d'une Cell, le calcule si pas déjà calculé
	 * @param cell Cellule sur laquelle le heal va être calculé
	 * @param consequences Consequences qui contient les altérations de la série d'action précédente
	 * @return un objet HealPotential
	 */
	static HealPotential getCellHeal(Cell cell, Consequences? consequences) {
		if (consequences && consequences!.isAlteringDanger) {
			if (!_hash_heal[consequences!.hashcode]) {
				_hash_heal[consequences!.hashcode] = [:]
			}
			if (!_hash_heal[consequences!.hashcode]![cell]) {
				_hash_heal[consequences!.hashcode]![cell] = MapAllyHeal.computeHeal(cell, consequences)
			}
			return _hash_heal[consequences!.hashcode]![cell]!
		} else {
			if (!_heal[cell]) {
				_heal[cell] = MapAllyHeal.computeHeal(cell, null)
			}
			return _heal[cell]!
		}
	}

	/*
	 * Pour chaque allié vivant, somme les heals de leurs items en fonction des TP et cooldowns
	 * @param cell Cellule sur laquelle le heal va être calculé
	 * @param consequences Consequences qui contient les altérations
	 * @return un objet HealPotential
	 */
	static HealPotential computeHeal(Cell cell, Consequences? consequences) {
		real totalHeal = 0.0
		string str = ""

		for (Entity ally in Fight.getAlliesAlive()) {
			if (ally == Fight.self) continue
			if (consequences && consequences!.isKilled(ally)) continue

			Array<Item>? healItems = _ally_heal_items[ally]
			if (healItems == null) continue

			integer tpLeft = ally.getCurrentTP(consequences)

			for (Item item in healItems!) {
				Map<Cell, real>? itemMap = _map_ally_item_heal[ally]![item]
				if (itemMap == null) continue

				real? ratioHeal = itemMap![cell]
				if (ratioHeal == null || ratioHeal <= 0) continue

				real itemHeal = MapAllyHeal.getHeal(ally, item, ratioHeal!, consequences)
				if (itemHeal > 0) {
					integer uses = 0
					while (item.cost <= tpLeft && uses < item.maxUse) {
						str += " " + item.name
						totalHeal += itemHeal
						tpLeft -= item.cost
						uses++
						if (item.haveCD) break
					}
				}
			}
		}

		return HealPotential(cell, totalHeal, str)
	}

	/*
	 * Check if a non-stackable HoT effect from this item is already on self.
	 * Used to filter out heal-over-time items that won't actually add healing.
	 * @param item Item to check
	 * @param effect ItemEffect to check (must be EFFECT_HEAL with duration > 1)
	 * @return true if effect should be skipped (already on self and non-stackable)
	 */
	static boolean isHoTAlreadyOnSelf(Item item, ItemEffect effect) {
		// Only applies to non-stackable heal-over-time effects
		if (effect.stackable) return false
		if (effect.duration <= 1) return false

		// Check if self already has this item's effect
		Array<EffectOverTime>? existing = Fight.self.items_effectOverTime[item]
		return existing != null && count(existing!) > 0
	}

	/*
	 * Calcule le heal que peut faire allySource avec une Item
	 * @param allySource Allié qui heal
	 * @param item Item de heal
	 * @param ratioHeal Ratio de distance (1.0 pour adjacent, moins pour AOE)
	 * @param consequences Consequences optionnelles
	 * @return heal calculé
	 */
	static real getHeal(Entity allySource, Item item, real ratioHeal, Consequences? consequences) {
		real heal = 0.0

		for (ItemEffect e in item.effects) {
			if (e.type == EFFECT_HEAL) {
				// Skip non-stackable HoT effects already on self
				if (e.duration > 1 && MapAllyHeal.isHoTAlreadyOnSelf(item, e)) continue
				real tmp = e.avgmax * (1 + (allySource.getCurrentWsd(consequences) / 100)) * ratioHeal
				heal += tmp
			}
			else if (e.type == EFFECT_BOOST_MAX_LIFE) {
				real tmp = e.avgmax * (1 + (allySource.getCurrentWsd(consequences) / 100)) * ratioHeal
				heal += tmp
			}
			else if (e.type == EFFECT_RAW_HEAL) {
				real tmp = e.avgmax * ratioHeal  // No wisdom scaling
				heal += tmp
			}
		}

		return heal
	}

	/*
	 * Debug: affiche la map de heal sur le terrain
	 * Vert = heal élevé, Bleu = heal faible
	 */
	static void showHeal(Cell from, integer mpLeft, Consequences? consequences) {
		Map<Cell, integer> reachableCells = MapPath.getCachedReachableCells(from, mpLeft, Fight.self.cellsToIgnore)
		for (Cell c : integer d in reachableCells) {
			HealPotential hp = MapAllyHeal.getCellHeal(c, consequences)
			integer green = ((hp.heal * 255) / Fight.self.totalLife) as integer
			if (green > 255) green = 255
			mark(c.id, getColor(0, green, 255 - green))
			markText(c.id, round(hp.heal))
		}
	}

	/*
	 * Debug: affiche la map de heal sur TOUT le terrain (pas seulement les cases accessibles)
	 */
	static void showHealAll() {
		for (integer id : Cell c in Board.cells) {
			if (c.isWall) continue
			HealPotential hp = MapAllyHeal.getCellHeal(c, null)
			if (hp.heal > 0) {
				integer green = ((hp.heal * 255) / Fight.self.totalLife) as integer
				if (green > 255) green = 255
				mark(c.id, getColor(0, green, 255 - green))
				markText(c.id, round(hp.heal))
			}
		}
	}

	/*
	 * Debug: affiche les infos des alliés et leurs items de heal
	 * Utile pour vérifier que les items sont bien détectés
	 */
	static void debugAllyHealItems() {
		debug("=== MapAllyHeal Debug ===")
		debug("Config: HEAL_ITEMS_LIMIT = " + MapAllyHeal.HEAL_ITEMS_LIMIT)
		debug("")

		for (Entity ally in Fight.getAlliesAlive()) {
			if (ally == Fight.self) continue

			Array<Item>? healItems = _ally_heal_items[ally]
			if (healItems == null || count(healItems!) == 0) {
				debug(ally.name + " (WSD:" + ally.wsd + ", TP:" + ally.tp + ", MP:" + ally.mp + "): NO HEAL ITEMS")
				continue
			}

			string itemsStr = ""
			for (Item item in healItems!) {
				// Calcul du heal de l'item
				real itemHeal = 0.0
				for (ItemEffect e in item.effects) {
					if (e.type == EFFECT_HEAL || e.type == EFFECT_BOOST_MAX_LIFE) {
						itemHeal += e.avg * (1 + (ally.wsd / 100))
					}
				}
				itemsStr += item.name + "(" + round(itemHeal) + "hp/" + item.cost + "tp) "
			}
			debug(ally.name + " (WSD:" + ally.wsd + ", TP:" + ally.tp + ", MP:" + ally.mp + "): " + itemsStr)

			// Affiche le nombre de cases couvertes par chaque item
			for (Item item in healItems!) {
				Map<Cell, real>? itemMap = _map_ally_item_heal[ally]![item]
				if (itemMap != null) {
					debug("  - " + item.name + ": " + mapSize(itemMap!) + " cells couvertes")
				}
			}
		}
		debug("=========================")
	}

	/*
	 * Debug: affiche le heal potentiel sur la case de chaque allié
	 */
	static void debugAllyCellHeal() {
		debug("=== Heal sur positions alliés ===")
		for (Entity ally in Fight.getAlliesAlive()) {
			HealPotential hp = MapAllyHeal.getCellHeal(ally.cell, null)
			debug(ally.name + " @" + ally.cell.id + ": " + round(hp.heal) + " heal potentiel" + (hp.combo != "" ? " (" + hp.combo + ")" : ""))
		}
		debug("=================================")
	}

	/*
	 * Debug: marque sur la map les cases qu'un allié spécifique peut heal
	 * @param ally L'allié dont on veut voir la couverture
	 */
	static void showAllyHealCoverage(Entity ally) {
		if (ally == Fight.self) {
			debug("Cannot show heal coverage for self")
			return
		}

		Array<Item>? healItems = _ally_heal_items[ally]
		if (healItems == null) {
			debug(ally.name + " has no heal items")
			return
		}

		debug("Showing heal coverage for " + ally.name)
		for (Item item in healItems!) {
			Map<Cell, real>? itemMap = _map_ally_item_heal[ally]![item]
			if (itemMap == null) continue

			for (Cell c : real ratio in itemMap!) {
				integer green = (ratio * 200) as integer + 55
				mark(c.id, getColor(0, green, 0))
				markText(c.id, item.name)
			}
		}
	}
}
