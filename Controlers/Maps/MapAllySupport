/*
 * Ensemble de méthodes et d'algorithmes permettant de calculer le support potentiel des alliés sur chaque case
 * (heal + shields). Similaire à MapDanger mais pour le support allié (ignore les entités dans la LOS, comme MapDanger)
 */
class MapAllySupport {
	// === Configuration ===
	// Nombre max d'items de support par allié à considérer (0 = illimité/tous les items)
	static integer SUPPORT_ITEMS_LIMIT = 4

	// Cache du heal estimé sur la case, reset à chaque tour
	static Map<Cell, HealPotential> _heal = [:] // [cell:HealPotential]
	static Map<integer, Map<Cell, HealPotential>> _hash_heal = [:] // [consequences.hash:[cell:HealPotential]]

	// Cache contenant pour chaque item, pour chaque case, les cases ciblables
	// Ignore les entités dans la LOS (comme MapDanger) - cache global car le résultat ne dépend pas de l'allié
	static Map<Item, Map<Cell, Array<Cell>>> _cache_item_targetableCells = [:] // [item:[fromCell:[targetCells]]]

	// Cache pour chaque allié des maps des cases où il peut heal
	// Refresh à chaque tour
	static Map<Entity, Map<Item, Map<Cell, real>>> _map_ally_item_heal = [:] // [ally:[item:[cell:ratio]]]

	// Items de support par allié (heal + shields)
	static Map<Entity, Array<Item>> _ally_support_items = [:] // [ally:[items]]

	// Valeur scorée de chaque item de support par allié (pré-calculée)
	static Map<Entity, Map<Item, real>> _ally_item_value = [:] // [ally:[item:scoredValue]]

	// === Allies array (populated by collectAllies, used by processRound) ===
	static Array<Entity> _allies = []

	/*
	 * Reset per-turn caches. Called by MapDanger.refresh() at start.
	 * Note: _cache_item_targetableCells is NOT reset (valid across turns)
	 */
	static void resetCaches() {
		_heal = [:]
		_hash_heal = [:]
		_map_ally_item_heal = [:]
		_ally_support_items = [:]
		_ally_item_value = [:]
		_allies = []
	}

	/*
	 * Collect allies and prepare their support items (heal + shields).
	 * Called by MapDanger.refresh() during Phase 1.
	 * @return maxItems - maximum number of support items across all allies
	 */
	static integer collectAllies() {
		integer maxItems = 0
		for (Entity ally in Fight.getAlliesAlive()) {
			if (ally == Fight.self) continue

			_map_ally_item_heal[ally] = [:]
			_ally_item_value[ally] = [:]
			Array<Item> supportItems = Items.getOrderedSupportItems(ally, SUPPORT_ITEMS_LIMIT)
			_ally_support_items[ally] = supportItems

			// Pre-compute scored value for each item
			for (Item item in supportItems) {
				_ally_item_value[ally]![item] = Items.computeSupportValue(ally, item)
			}

			push(_allies, ally)
			integer itemCount = count(supportItems)
			if (itemCount > maxItems) maxItems = itemCount
		}
		return maxItems
	}

	/*
	 * Process round i: compute support map for item[i] of all allies.
	 * Called by MapDanger.refresh() in interleaved round-robin.
	 * @param i - item index to process
	 */
	static void processRound(integer i) {
		for (Entity ally in _allies) {
			Array<Item>? supportItems = _ally_support_items[ally]
			if (supportItems != null && i < count(supportItems!)) {
				Item item = supportItems![i]
				_map_ally_item_heal[ally]![item] = MapAllySupport.getAllySupportMap(ally, item)
			}
		}
	}

	/*
	 * Build early exit stats string for allies.
	 * Called by MapDanger.refresh() when budget exceeded.
	 * @param round - current round number (0-indexed)
	 * @return stats string like "Bulb1:2/3 Bulb2:2/4"
	 */
	static string getEarlyExitStats(integer round) {
		string stats = ""
		for (Entity ally in _allies) {
			Array<Item>? items = _ally_support_items[ally]
			integer total = items != null ? count(items!) : 0
			integer done = min(round + 1, total)
			if (stats != "") stats += " "
			stats += ally.name + ":" + done + "/" + total
		}
		return stats
	}

	/*
	 * Standalone refresh (for testing or when not using interleaved mode).
	 * In production, MapDanger.refresh() orchestrates both maps.
	 */
	static void refresh() {
		MapAllySupport.resetCaches()
		integer maxItems = MapAllySupport.collectAllies()
		for (integer i = 0; i < maxItems; i++) {
			MapAllySupport.processRound(i)
		}
	}

	/*
	 * Pour les cellules accessibles par l'allié, initialise un tableau contenant les cases qu'il peut cibler avec l'item
	 * @info Ignore les entités dans la LOS (comme MapDanger.getEnemiesDmgMap)
	 * @param ally Entity allié
	 * @param item Item de support (heal ou shield)
	 * @return map de Cells ciblables avec ratio (1.0 pour hit direct)
	 */
	static Map<Cell, real> getAllySupportMap(Entity ally, Item item) {
		Map<Cell, real> map = [:]

		for (Cell cell : integer dist in ally.reachableCells) {
			if (dist > ally.mp) break
			Array<Cell> targetableCells = MapAllySupport.getAllyTargetableCells(item, cell)
			for (Cell c in targetableCells) {
				if (map[c] == null) {
					map[c] = 1.0 // ratio
				}
			}
		}

		// Expansion AOE pour les supports de zone
		if (item.area == AREA_CIRCLE_1 || item.area == AREA_CIRCLE_2 || item.area == AREA_CIRCLE_3) {
			for (integer distance = 1; distance <= item.area - 2; distance++) {
				real ratio = 1 - 0.2 * distance
				if (ratio <= 0) break
				Array<Cell> circle = []
				for (Cell c : real value in map) {
					if (value > 0) {
						for (Cell neighbor in c.neighborsObstacles) {
							if (map[neighbor] == null || map[neighbor] == 0) {
								push(circle, neighbor)
							}
						}
					}
				}
				for (Cell cell in circle) {
					map[cell] = ratio
				}
			}
		}

		return map
	}

	/*
	 * Retourne les Cells pouvant être ciblées depuis la @cell avec l'@item (ignore les entités dans la LOS)
	 * @param item Item de support (heal ou shield)
	 * @param cell Cellule depuis laquelle l'allié tire
	 * @return Array de cellules ciblables
	 */
	static Array<Cell> getAllyTargetableCells(Item item, Cell cell) {
		// Init du cache si nécessaire
		if (_cache_item_targetableCells[item] == null) {
			_cache_item_targetableCells[item] = [:]
		}
		if (_cache_item_targetableCells[item]![cell] == null) {
			// Ignore toutes les entités dans la LOS (comme MapDanger.getEnemiesTargetableCells)
			_cache_item_targetableCells[item]![cell] = Targets.getTargetableCells(item, cell, Fight.allEntitiesId)
		}

		return _cache_item_targetableCells[item]![cell]!
	}

	/*
	 * Calcule le support potentiel d'une Cell, version sans Conséquences
	 * @param cell la case sur laquelle on veut le support potentiel
	 * @return HealPotential (TODO: rename to SupportPotential)
	 */
	static HealPotential getCellSupport(Cell cell) {
		return MapAllySupport.getCellSupport(cell, null)
	}

	/*
	 * Renvoie le cache du support potentiel d'une Cell, le calcule si pas déjà calculé
	 * @param cell Cellule sur laquelle le support va être calculé
	 * @param consequences Consequences qui contient les altérations de la série d'action précédente
	 * @return un objet HealPotential (TODO: rename to SupportPotential)
	 */
	static HealPotential getCellSupport(Cell cell, Consequences? consequences) {
		if (consequences && consequences!.isAlteringDanger) {
			if (!_hash_heal[consequences!.hashcode]) {
				_hash_heal[consequences!.hashcode] = [:]
			}
			if (!_hash_heal[consequences!.hashcode]![cell]) {
				_hash_heal[consequences!.hashcode]![cell] = MapAllySupport.computeSupport(cell, consequences)
			}
			return _hash_heal[consequences!.hashcode]![cell]!
		} else {
			if (!_heal[cell]) {
				_heal[cell] = MapAllySupport.computeSupport(cell, null)
			}
			return _heal[cell]!
		}
	}

	/*
	 * Pour chaque allié vivant, somme le support (heal + shields) de leurs items en fonction des TP et cooldowns
	 * @param cell Cellule sur laquelle le support va être calculé
	 * @param consequences Consequences qui contient les altérations
	 * @return un objet HealPotential (TODO: rename to SupportPotential)
	 */
	static HealPotential computeSupport(Cell cell, Consequences? consequences) {
		real totalSupport = 0.0
		string str = ""

		for (Entity ally in Fight.getAlliesAlive()) {
			if (ally == Fight.self) continue
			if (consequences && consequences!.isKilled(ally)) continue

			Array<Item>? supportItems = _ally_support_items[ally]
			if (supportItems == null) continue

			integer tpLeft = ally.getCurrentTP(consequences)

			for (Item item in supportItems!) {
				Map<Cell, real>? itemMap = _map_ally_item_heal[ally]![item]
				if (itemMap == null) continue

				real? ratio = itemMap![cell]
				if (ratio == null || ratio <= 0) continue

				real itemSupport = MapAllySupport.getSupport(ally, item, ratio!)
				if (itemSupport > 0) {
					integer uses = 0
					while (item.cost <= tpLeft && uses < item.maxUse) {
						str += " " + item.name
						totalSupport += itemSupport
						tpLeft -= item.cost
						uses++
						if (item.haveCD) break
					}
				}
			}
		}

		return HealPotential(cell, totalSupport, str)
	}

	/*
	 * Retourne la valeur de support d'un item pour un allié, multipliée par le ratio de distance.
	 * Utilise la valeur pré-calculée dans _ally_item_value.
	 * @param ally Allié qui support
	 * @param item Item de support
	 * @param ratio Ratio de distance (1.0 pour adjacent, moins pour AOE)
	 * @return valeur de support scorée * ratio
	 */
	static real getSupport(Entity ally, Item item, real ratio) {
		real? value = _ally_item_value[ally]![item]
		if (value == null) return 0.0
		return value! * ratio
	}

	/*
	 * Debug: affiche la map de support sur le terrain
	 * Vert = support élevé, Bleu = support faible
	 */
	static void showSupport(Cell from, integer mpLeft, Consequences? consequences) {
		Map<Cell, integer> reachableCells = MapPath.getCachedReachableCells(from, mpLeft, Fight.self.cellsToIgnore)
		for (Cell c : integer d in reachableCells) {
			HealPotential hp = MapAllySupport.getCellSupport(c, consequences)
			integer green = ((hp.heal * 255) / Fight.self.totalLife) as integer
			if (green > 255) green = 255
			mark(c.id, getColor(0, green, 255 - green))
			markText(c.id, round(hp.heal))
		}
	}

	/*
	 * Debug: affiche la map de support sur TOUT le terrain (pas seulement les cases accessibles)
	 */
	static void showSupportAll() {
		for (integer id : Cell c in Board.cells) {
			if (c.isWall) continue
			HealPotential hp = MapAllySupport.getCellSupport(c, null)
			if (hp.heal > 0) {
				integer green = ((hp.heal * 255) / Fight.self.totalLife) as integer
				if (green > 255) green = 255
				mark(c.id, getColor(0, green, 255 - green))
				markText(c.id, round(hp.heal))
			}
		}
	}

	/*
	 * Debug: affiche les infos des alliés et leurs items de support
	 * Utile pour vérifier que les items sont bien détectés
	 */
	static void debugAllySupportItems() {
		debug("=== MapAllySupport Debug ===")
		debug("Config: SUPPORT_ITEMS_LIMIT = " + MapAllySupport.SUPPORT_ITEMS_LIMIT)
		debug("")

		for (Entity ally in Fight.getAlliesAlive()) {
			if (ally == Fight.self) continue

			Array<Item>? supportItems = _ally_support_items[ally]
			if (supportItems == null || count(supportItems!) == 0) {
				debug(ally.name + " (WSD:" + ally.wsd + ", RST:" + ally.rst + ", TP:" + ally.tp + ", MP:" + ally.mp + "): NO SUPPORT ITEMS")
				continue
			}

			string itemsStr = ""
			for (Item item in supportItems!) {
				itemsStr += item.name + "(" + item.cost + "tp) "
			}
			debug(ally.name + " (WSD:" + ally.wsd + ", RST:" + ally.rst + ", TP:" + ally.tp + ", MP:" + ally.mp + "): " + itemsStr)

			// Affiche le nombre de cases couvertes par chaque item
			for (Item item in supportItems!) {
				Map<Cell, real>? itemMap = _map_ally_item_heal[ally]![item]
				if (itemMap != null) {
					debug("  - " + item.name + ": " + mapSize(itemMap!) + " cells couvertes")
				}
			}
		}
		debug("============================")
	}

	/*
	 * Debug: affiche le support potentiel sur la case de chaque allié
	 */
	static void debugAllyCellSupport() {
		debug("=== Support sur positions alliés ===")
		for (Entity ally in Fight.getAlliesAlive()) {
			HealPotential hp = MapAllySupport.getCellSupport(ally.cell, null)
			debug(ally.name + " @" + ally.cell.id + ": " + round(hp.heal) + " support potentiel" + (hp.combo != "" ? " (" + hp.combo + ")" : ""))
		}
		debug("====================================")
	}

	/*
	 * Debug: marque sur la map les cases qu'un allié spécifique peut support
	 * @param ally L'allié dont on veut voir la couverture
	 */
	static void showAllySupportCoverage(Entity ally) {
		if (ally == Fight.self) {
			debug("Cannot show support coverage for self")
			return
		}

		Array<Item>? supportItems = _ally_support_items[ally]
		if (supportItems == null) {
			debug(ally.name + " has no support items")
			return
		}

		debug("Showing support coverage for " + ally.name)
		for (Item item in supportItems!) {
			Map<Cell, real>? itemMap = _map_ally_item_heal[ally]![item]
			if (itemMap == null) continue

			for (Cell c : real ratio in itemMap!) {
				integer green = (ratio * 200) as integer + 55
				mark(c.id, getColor(0, green, 0))
				markText(c.id, item.name)
			}
		}
	}
}
