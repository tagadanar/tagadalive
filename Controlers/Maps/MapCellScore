/*
 * MapCellScore - Cell-centric view of action scores
 *
 * Aggregates action data from MapAction into cell-based format for exploration.
 * Answers: "If I stand on cell X, what's the total offensive value I can generate?"
 *
 * Data flow:
 *   MapAction._cell_item_bestAction  -->  MapCellScore.cellScores (sum per cell)
 *   (Cell -> Item -> Action)              MapCellScore.cellActions (flat list)
 */

class MapCellScore {
	// Cell -> total action score (sum of best actions per item)
	static Map<Cell, real> cellScores = [:]

	// Cell -> actions (unsorted, sorted lazily in buildWithKnapsack)
	static Map<Cell, Array<Action>> cellActions = [:]

	// Self-cast actions (available from any cell)
	static Array<Action> selfCastActions = []

	// Top K interesting cells (sorted by score DESC)
	static Array<Cell> interestingCells = []

	/*
	 * Refresh cell scoring from MapAction (no duplication)
	 */
	static void refresh() {
		MapCellScore.cellScores = [:]
		MapCellScore.cellActions = [:]
		MapCellScore.selfCastActions = []

		Map<Cell, Map<Item, Action>> bestActions = MapAction.getMapBestAction()

		for (Cell cell : Map<Item, Action> itemActions in bestActions) {
			real totalScore = 0.0
			Array<Action> actions = []

			for (Item item : Action action in itemActions) {
				if (action.score == null || action.score! <= 0) continue
				totalScore += action.score!
				push(actions, action)
			}

			if (count(actions) == 0) continue

			// Handle self-cast separately
			if (cell == Fight.selfCell) {
				MapCellScore.selfCastActions = actions
			} else {
				MapCellScore.cellScores[cell] = totalScore
				MapCellScore.cellActions[cell] = actions
			}
		}

		// Build interesting cells list (top K by score)
		MapCellScore.interestingCells = []
		Array<Cell> allCells = []
		for (Cell cell : real score in MapCellScore.cellScores) {
			push(allCells, cell)
		}

		allCells = arraySort(allCells, (Cell a, Cell b) => integer|real {
			return Sort.desc(MapCellScore.cellScores[a]!, MapCellScore.cellScores[b]!)
		}) as Array<Cell>

		integer k = min(ExplorerConfig.INTERESTING_CELLS_K_PHASE2, count(allCells))
		for (integer i = 0; i < k; i++) {
			push(MapCellScore.interestingCells, allCells[i])
		}
	}

	/*
	 * Sort actions by priority ASC, then score DESC
	 */
	static Array<Action> sortByPriority(Array<Action> actions) {
		return arraySort(actions, (Action a, Action b) => integer|real {
			if (a.item.priority != b.item.priority) {
				return Sort.asc(a.item.priority, b.item.priority)
			}
			return Sort.desc(a.score!, b.score!)
		}) as Array<Action>
	}

	/*
	 * Sort actions by score DESC (for selection)
	 */
	static Array<Action> sortByScore(Array<Action> actions) {
		return arraySort(actions, (Action a, Action b) => integer|real {
			return Sort.desc(a.score!, b.score!)
		}) as Array<Action>
	}

	/*
	 * Display cell scores on the map (for debugging)
	 * Color: black = reachable but no useful action
	 *        red (low) to green (high) gradient = has actions
	 *        blue = top K selected cells
	 * Text: rounded score value
	 */
	static void showCellScores() {
		// Find max for normalization
		real maxScore = 1.0
		for (Cell c : real s in MapCellScore.cellScores) {
			if (s > maxScore) maxScore = s
		}

		// Build set of interesting cells for O(1) lookup
		Map<Cell, boolean> isInteresting = [:]
		for (Cell c in MapCellScore.interestingCells) {
			isInteresting[c] = true
		}

		// Color all reachable cells (including extended range with MP buffs)
		for (Cell c : integer dist in Fight.self.extendedReachableCells) {
			real? score = MapCellScore.cellScores[c]
			if (isInteresting[c]) {
				mark(c.id, getColor(0, 0, 255))
				markText(c.id, round(score!) + "")
			} else if (score != null && score! > 0) {
				integer green = ((score! * 255) / maxScore) as integer
				integer red = 255 - green
				mark(c.id, getColor(red, green, 0))
				markText(c.id, round(score!) + "")
			} else {
				// Reachable but no useful action
				mark(c.id, getColor(0, 0, 0))
			}
		}
	}

	/*
	 * Get actions for a cell (including self-cast merged in)
	 */
	static Array<Action> getActionsForCell(Cell cell) {
		Array<Action> result = []

		// Add cell-specific actions
		if (MapCellScore.cellActions[cell] != null) {
			for (Action a in MapCellScore.cellActions[cell]!) {
				push(result, a)
			}
		}

		// Add self-cast actions
		for (Action a in MapCellScore.selfCastActions) {
			push(result, a)
		}

		return result
	}

	/*
	 * Get all actions that damage a specific target
	 */
	static Array<Action> getActionsDamagingTarget(Entity target) {
		Array<Action> result = []
		Map<Cell, Map<Item, Action>> bestActions = MapAction.getMapBestAction()

		for (Cell cell : Map<Item, Action> itemActions in bestActions) {
			for (Item item : Action action in itemActions) {
				if (action.score == null || action.score! <= 0) continue
				// Check if this action targets the enemy
				if (action.to == target.cell || (action.item.isAOE && MapCellScore.actionHitsTarget(action, target))) {
					push(result, action)
				}
			}
		}

		return result
	}

	/*
	 * Get all actions that help a specific ally (heals/buffs)
	 */
	static Array<Action> getActionsHelpingAlly(Entity ally) {
		Array<Action> result = []
		Map<Cell, Map<Item, Action>> bestActions = MapAction.getMapBestAction()

		for (Cell cell : Map<Item, Action> itemActions in bestActions) {
			for (Item item : Action action in itemActions) {
				if (action.score == null || action.score! <= 0) continue
				// Check if this action targets the ally (heal/buff)
				if (action.to == ally.cell) {
					// Only include if it's a helpful action (check item effects)
					if (MapCellScore.isHelpfulAction(action, ally)) {
						push(result, action)
					}
				}
			}
		}

		return result
	}

	/*
	 * Check if an AOE action hits a specific target
	 */
	static boolean actionHitsTarget(Action action, Entity target) {
		// Get cells affected by this AOE
		Array<Cell> affectedCells = action.to.getAreaCells(action.item.area)
		for (Cell c in affectedCells) {
			if (c == target.cell) return true
		}
		return false
	}

	/*
	 * Check if action is helpful (heal/buff) for an ally.
	 * Uses TargetType.allies which covers all ally-targeting effects.
	 */
	static boolean isHelpfulAction(Action action, Entity ally) {
		for (ItemEffect effect in action.item.effects) {
			if (effect.targetType.allies) {
				return true
			}
		}
		return false
	}
}
