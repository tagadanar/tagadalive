/*
 *  Ensemble de méthodes et d'algorithmes permettant de calculer le Danger et les maps de dommages
 */
class MapDanger {
	// cache du danger estimé sur la case, reset à chaque tour, pour la v1 du danger, sera amener à évoluer quand on améliorera la map
	static Map<Cell, Danger> _danger = [:] // [cell:danger]
	static Map<integer, Map<Cell, Danger>> _hash_danger = [:] // [consequences.hash:[cell:danger]]
	
	// cache contenant pour chaque item, pour chaque case, les cases qu'on peut toucher si rien ne bloque la LOS
	// ne doit pas être reset en début de tour, l'info reste valide, et est lazyloader à la demande.
	static Map<Item, Map<Cell, Array<Cell>>> _cache_item_targetableCells = [:] // [item:[fromCell:[targetCells]]]
	
	// cache contenant pour chaque ally, pour chaque item, pour chauqe case, les cases qu'on peut toucher, en prenant en compte la LOS
	// doit être refresh à chaque tour, car on prend en compte la LOS
	// TODO faire des tests de performances quand on rencontrera des problèmes d'opérations, c'est surement nettement + couteux...
	static Map<Entity, Map<Item, Map<Cell, Array<Cell>>>> _cache_allies_item_targetableCells = [:] // [ally:[item:[fromCell:[targetCells]]]]
	
	// cache pour chaque enemy des maps des cases où il peut tirer
	// refresh à chaque tour
	static Map<Entity, Map<Item, Map<Cell, real>>> _map_entity_item_danger = [:] // [e:[item:[cell:ratio]]]
	// min MP cost to reach each direct-hit cell (no AOE), used for MP shackle filtering in Damages
	static Map<Entity, Map<Item, Map<Cell, integer>>> _map_entity_item_mp = [:] // [e:[item:[cell:minDist]]]

	// Enemy antidote coverage: for each enemy with antidote cd <= 1, which cells they can reach
	// Only populated when BattleState.allyHasPsn is true
	static Map<Entity, Map<Cell, real>> _map_enemy_antidote = [:]

	// Enemy liberation coverage: for each enemy with liberation cd <= 1, which cells they can reach
	// Only populated when BattleState.allyHasRst is true
	static Map<Entity, Map<Cell, real>> _map_enemy_liberation = [:]
	
	/*
	 * Actualise les informations en fonctions des enemies et alliés encore vivant.
	 * Orchestre le round-robin avec priorité:
	 *   Phase 1: Enemy[0] + AllySupport[0] + AllyDamage[0] → minimum info guaranteed
	 *   Phase 2: Enemy[1..n] → danger priority, check after each round
	 *   Phase 3: AllySupport[1..n] → heal completion, check after each round
	 *   Phase 4: AllyDamage[1..n] → ally offensive completion (lowest priority)
	 */
	static void refresh(){
		// Reset caches (danger, support, and ally damage)
		_danger = [:]
		_hash_danger = [:]
		_map_entity_item_danger = [:]
		_map_entity_item_mp = [:]
		_map_enemy_antidote = [:]
		_map_enemy_liberation = [:]
		MapSupport.resetCaches()
		MapDamage.resetCaches()

		// Collect enemies and prepare their offensive items
		Array<Entity> enemies = []
		integer maxEnemyItems = 0
		for(Entity e in Fight.getEnemiesAlive()){
			_map_entity_item_danger[e] = [:]
			_map_entity_item_mp[e] = [:]
			e.offensiveItems = Items.getOrderedOffensiveItems(e)
			push(enemies, e)
			integer itemCount = count(e.offensiveItems)
			if(itemCount > maxEnemyItems) maxEnemyItems = itemCount
		}

		// Collect allies and prepare their support/offensive items
		integer maxAllySupport = MapSupport.collectAllies()
		integer maxAllyDamage = MapDamage.collectAllies()

		integer dangerBudget = (getMaxOperations() * 0.4) as integer
		integer enemyRound = 0
		integer allySupportRound = 0
		integer allyDamageRound = 0

		// ═══════════════════════════════════════════════════════════════════
		// PHASE 1: Minimum info - Enemy[0] + AllySupport[0] + AllyDamage[0]
		// ═══════════════════════════════════════════════════════════════════
		if(maxEnemyItems > 0){
			MapDanger._processEnemyRound(enemies, 0)
			enemyRound = 1
		}
		if(maxAllySupport > 0){
			MapSupport.processRound(0)
			allySupportRound = 1
		}
		if(maxAllyDamage > 0){
			MapDamage.processRound(0)
			allyDamageRound = 1
		}

		// Check budget after Phase 1
		if(getOperations() > dangerBudget){
			MapDanger._logEarlyExit("Phase1", enemyRound, maxEnemyItems, allySupportRound, maxAllySupport, allyDamageRound, maxAllyDamage, enemies)
			return
		}

		// Build enemy antidote maps (only when allies have poison capability)
		if (BattleState.allyHasPsn) {
			MapDanger._buildEnemyCoverageMaps(CHIP_ANTIDOTE, (Entity e) => integer { return e.antidoteCD }, _map_enemy_antidote)
			MapDanger._computeEnemyNextChipTurn(5, (Entity e) => integer { return e.antidoteCD }, _map_enemy_antidote, (Entity t, integer v) => void { t.nextAntidote = v })
			for (Entity e in Fight.getEnemiesAlive()) {
				e.willBeDead = e.psnlife <= 0 && e.nextAntidote >= 1
			}
		}
		// Build enemy liberation maps (only when enemies have STR and allies have RST)
		if (BattleState.enemyHasStr && BattleState.allyHasRst) {
			MapDanger._buildEnemyCoverageMaps(CHIP_LIBERATION, (Entity e) => integer { return e.liberationCD }, _map_enemy_liberation)
			MapDanger._computeEnemyNextChipTurn(6, (Entity e) => integer { return e.liberationCD }, _map_enemy_liberation, (Entity t, integer v) => void { t.nextLiberation = v })
		}
		// Compute enemy nextManumission (self-cast: E == T → max(1, cd))
		for (Entity e in Fight.getEnemiesAlive()) {
			if (e.manumissionCD < 6) e.nextManumission = max(1, e.manumissionCD)
		}

		// ═══════════════════════════════════════════════════════════════════
		// PHASE 2: Enemy priority - complete enemy danger map
		// ═══════════════════════════════════════════════════════════════════
		for(integer i = 1; i < maxEnemyItems; i++){
			MapDanger._processEnemyRound(enemies, i)
			enemyRound = i + 1

			if(getOperations() > dangerBudget){
				MapDanger._logEarlyExit("Phase2", enemyRound, maxEnemyItems, allySupportRound, maxAllySupport, allyDamageRound, maxAllyDamage, enemies)
				return
			}
		}

		// ═══════════════════════════════════════════════════════════════════
		// PHASE 3: Ally support completion
		// ═══════════════════════════════════════════════════════════════════
		for(integer i = 1; i < maxAllySupport; i++){
			MapSupport.processRound(i)
			allySupportRound = i + 1

			if(getOperations() > dangerBudget){
				MapDanger._logEarlyExit("Phase3", enemyRound, maxEnemyItems, allySupportRound, maxAllySupport, allyDamageRound, maxAllyDamage, enemies)
				return
			}
		}

		// ═══════════════════════════════════════════════════════════════════
		// PHASE 4: Ally damage completion (lowest priority)
		// ═══════════════════════════════════════════════════════════════════
		for(integer i = 1; i < maxAllyDamage; i++){
			MapDamage.processRound(i)
			allyDamageRound = i + 1

			if(getOperations() > dangerBudget){
				MapDanger._logEarlyExit("Phase4", enemyRound, maxEnemyItems, allySupportRound, maxAllySupport, allyDamageRound, maxAllyDamage, enemies)
				return
			}
		}
	}

	/*
	 * Process enemy round i: compute danger map for item[i] of all enemies
	 */
	static void _processEnemyRound(Array<Entity> enemies, integer i){
		for(Entity e in enemies){
			if(i < count(e.offensiveItems)){
				Item item = e.offensiveItems[i]
				_map_entity_item_danger[e]![item] = MapDanger.getEnemiesDmgMap(e, item)
			}
		}
	}

	/*
	 * Build early exit stats string for a set of allies and their items
	 */
	static string _buildExitStats(integer round, Array<Entity> allies, Map<Entity, Array<Item>> allyItems) {
		string stats = ""
		for (Entity ally in allies) {
			Array<Item>? items = allyItems[ally]
			integer total = items != null ? count(items!) : 0
			integer done = min(round + 1, total)
			if (stats != "") stats += " "
			stats += ally.name + ":" + done + "/" + total
		}
		return stats
	}

	/*
	 * Log early exit with phase info and stats
	 */
	static void _logEarlyExit(string phase, integer enemyRound, integer maxEnemy, integer allySupportRound, integer maxAllySupport, integer allyDamageRound, integer maxAllyDamage, Array<Entity> enemies){
		string enemyStats = ""
		for(Entity e in enemies){
			integer done = min(enemyRound, count(e.offensiveItems))
			if(enemyStats != "") enemyStats += " "
			enemyStats += e.name + ":" + done + "/" + count(e.offensiveItems)
		}
		// Round is 1-indexed (rounds completed), _buildExitStats expects 0-indexed (last round index)
		string supportStats = allySupportRound > 0 ? MapDanger._buildExitStats(allySupportRound - 1, MapSupport._allies, MapSupport._ally_support_items) : ""
		string damageStats = allyDamageRound > 0 ? MapDanger._buildExitStats(allyDamageRound - 1, MapDamage._allies, MapDamage._ally_offensive_items) : ""

		string entity = Fight.self.isBulb ? "bulb" : "leek"
		string msg = entity + " T" + getTurn() + " MapDanger " + phase + " early exit @" + Benchmark.format(getOperations())
		msg += " | E:" + enemyRound + "/" + maxEnemy
		if(enemyStats != "") msg += " (" + enemyStats + ")"
		msg += " | S:" + allySupportRound + "/" + maxAllySupport
		if(supportStats != "") msg += " (" + supportStats + ")"
		msg += " | D:" + allyDamageRound + "/" + maxAllyDamage
		if(damageStats != "") msg += " (" + damageStats + ")"
		debugW(msg)
	}
	
	/*
	 * Calcule le danger d'une Cell, version sans Conséquences
	 * @param <Cell> cell la case sur laquel on veut le danger
	 * @return <Danger>
	 */
	static Danger getCellDanger(Cell cell){
		return MapDanger.getCellDanger(cell, null)
	}
		
	/*
	 * renvoie le cache du danger d'une Cell, la calcule si elle n'a pas déjà été calculé.
	 * @param cell Cellule sur laquelle le danger va être calculé
	 * @param consequences Consequences qui contient les altérations de la série d'action précédente dans le combo
	 * @return un objet <Danger>
	 */
	static Danger getCellDanger(Cell cell, Consequences? consequences) {
		if(consequences && consequences!.isAlteringDanger){
			if(!_hash_danger[consequences!.hashcode]) 
				_hash_danger[consequences!.hashcode] = [:]
			if(!_hash_danger[consequences!.hashcode]![cell]){
				_hash_danger[consequences!.hashcode]![cell] = Damages.computeDanger(cell, consequences)
			}
			return _hash_danger[consequences!.hashcode]![cell]!
		}else{
			if(!_danger[cell]) {
				_danger[cell] = Damages.computeDanger(cell, null)
			}
			return _danger[cell]!
		}
	}

	/*
	 * Pour les cellules accessible par l'allié, initialise un tableau contenant les cases qu'il peut cibler avec l'item passé en paramètre
	 * @info cette fonction est appelé pour chaque items de l'allié
	 * @param ally Entity allié
	 * @item Item item
	 * @return map de Cells ciblables par l'Entity ally
	 */
	static Map<Cell, real> getAlliesDmgMap(Entity ally, Item item){
		Map<Cell, real> map = [:]//, map_mp = []
		for(Cell cell:integer dist in ally.reachableCells){
			if(dist > ally.mp) break
			var targetableCells = MapDanger.getAlliesTargetableCells(ally, item, cell);
			for(var c in targetableCells){
				if(map[c]==null){
					map[c]=1.0;//coef
					//map_mp[cell]=dist;
				}
			}
		}
		//aoe TODO
		
		return map // TODO add map_mp
	}

	/*
	 * Retourne les Cells pouvant être touché depuis la @cell avec l'@item (prend en compte les los)
	 * @param item Item
	 * @param cell une Cellule accesible par l'entité en question
	 * @return cache sous forme de double tableau
	 */
	static Array<Cell> getAlliesTargetableCells(Entity ally, Item item, Cell cell){ // TODO add ignoreleeks to ignore leeks who play before
		// init du cache si nécessaire
		if(MapDanger._cache_allies_item_targetableCells[ally]==null) 
			MapDanger._cache_allies_item_targetableCells[ally] = [:]
		if(MapDanger._cache_allies_item_targetableCells[ally]![item]==null)
			MapDanger._cache_allies_item_targetableCells[ally]![item] = [:]
		if(MapDanger._cache_allies_item_targetableCells[ally]![item]![cell]==null) 
			MapDanger._cache_allies_item_targetableCells[ally]![item]![cell] = Targets.getTargetableCells(item, cell, [])
			
		return MapDanger._cache_allies_item_targetableCells[ally]![item]![cell]!;
	}
		
	
		
		
	/*
	 * Pour les cellules accessible par l'ennemi, initialise un tableau contenant les cases qu'il peut cibler avec l'item passé en paramètre
	 * @info cette fonction est appelé pour chaque items de l'ennemi'
	 * @param enemy Entity ennemi
	 * @item Item item
	 * @return map de Cells ciblables par l'Entity enemy
	 */
	static Map<Cell, real> getEnemiesDmgMap(Entity enemy, Item item){
		Map<Cell, real> map = [:]
		Map<Cell, integer> map_mp = [:]
		for(Cell cell:integer dist in enemy.reachableCells){
			if(dist > enemy.mp) break
			Array<Cell> targetableCells = MapDanger.getCachedTargetableCells(item, cell);
			for(Cell c in targetableCells){
				if(map[c]==null){
					map[c]=1.0
					map_mp[c]=dist
				}
			}
		}

		// Store direct-hit MP costs before AOE expansion
		_map_entity_item_mp[enemy]![item] = map_mp

		// AOE expansion (handles CIRCLE, PLUS, X, SQUARE)
		MapDanger.expandAOE(map, item)

		return map
	}

	/*
	 * Expand AOE danger using pre-computed area cells
	 * Handles all AOE types: CIRCLE, PLUS, X, SQUARE
	 * @param map Map of cells with danger ratios (1.0 = direct hit)
	 * @param item Item with AOE area type
	 */
	static void expandAOE(Map<Cell, real> map, Item item){
		if(!item.isAOE) return;

		// Collect direct-hit cells
		Array<Cell> directHits = []
		for(Cell c:real value in map){
			if(value == 1.0) push(directHits, c)
		}

		// For each direct-hit, mark all cells in its AOE with decayed ratio
		for(Cell hit in directHits){
			Set<Cell> aoeCells = hit.getAreaCells(item.area)
			for(Cell c in aoeCells){
				if(c == hit) continue  // center already has 1.0
				// Manhattan distance for ratio decay
				integer dist = abs(hit.x - c.x) + abs(hit.y - c.y)
				real ratio = 1 - ScoringConfig.AOE_DECAY_RATE * dist
				// Keep higher ratio (protects direct hits and overlapping AOEs)
				if(map[c] == null || map[c] < ratio){
					map[c] = ratio
				}
			}
		}
	}

	/*
	 * Retourne les Cells depuis lesquelles on peut cibler `cell` avec `item`, en ignorant toutes les entités.
	 * Cache persistent pour toute la durée du combat (le résultat ne dépend que de la map).
	 * Utilisé par: MapDanger, MapDamage, MapSupport, MapTactical
	 *
	 * @param item Item à utiliser
	 * @param cell Cellule ciblée
	 * @return Array de cellules depuis lesquelles on peut cibler `cell`
	 */
	static Array<Cell> getCachedTargetableCells(Item item, Cell cell){
		// init du cache si nécessaire
		if(MapDanger._cache_item_targetableCells[item]==null) 
			MapDanger._cache_item_targetableCells[item] = [:]
		if(MapDanger._cache_item_targetableCells[item]![cell]==null)
			MapDanger._cache_item_targetableCells[item]![cell] = Targets.getTargetableCells(item, cell, Fight.allEntitiesId)
		
		return MapDanger._cache_item_targetableCells[item]![cell]!;
	}
		
	/*
	 * Build coverage maps for enemies with a given chip cd <= 1.
	 * Used for reach-checking in _computeEnemyNextChipTurn (turnsForT=0 case).
	 */
	static void _buildEnemyCoverageMaps(
		integer chipId,
		Function<Entity => integer> getCD,
		Map<Entity, Map<Cell, real>> coverageMap
	) {
		for (Entity e in Fight.getEnemiesAlive()) {
			if (getCD(e) > 1) continue
			for (Item item in e.items) {
				if (item.id == chipId) {
					Map<Cell, real> map = [:]
					for (Cell cell : integer dist in e.reachableCells) {
						if (dist > e.mp) break
						Array<Cell> targetableCells = MapDanger.getCachedTargetableCells(item, cell)
						for (Cell c in targetableCells) {
							if (map[c] == null) map[c] = 1.0
						}
					}
					coverageMap[e] = map
					break
				}
			}
		}
	}

	/*
	 * Compute how many target turns pass before an enemy can use a chip on it.
	 * Unified logic for antidote (maxCD=5) and liberation (maxCD=6).
	 *
	 * Logic per caster E relative to target T:
	 * - E plays before T: turnsForT = max(0, cd - 1), reach check if 0
	 * - E == T or plays after T: turnsForT = max(1, cd)
	 *
	 * For turnsForT == 0, a reach check is applied via the coverage map.
	 * If unreachable this turn, turnsForT is bumped to 1.
	 */
	static void _computeEnemyNextChipTurn(
		integer maxCD,
		Function<Entity => integer> getCD,
		Map<Entity, Map<Cell, real>> coverageMap,
		Function<Entity, integer => void> setResult
	) {
		Array<Entity> casters = []
		for (Entity e in Fight.getEnemiesAlive()) {
			if (getCD(e) < maxCD) push(casters, e)
		}
		if (count(casters) == 0) return;

		for (Entity target in Fight.getEnemiesAlive()) {
			integer best = maxCD
			for (Entity e in casters) {
				integer turnsForT
				if (e == target) {
					turnsForT = max(1, getCD(e))
				} else {
					boolean playsBefore = false
					for (Entity ent in target.entitiesWhoPlayBefore) {
						if (ent == e) { playsBefore = true; break }
					}
					if (playsBefore) {
						turnsForT = max(0, getCD(e) - 1)
						if (turnsForT == 0) {
							Map<Cell, real>? map = coverageMap[e]
							if (map == null || map![target.cell] == null) turnsForT = 1
						}
					} else {
						turnsForT = max(1, getCD(e))
					}
				}
				if (turnsForT < best) best = turnsForT
				if (best == 0) break
			}
			setResult(target, best)
		}
	}

	static void showDanger(Cell from, integer mpleft, Consequences consequences) {
		Map<Cell, integer> reachableCells = MapPath.getCachedReachableCells(from, mpleft, Fight.self.cellsToIgnore)
		for (Cell c : integer d in reachableCells) {
			Danger danger = MapDanger.getCellDanger(c, consequences)
			// Color: based on total danger (dmg + psnDmg)
			real totalDmg = danger.dmg + danger.psnDmg
			integer red = ((totalDmg * 255) / Fight.self.life) as integer
			if (red > 255) mark(c.id, getColor(0, 0, 0))
			else mark(c.id, getColor(red, 255 - red, 0))
			// Text: dmg+psnDmg
			integer dmgVal = round(danger.dmg)
			integer psnVal = round(danger.psnDmg)
			markText(c.id, dmgVal + "+" + psnVal)
		}
	}

}