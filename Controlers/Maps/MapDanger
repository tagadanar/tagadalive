/*
 *  Ensemble de méthodes et d'algorithmes permettant de calculer le Danger et les maps de dommages
 */
class MapDanger {
	// cache du danger estimé sur la case, reset à chaque tour, pour la v1 du danger, sera amener à évoluer quand on améliorera la map
	static Map<Cell, Danger> _danger = [:] // [cell:danger]
	static Map<integer, Map<Cell, Danger>> _hash_danger = [:] // [consequences.hash:[cell:danger]]
	
	// cache contenant pour chaque item, pour chaque case, les cases qu'on peut toucher si rien ne bloque la LOS
	// ne doit pas être reset en début de tour, l'info reste valide, et est lazyloader à la demande.
	static Map<Item, Map<Cell, Array<Cell>>> _cache_item_targetableCells = [:] // [item:[fromCell:[targetCells]]]
	
	// cache contenant pour chaque ally, pour chaque item, pour chauqe case, les cases qu'on peut toucher, en prenant en compte la LOS
	// doit être refresh à chaque tour, car on prend en compte la LOS
	// TODO faire des tests de performances quand on rencontrera des problèmes d'opérations, c'est surement nettement + couteux...
	static Map<Entity, Map<Item, Map<Cell, Array<Cell>>>> _cache_allies_item_targetableCells = [:] // [ally:[item:[fromCell:[targetCells]]]]
	
	// cache pour chaque enemy des maps des cases où il peut tirer
	// refresh à chaque tour
	static Map<Entity, Map<Item, Map<Cell, real>>> _map_entity_item_danger = [:] // [e:[item:[cell:ratio]]]
	
	/*
	 * Actualise les informations en fonctions des enemies et alliés encore vivant.
	 * Orchestre le round-robin avec priorité:
	 *   Phase 1: Enemy[0] + Ally[0] → minimum info guaranteed
	 *   Phase 2: Enemy[1..n] → danger priority, check after each round
	 *   Phase 3: Ally[1..n] → heal completion, check after each round
	 */
	static void refresh(){
		// Reset caches (both danger and heal)
		_danger = [:]
		_hash_danger = [:]
		_map_entity_item_danger = [:]
		MapAllySupport.resetCaches()

		// Collect enemies and prepare their offensive items
		Array<Entity> enemies = []
		integer maxEnemyItems = 0
		for(Entity e in Fight.getEnemiesAlive()){
			_map_entity_item_danger[e] = [:]
			e.offensiveItems = Items.getOrderedOffensiveItems(e)
			push(enemies, e)
			integer itemCount = count(e.offensiveItems)
			if(itemCount > maxEnemyItems) maxEnemyItems = itemCount
		}

		// Collect allies and prepare their heal items
		integer maxAllyItems = MapAllySupport.collectAllies()

		integer dangerBudget = (getMaxOperations() * 0.4) as integer
		integer enemyRound = 0
		integer allyRound = 0

		// ═══════════════════════════════════════════════════════════════════
		// PHASE 1: Minimum info - Enemy[0] + Ally[0] (guaranteed)
		// ═══════════════════════════════════════════════════════════════════
		if(maxEnemyItems > 0){
			MapDanger._processEnemyRound(enemies, 0)
			enemyRound = 1
		}
		if(maxAllyItems > 0){
			MapAllySupport.processRound(0)
			allyRound = 1
		}

		// Check budget after Phase 1
		if(getOperations() > dangerBudget){
			MapDanger._logEarlyExit("Phase1", enemyRound, maxEnemyItems, allyRound, maxAllyItems, enemies)
			return
		}

		// ═══════════════════════════════════════════════════════════════════
		// PHASE 2: Enemy priority - complete enemy danger map
		// ═══════════════════════════════════════════════════════════════════
		for(integer i = 1; i < maxEnemyItems; i++){
			MapDanger._processEnemyRound(enemies, i)
			enemyRound = i + 1

			if(getOperations() > dangerBudget){
				MapDanger._logEarlyExit("Phase2", enemyRound, maxEnemyItems, allyRound, maxAllyItems, enemies)
				return
			}
		}

		// ═══════════════════════════════════════════════════════════════════
		// PHASE 3: Ally heal completion
		// ═══════════════════════════════════════════════════════════════════
		for(integer i = 1; i < maxAllyItems; i++){
			MapAllySupport.processRound(i)
			allyRound = i + 1

			if(getOperations() > dangerBudget){
				MapDanger._logEarlyExit("Phase3", enemyRound, maxEnemyItems, allyRound, maxAllyItems, enemies)
				return
			}
		}
	}

	/*
	 * Process enemy round i: compute danger map for item[i] of all enemies
	 */
	static void _processEnemyRound(Array<Entity> enemies, integer i){
		for(Entity e in enemies){
			if(i < count(e.offensiveItems)){
				Item item = e.offensiveItems[i]
				_map_entity_item_danger[e]![item] = MapDanger.getEnemiesDmgMap(e, item)
			}
		}
	}

	/*
	 * Log early exit with phase info and stats
	 */
	static void _logEarlyExit(string phase, integer enemyRound, integer maxEnemy, integer allyRound, integer maxAlly, Array<Entity> enemies){
		string enemyStats = ""
		for(Entity e in enemies){
			integer done = min(enemyRound, count(e.offensiveItems))
			if(enemyStats != "") enemyStats += " "
			enemyStats += e.name + ":" + done + "/" + count(e.offensiveItems)
		}
		// allyRound is 1-indexed (rounds completed), getEarlyExitStats expects 0-indexed (last round index)
		string allyStats = allyRound > 0 ? MapAllySupport.getEarlyExitStats(allyRound - 1) : ""

		string entity = Fight.self.isBulb ? "bulb" : "leek"
		string msg = entity + " T" + getTurn() + " MapDanger " + phase + " early exit @" + Benchmark.format(getOperations())
		msg += " | E:" + enemyRound + "/" + maxEnemy
		if(enemyStats != "") msg += " (" + enemyStats + ")"
		msg += " | A:" + allyRound + "/" + maxAlly
		if(allyStats != "") msg += " (" + allyStats + ")"
		debugW(msg)
	}
	
	/*
	 * Calcule le danger d'une Cell, version sans Conséquences
	 * @param <Cell> cell la case sur laquel on veut le danger
	 * @return <Danger>
	 */
	static Danger getCellDanger(Cell cell){
		return MapDanger.getCellDanger(cell, null)
	}
		
	/*
	 * renvoie le cache du danger d'une Cell, la calcule si elle n'a pas déjà été calculé.
	 * @param cell Cellule sur laquelle le danger va être calculé
	 * @param consequences Consequences qui contient les altérations de la série d'action précédente dans le combo
	 * @return un objet <Danger>
	 */
	static Danger getCellDanger(Cell cell, Consequences? consequences) {
		if(consequences && consequences!.isAlteringDanger){
			if(!_hash_danger[consequences!.hashcode]) 
				_hash_danger[consequences!.hashcode] = [:]
			if(!_hash_danger[consequences!.hashcode]![cell]){
				_hash_danger[consequences!.hashcode]![cell] = Damages.computeDanger(cell, consequences)
			}
			return _hash_danger[consequences!.hashcode]![cell]!
		}else{
			if(!_danger[cell]) {
				_danger[cell] = Damages.computeDanger(cell, null)
			}
			return _danger[cell]!
		}
	}

	/*
	 * Pour les cellules accessible par l'allié, initialise un tableau contenant les cases qu'il peut cibler avec l'item passé en paramètre
	 * @info cette fonction est appelé pour chaque items de l'allié
	 * @param ally Entity allié
	 * @item Item item
	 * @return map de Cells ciblables par l'Entity ally
	 */
	static Map<Cell, real> getAlliesDmgMap(Entity ally, Item item){
		Map<Cell, real> map = [:]//, map_mp = []
		for(Cell cell:integer dist in ally.reachableCells){
			if(dist > ally.mp) break
			var targetableCells = MapDanger.getAlliesTargetableCells(ally, item, cell);
			for(var c in targetableCells){
				if(map[c]==null){
					map[c]=1.0;//coef
					//map_mp[cell]=dist;
				}
			}
		}
		//aoe TODO
		
		return map // TODO add map_mp
	}

	/*
	 * Retourne les Cells pouvant être touché depuis la @cell avec l'@item (prend en compte les los)
	 * @param item Item
	 * @param cell une Cellule accesible par l'entité en question
	 * @return cache sous forme de double tableau
	 */
	static Array<Cell> getAlliesTargetableCells(Entity ally, Item item, Cell cell){ // TODO add ignoreleeks to ignore leeks who play before
		// init du cache si nécessaire
		if(MapDanger._cache_allies_item_targetableCells[ally]==null) 
			MapDanger._cache_allies_item_targetableCells[ally] = [:]
		if(MapDanger._cache_allies_item_targetableCells[ally]![item]==null)
			MapDanger._cache_allies_item_targetableCells[ally]![item] = [:]
		if(MapDanger._cache_allies_item_targetableCells[ally]![item]![cell]==null) 
			MapDanger._cache_allies_item_targetableCells[ally]![item]![cell] = Targets.getTargetableCells(item, cell, [])
			
		return MapDanger._cache_allies_item_targetableCells[ally]![item]![cell]!;
	}
		
	
		
		
	/*
	 * Pour les cellules accessible par l'ennemi, initialise un tableau contenant les cases qu'il peut cibler avec l'item passé en paramètre
	 * @info cette fonction est appelé pour chaque items de l'ennemi'
	 * @param enemy Entity ennemi
	 * @item Item item
	 * @return map de Cells ciblables par l'Entity enemy
	 */
	static Map<Cell, real> getEnemiesDmgMap(Entity enemy, Item item){
		Map<Cell, real> map = [:]//, map_mp = []
		for(Cell cell:integer dist in enemy.reachableCells){
			if(dist > enemy.mp) break
			Array<Cell> targetableCells = MapDanger.getEnemiesTargetableCells(item, cell);
			for(Cell c in targetableCells){
				if(map[c]==null){
					map[c]=1.0;//coef
					//map_mp[c]=dist;
				}
			}
		}

		// AOE expansion (handles CIRCLE, PLUS, X, SQUARE)
		MapDanger.expandAOE(map, item)

		return map // TODO add map_mp
	}

	/*
	 * Expand AOE danger using pre-computed area cells
	 * Handles all AOE types: CIRCLE, PLUS, X, SQUARE
	 * @param map Map of cells with danger ratios (1.0 = direct hit)
	 * @param item Item with AOE area type
	 */
	static void expandAOE(Map<Cell, real> map, Item item){
		if(!item.isAOE) return;

		// Collect direct-hit cells
		Array<Cell> directHits = []
		for(Cell c:real value in map){
			if(value == 1.0) push(directHits, c)
		}

		// For each direct-hit, mark all cells in its AOE with decayed ratio
		for(Cell hit in directHits){
			Set<Cell> aoeCells = hit.getAreaCells(item.area)
			for(Cell c in aoeCells){
				if(c == hit) continue  // center already has 1.0
				// Chebyshev distance for ratio decay
				integer dist = abs(hit.x - c.x) + abs(hit.y - c.y)
				real ratio = max(0.2, 1.0 - 0.2 * dist)
				// Keep higher ratio (protects direct hits and overlapping AOEs)
				if(map[c] == null || map[c] < ratio){
					map[c] = ratio
				}
			}
		}
	}

	/*
	 * Retourne les Cells pouvant être touché avec le parametre item par les ennemis, ignore la los
	 * ce qui permet de garder en cache le résultat pour des bonnes perfs
	 * @see getAlliesTargetableCells
	 * @param item Item
	 * @param cell une Cellule accesible par l'entité en question
	 */
	// TODO memoisé lineOfSight ignoring allEntitiesId
	// fonction avec cache qui considère que los est tjr pareil.
	static Array<Cell> getEnemiesTargetableCells(Item item, Cell cell){
		// init du cache si nécessaire
		if(MapDanger._cache_item_targetableCells[item]==null) 
			MapDanger._cache_item_targetableCells[item] = [:]
		if(MapDanger._cache_item_targetableCells[item]![cell]==null)
			MapDanger._cache_item_targetableCells[item]![cell] = Targets.getTargetableCells(item, cell, Fight.allEntitiesId)
		
		return MapDanger._cache_item_targetableCells[item]![cell]!;
	}
		
	static void showDanger(Cell from, integer mpleft, Consequences consequences) {
		Map<Cell, integer> reachableCells = MapPath.getCachedReachableCells(from, mpleft, Fight.self.cellsToIgnore)
		for (Cell c : integer d in reachableCells) {
			Danger danger = MapDanger.getCellDanger(c, consequences)
			// Color: based on total danger (dmg + psnDmg)
			real totalDmg = danger.dmg + danger.psnDmg
			integer red = ((totalDmg * 255) / Fight.self.life) as integer
			if (red > 255) mark(c.id, getColor(0, 0, 0))
			else mark(c.id, getColor(red, 255 - red, 0))
			// Text: dmg+psnDmg
			integer dmgVal = round(danger.dmg)
			integer psnVal = round(danger.psnDmg)
			markText(c.id, dmgVal + "+" + psnVal)
		}
	}

}