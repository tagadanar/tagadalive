/*
 *  Ensemble de méthodes et d'algorithmes permettant de calculer le Danger et les maps de dommages
 */
class MapDanger {
	// cache du danger estimé sur la case, reset à chaque tour, pour la v1 du danger, sera amener à évoluer quand on améliorera la map
	static Map<Cell, Danger> _danger = [:] // [cell:danger]
	static Map<integer, Map<Cell, Danger>> _hash_danger = [:] // [consequences.hash:[cell:danger]]
	
	// cache contenant pour chaque item, pour chaque case, les cases qu'on peut toucher si rien ne bloque la LOS
	// ne doit pas être reset en début de tour, l'info reste valide, et est lazyloader à la demande.
	static Map<Item, Map<Cell, Array<Cell>>> _cache_item_targetableCells = [:] // [item:[fromCell:[targetCells]]]
	
	// cache contenant pour chaque ally, pour chaque item, pour chauqe case, les cases qu'on peut toucher, en prenant en compte la LOS
	// doit être refresh à chaque tour, car on prend en compte la LOS
	// TODO faire des tests de performances quand on rencontrera des problèmes d'opérations, c'est surement nettement + couteux...
	static Map<Entity, Map<Item, Map<Cell, Array<Cell>>>> _cache_allies_item_targetableCells = [:] // [ally:[item:[fromCell:[targetCells]]]]
	
	// cache pour chaque enemy des maps des cases où il peut tirer
	// refresh à chaque tour
	static Map<Entity, Map<Item, Map<Cell, real>>> _map_entity_item_danger = [:] // [e:[item:[cell:ratio]]]
	
	/*
	 * Actualise les informations en fonctions des enemies et alliés encore vivant
	 */
	static void refresh(){
		// reset du cache
		_danger = [:]
		_hash_danger = [:]
		_map_entity_item_danger = [:]

		// Phase 1: Collect enemies and prepare their offensive items
		Array<Entity> enemies = []
		integer maxItems = 0
		for(Entity e in Fight.getEnemiesAlive()){
			_map_entity_item_danger[e] = [:]
			e.offensiveItems = Items.getOrderedOffensiveItems(e)
			push(enemies, e)
			integer itemCount = count(e.offensiveItems)
			if(itemCount > maxItems) maxItems = itemCount
		}

		// Phase 2: Round-robin - process item i for all enemies before item i+1
		integer halfBudget = (getMaxOperations() * 0.5) as integer
		for(integer i = 0; i < maxItems; i++){
			for(Entity e in enemies){
				if(i < count(e.offensiveItems)){
					Item item = e.offensiveItems[i]
					_map_entity_item_danger[e]![item] = MapDanger.getEnemiesDmgMap(e, item)
				}
			}
			// Early exit if we've used more than half the operation budget
			if(getOperations() > halfBudget){
				string stats = ""
				for(Entity e in enemies){
					integer done = min(i + 1, count(e.offensiveItems))
					if(stats != "") stats += " "
					stats += e.name + ":" + done + "/" + count(e.offensiveItems)
				}
				debugW("T" + getTurn() + " MapDanger early exit: round " + (i + 1) + "/" + maxItems + " @" + Benchmark.format(getOperations()) + " | " + stats)
				break
			}
		}
	}
	
	/*
	 * Calcule le danger d'une Cell, version sans Conséquences
	 * @param <Cell> cell la case sur laquel on veut le danger
	 * @return <Danger>
	 */
	static Danger getCellDanger(Cell cell){
		return MapDanger.getCellDanger(cell, null)
	}
		
	/*
	 * renvoie le cache du danger d'une Cell, la calcule si elle n'a pas déjà été calculé.
	 * @param cell Cellule sur laquelle le danger va être calculé
	 * @param consequences Consequences qui contient les altérations de la série d'action précédente dans le combo
	 * @return un objet <Danger>
	 */
	static Danger getCellDanger(Cell cell, Consequences? consequences) {
		if(consequences && consequences!.isAlteringDanger){
			if(!_hash_danger[consequences!.hashcode]) 
				_hash_danger[consequences!.hashcode] = [:]
			if(!_hash_danger[consequences!.hashcode]![cell]){
				_hash_danger[consequences!.hashcode]![cell] = Damages.computeDanger(cell, consequences)
			}
			return _hash_danger[consequences!.hashcode]![cell]!
		}else{
			if(!_danger[cell]) {
				_danger[cell] = Damages.computeDanger(cell, null)
			}
			return _danger[cell]!
		}
	}

	/*
	 * Pour les cellules accessible par l'allié, initialise un tableau contenant les cases qu'il peut cibler avec l'item passé en paramètre
	 * @info cette fonction est appelé pour chaque items de l'allié
	 * @param ally Entity allié
	 * @item Item item
	 * @return map de Cells ciblables par l'Entity ally
	 */
	static Map<Cell, real> getAlliesDmgMap(Entity ally, Item item){
		Map<Cell, real> map = [:]//, map_mp = []
		for(Cell cell:integer dist in ally.reachableCells){
			if(dist > ally.mp) break
			var targetableCells = MapDanger.getAlliesTargetableCells(ally, item, cell);
			for(var c in targetableCells){
				if(map[c]==null){
					map[c]=1.0;//coef
					//map_mp[cell]=dist;
				}
			}
		}
		//aoe TODO
		
		return map // TODO add map_mp
	}

	/*
	 * Retourne les Cells pouvant être touché depuis la @cell avec l'@item (prend en compte les los)
	 * @param item Item
	 * @param cell une Cellule accesible par l'entité en question
	 * @return cache sous forme de double tableau
	 */
	static Array<Cell> getAlliesTargetableCells(Entity ally, Item item, Cell cell){ // TODO add ignoreleeks to ignore leeks who play before
		// init du cache si nécessaire
		if(MapDanger._cache_allies_item_targetableCells[ally]==null) 
			MapDanger._cache_allies_item_targetableCells[ally] = [:]
		if(MapDanger._cache_allies_item_targetableCells[ally]![item]==null)
			MapDanger._cache_allies_item_targetableCells[ally]![item] = [:]
		if(MapDanger._cache_allies_item_targetableCells[ally]![item]![cell]==null) 
			MapDanger._cache_allies_item_targetableCells[ally]![item]![cell] = Targets.getTargetableCells(item, cell, [])
			
		return MapDanger._cache_allies_item_targetableCells[ally]![item]![cell]!;
	}
		
	
		
		
	/*
	 * Pour les cellules accessible par l'ennemi, initialise un tableau contenant les cases qu'il peut cibler avec l'item passé en paramètre
	 * @info cette fonction est appelé pour chaque items de l'ennemi'
	 * @param enemy Entity ennemi
	 * @item Item item
	 * @return map de Cells ciblables par l'Entity enemy
	 */
	static Map<Cell, real> getEnemiesDmgMap(Entity enemy, Item item){
		Map<Cell, real> map = [:]//, map_mp = []
		for(Cell cell:integer dist in enemy.reachableCells){
			if(dist > enemy.mp) break
			Array<Cell> targetableCells = MapDanger.getEnemiesTargetableCells(item, cell);
			for(Cell c in targetableCells){
				if(map[c]==null){
					map[c]=1.0;//coef
					//map_mp[c]=dist;
				}
			}
		}

		// AOE expansion (handles CIRCLE, PLUS, X, SQUARE)
		MapDanger.expandAOE(map, item)

		return map // TODO add map_mp
	}

	/*
	 * Expand AOE danger using pre-computed area cells
	 * Handles all AOE types: CIRCLE, PLUS, X, SQUARE
	 * @param map Map of cells with danger ratios (1.0 = direct hit)
	 * @param item Item with AOE area type
	 */
	static void expandAOE(Map<Cell, real> map, Item item){
		if(!item.isAOE) return;

		// Collect direct-hit cells
		Array<Cell> directHits = []
		for(Cell c:real value in map){
			if(value == 1.0) push(directHits, c)
		}

		// For each direct-hit, mark all cells in its AOE with decayed ratio
		for(Cell hit in directHits){
			Array<Cell> aoeCells = hit.getAreaCells(item.area)
			for(Cell c in aoeCells){
				if(c == hit) continue  // center already has 1.0
				// Chebyshev distance for ratio decay
				integer dist = max(abs(hit.x - c.x), abs(hit.y - c.y))
				real ratio = max(0.2, 1.0 - 0.2 * dist)
				// Keep higher ratio (protects direct hits and overlapping AOEs)
				if(map[c] == null || map[c] < ratio){
					map[c] = ratio
				}
			}
		}
	}

	/*
	 * Retourne les Cells pouvant être touché avec le parametre item par les ennemis, ignore la los
	 * ce qui permet de garder en cache le résultat pour des bonnes perfs
	 * @see getAlliesTargetableCells
	 * @param item Item
	 * @param cell une Cellule accesible par l'entité en question
	 */
	// TODO memoisé lineOfSight ignoring allEntitiesId
	// fonction avec cache qui considère que los est tjr pareil.
	static Array<Cell> getEnemiesTargetableCells(Item item, Cell cell){
		// init du cache si nécessaire
		if(MapDanger._cache_item_targetableCells[item]==null) 
			MapDanger._cache_item_targetableCells[item] = [:]
		if(MapDanger._cache_item_targetableCells[item]![cell]==null)
			MapDanger._cache_item_targetableCells[item]![cell] = Targets.getTargetableCells(item, cell, Fight.allEntitiesId)
		
		return MapDanger._cache_item_targetableCells[item]![cell]!;
	}
		
	static void showDanger(Cell from, integer mpleft, Consequences consequences) {
		Map<Cell, integer> reachableCells = MapPath.getCachedReachableCells(from, mpleft, Fight.self.cellsToIgnore)
		Array<Danger> arrayDanger = []
		for(Cell c : integer d in reachableCells) {
			Danger danger = MapDanger.getCellDanger(c, consequences)
			integer red = ((danger.dmg*255)/Fight.self.life) as integer
			if(red>255) mark(c.id, getColor(0, 0, 0))
			else mark(c.id, getColor(red, 255-red, 0))
			markText(c.id, round(danger.dmg))
			push(arrayDanger, danger)
		}
	}

}