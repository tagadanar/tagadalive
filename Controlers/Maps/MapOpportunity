/*
 * MapOpportunity - Centralized opportunity index for all algorithms
 *
 * Builds and maintains opportunity data structures used by PTS, MCTS, and other algorithms.
 * Called after MapAction.refresh() since it depends on the entity index.
 *
 * Indexes provided:
 * - opportunities: All opportunities by key (item.id + "_" + entityId)
 * - cellOpportunities: Cell → Array<Opportunity> (which opportunities are reachable from each cell)
 * - cellScores: Cell → weighted opportunity score (for cell prioritization)
 * - sortedOpportunities: Pre-sorted for PTS greedy iteration
 */
class MapOpportunity {
	// ═══════════════════════════════════════════════════════
	// PRIMARY INDEX
	// ═══════════════════════════════════════════════════════
	// Key = item.id + "_" + entityId (unique per item+target pair)
	static Map<string, Opportunity> opportunities = [:]

	// ═══════════════════════════════════════════════════════
	// DERIVED INDEXES
	// ═══════════════════════════════════════════════════════

	// Cell → Opportunities reachable from that cell (for MCTS move decisions)
	// Note: Does NOT include self-cast opportunities (they're position-independent)
	static Map<Cell, Array<Opportunity>> cellOpportunities = [:]

	// Cell → Weighted opportunity score (for cell prioritization)
	// Weights: 1.0 (best), 0.7 (2nd), 0.4 (3rd) - diminishing returns
	static Map<Cell, real> cellScores = [:]

	// Pre-sorted arrays for PTS (self-cast first, then by score desc)
	static Array<Opportunity> sortedSelfCast = []
	static Array<Opportunity> sortedOther = []

	// ═══════════════════════════════════════════════════════
	// STATISTICS
	// ═══════════════════════════════════════════════════════
	static integer totalOpportunities = 0
	static integer totalCellsCovered = 0

	/*
	 * Build all opportunity indexes.
	 * Must be called after MapAction.refresh() since it uses the entity index.
	 */
	static void refresh() {
		// Reset all indexes
		MapOpportunity.opportunities = [:]
		MapOpportunity.cellOpportunities = [:]
		MapOpportunity.cellScores = [:]
		MapOpportunity.sortedSelfCast = []
		MapOpportunity.sortedOther = []

		// Temp collector for cell score calculation
		Map<Cell, Array<real>> cellScoreCollector = [:]

		// Iterate all items
		for (Item item in Fight.self.items) {
			// Skip items on cooldown
			if (getCooldown(item.id, Fight.self.id) > 0) continue

			// Get valid targets for this item
			Map<integer, Entity> targets = item.targetSet()

			// For each target
			for (Entity target in targets) {
				// Skip invincible enemies
				if (target.isInvincible && !target.isFriend) continue

				// Generate opportunity
				Opportunity? opp = MapOpportunity._createOpportunity(item, target)
				if (opp == null) continue

				// Store in primary index
				string key = item.id + "_" + target.id
				MapOpportunity.opportunities[key] = opp!

				// Categorize for sorted arrays
				if (opp!.isSelfCast) {
					push(MapOpportunity.sortedSelfCast, opp!)
				} else {
					push(MapOpportunity.sortedOther, opp!)

					// Build cell → opportunities index (skip self-cast)
					for (Cell attackCell : Cell aimCell in opp!.attackCells) {
						// cellOpportunities index
						if (MapOpportunity.cellOpportunities[attackCell] == null) {
							MapOpportunity.cellOpportunities[attackCell] = []
						}
						push(MapOpportunity.cellOpportunities[attackCell]!, opp!)

						// Collect scores for cellScores (use per-cell score, not baseScore)
						if (cellScoreCollector[attackCell] == null) {
							cellScoreCollector[attackCell] = []
						}
						push(cellScoreCollector[attackCell]!, opp!.attackScores[attackCell]!)
					}
				}
			}
		}

		// Sort opportunities for PTS
		// Sort by score first, priority as tiebreaker (lower priority = higher precedence)
		MapOpportunity.sortedSelfCast = arraySort(MapOpportunity.sortedSelfCast,
			(Opportunity a, Opportunity b) => integer|real {
				if (a.baseScore != b.baseScore) return Sort.desc(a.baseScore, b.baseScore)
				return Sort.asc(a.item.priority, b.item.priority)
			}) as Array<Opportunity>

		MapOpportunity.sortedOther = arraySort(MapOpportunity.sortedOther,
			(Opportunity a, Opportunity b) => integer|real {
				if (a.baseScore != b.baseScore) return Sort.desc(a.baseScore, b.baseScore)
				return Sort.asc(a.item.priority, b.item.priority)
			}) as Array<Opportunity>

		// Compute weighted cell scores
		// Cells with multiple high-scoring opportunities rank higher
		for (Cell cell : Array<real> scores in cellScoreCollector) {
			// Sort descending
			Array<real> sorted = arraySort(scores, (real a, real b) => integer|real {
				return Sort.desc(a, b)
			}) as Array<real>

			// Weighted sum of top 3
			real priority = 0.0
			integer k = min(3, count(sorted))
			for (integer i = 0; i < k; i++) {
				real weight = 1.0 - i * 0.3  // 1.0, 0.7, 0.4
				priority += sorted[i] * weight
			}
			MapOpportunity.cellScores[cell] = priority
		}

		// Update statistics
		MapOpportunity.totalOpportunities = mapSize(MapOpportunity.opportunities)
		MapOpportunity.totalCellsCovered = mapSize(MapOpportunity.cellScores)

		// Debug: could log totalOpportunities, totalCellsCovered, and top 5 sorted opportunities
		// Format: "MapOpportunity: X opps, Y cells" + each opp shows "best:Z close:W cells:N"
	}

	/*
	 * Create an opportunity for a (item, target) pair.
	 * Uses MapAction's pre-validated attack cells and scores.
	 * Computes both closestCell (min MP) and bestScoreCell (max damage).
	 */
	static Opportunity? _createOpportunity(Item item, Entity target) {
		// Self-cast case: item targets self with minRange 0
		if (target == Fight.self && item.minRange == 0) {
			// Create a temporary action to get base score
			Action tempAction = Action(item, Fight.selfCell, Fight.selfCell)
			if (tempAction.score! <= 0) return null
			return Opportunity(target, item, tempAction.score!)
		}

		// Can't target self with minRange > 0
		if (target == Fight.self) return null

		// Get validated attack cells and scores from MapAction index (O(1) lookup)
		Map<Cell, Cell>? attackCells = MapAction.getAttackCellsForEntity(item, target.id)
		Map<Cell, real>? attackScores = MapAction.getScoresForEntity(item, target.id)
		if (attackCells == null || mapSize(attackCells!) == 0) return null
		if (attackScores == null) return null

		// Find closestCell (min MP) and bestScoreCell (max score)
		Cell? closestCell = null
		integer closestDist = 99999
		Cell? bestScoreCell = null
		real bestScore = -999999

		for (Cell attackCell : real score in attackScores!) {
			// Track closest reachable cell
			integer? dist = Fight.self.reachableCells[attackCell]
			if (dist != null && dist! < closestDist) {
				closestDist = dist!
				closestCell = attackCell
			}
			// Track best score cell
			if (score > bestScore) {
				bestScore = score
				bestScoreCell = attackCell
			}
		}

		// Need at least one reachable cell with positive score
		if (closestCell == null || bestScore <= 0) return null

		// Return opportunity with both cells identified
		return Opportunity(target, item, attackCells!, attackScores!, closestCell!, bestScoreCell!)
	}

	// ═══════════════════════════════════════════════════════
	// ACCESSORS
	// ═══════════════════════════════════════════════════════

	/*
	 * Get all opportunities as a map (for iteration or lookup by key)
	 */
	static Map<string, Opportunity> getAllOpportunities() {
		return MapOpportunity.opportunities
	}

	/*
	 * Get sorted opportunities for PTS-style greedy iteration.
	 * Self-cast opportunities come first, then others sorted by score.
	 */
	static Array<Opportunity> getSortedOpportunities() {
		Array<Opportunity> result = []
		for (Opportunity o in MapOpportunity.sortedSelfCast) push(result, o)
		for (Opportunity o in MapOpportunity.sortedOther) push(result, o)
		return result
	}

	/*
	 * Get opportunities achievable from a specific cell.
	 * Returns empty array if no opportunities from that cell.
	 * (For MCTS move decisions)
	 */
	static Array<Opportunity> getOpportunitiesFromCell(Cell cell) {
		Array<Opportunity>? opps = MapOpportunity.cellOpportunities[cell]
		return opps != null ? opps! : ([] as Array<Opportunity>)
	}

	/*
	 * Get cell's opportunity score (for prioritization).
	 * Higher score = more valuable cell for attacking.
	 */
	static real getCellScore(Cell cell) {
		real? score = MapOpportunity.cellScores[cell]
		return score != null ? score! : 0.0
	}

	/*
	 * Get count of opportunities available from a cell.
	 * Useful for "stuck" detection in MCTS.
	 */
	static integer getOpportunityCountFromCell(Cell cell) {
		Array<Opportunity>? opps = MapOpportunity.cellOpportunities[cell]
		return opps != null ? count(opps!) : 0
	}
}
