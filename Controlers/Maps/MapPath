class MapPath{
	static Map<integer, Map<Cell, integer>> _cache_reachable
	static Map<integer, integer> _cache_reachable_size

	static void refresh(){
		MapPath._cache_reachable = [:] // [hash:[cell:distance]]
		MapPath._cache_reachable_size = [:] // [hash:maxmp]
	}
	
	/*
	 * Renvoie l'ensemble de cellules accessibles depuis la cellule (cells) avec la quantité de points de mouvements (mp) en utilisant les voisins.
	 * @param cells -> cellule à partir de laquelle je veux checker (format [Cell:distance]) donc par exemple ma [cellule courante:0]
	 * @param mp -> les points de mouvements
	 * @param ignoreCells -> cellules à ignorer par l'algorithme (treat as walkable even if occupied)
	 * @param newObstacles -> cellules à bloquer (entities moved here during combo simulation)
	 * @return  un tableau contenant pour chaque cellules accessible [Cell:distance]
	 *
	 */
	static Map<Cell, integer> getReachableCells(Map<Cell, integer> cells, integer mp, Set<Cell> ignoreCells, Set<Cell> newObstacles = <>){
		Map<Cell, integer> stack = clone(cells, 2) as Map<Cell, integer>
		Map<Cell, integer> tmp = clone(cells, 2) as Map<Cell, integer>
		Map<Cell, integer> next = [:]
		while(mp-->0){
			for(Cell currentWorkingCell: integer dist in tmp){
				for(Cell c in currentWorkingCell.neighbors){
					if(stack[c] == null
					   && (!Board.entityCells[c] || setContains(ignoreCells, c))
					   && !setContains(newObstacles, c)){
						stack[c] = dist+1
						next[c] = dist+1
					}
				}
			}
			tmp = next
			next = [:]
		}
		return stack
	}
	
	// Persistent cache: jump destinations per cell (walls don't change during fight)
	// Lazy-loaded from AREA_CIRCLE_3, filtered to non-wall non-center cells
	static Map<Cell, Array<Cell>> _cache_jumpDests = [:]

	static Array<Cell> getJumpDests(Cell cell) {
		Array<Cell>? cached = _cache_jumpDests[cell]
		if (cached != null) return cached!
		Array<Cell> dests = []
		for (Cell c in cell.getAreaCells(AREA_CIRCLE_3)) {
			if (c != cell) push(dests, c)
		}
		_cache_jumpDests[cell] = dests
		return dests
	}

	/*
	 * State-space BFS for jump reachability (adapted from pathbench).
	 * Reuses pre-computed walk map as the "canJump" state.
	 * Two states: canJump (walk, reused) and usedJump (new).
	 * Jump is free (0 MP), walk costs 1 MP.
	 * Returns superset of walk map.
	 */
	static Map<Cell, integer> getJumpReachableCells(Map<Cell, integer> walk, integer mp,
			Set<Cell> ignoreCells, Set<Cell> newObstacles) {
		// Reconstruct walk frontiers by distance
		Array<Array<Cell>> walkFrontiers = []
		for (integer i = 0; i <= mp; i++) push(walkFrontiers, [])
		for (Cell c : integer d in walk) {
			if (d <= mp) push(walkFrontiers[d]!, c)
		}

		// usedJump state: cells reachable after having jumped
		Map<Cell, integer> usedJump = [:]
		Array<Cell> ujFrontier = []

		for (integer cost = 0; cost <= mp; cost++) {
			// Step 1: Jump transitions from walk frontier at this cost (free)
			for (Cell cell in walkFrontiers[cost]!) {
				for (Cell j in MapPath.getJumpDests(cell)) {
					if (usedJump[j] != null) continue
					if (walk[j] != null && walk[j]! <= cost) continue
					if (Board.entityCells[j] && !setContains(ignoreCells, j)) continue
					if (setContains(newObstacles, j)) continue
					usedJump[j] = cost
					push(ujFrontier, j)
				}
			}

			// Step 2: Walk from usedJump frontier (cost + 1)
			if (cost < mp) {
				integer nextCost = cost + 1
				Array<Cell> nextUjFrontier = []
				for (Cell cell in ujFrontier) {
					for (Cell n in cell.neighbors) {
						if (usedJump[n] == null
							&& (walk[n] == null || walk[n]! > nextCost)
							&& (!Board.entityCells[n] || setContains(ignoreCells, n))
							&& !setContains(newObstacles, n)) {
							usedJump[n] = nextCost
							push(nextUjFrontier, n)
						}
					}
				}
				ujFrontier = nextUjFrontier
			}
		}

		// Merge: walk ∪ usedJump (keep minimum distance)
		Map<Cell, integer> result = clone(walk, 2) as Map<Cell, integer>
		for (Cell c : integer d in usedJump) {
			if (result[c] == null || result[c]! > d) result[c] = d
		}
		return result
	}

	static integer getHashcode(Cell from, Set<Cell> ignoreCells, Set<Cell> newObstacles = <>){
		integer hash = 31
		hash = hash*37+from.id
		for(Cell c in ignoreCells){
			hash = hash*37+c.id
		}
		for(Cell c in newObstacles){
			hash = hash*41+c.id
		}
		return hash
	}

	/*
	 * Returns cached reachable cells from a position.
	 * WARNING: Cache may contain cells beyond requested mp if previously expanded.
	 * Callers MUST check distance <= mp when iterating results!
	 *
	 * @param newObstacles Cells blocked by position swaps (e.g., after inversion)
	 */
	static Map<Cell, integer> getCachedReachableCells(Cell from, integer mp, Set<Cell> ignoreCells, Set<Cell> newObstacles = <>){
		integer hash = MapPath.getHashcode(from, ignoreCells, newObstacles)
		Map<Cell, integer>? result = MapPath._cache_reachable[hash]
		if(result==null){
			result = MapPath.getReachableCells([from:0], mp, ignoreCells, newObstacles)
			MapPath._cache_reachable_size[hash] = mp
			MapPath._cache_reachable[hash] = result
		}else if(MapPath._cache_reachable_size[hash] < mp){
			result = MapPath.getReachableCells(MapPath._cache_reachable[hash]!, mp-MapPath._cache_reachable_size[hash], ignoreCells, newObstacles)
			MapPath._cache_reachable_size[hash] = mp
			MapPath._cache_reachable[hash] = result
		}
		return result!
	}
}