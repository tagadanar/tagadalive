/*
 * Controller for position evaluation and end-of-turn positioning decisions.
 * Handles gravity cells, threat detection, and comprehensive position scoring.
 */
class MapPosition {
	// === Gravity configuration ===
	static Map<Cell, integer> _gravity_distance = [:]  // [cell: ideal distance]
	static Map<Cell, real> _gravity_coef = [:]         // [cell: weight]
	static real _total_ally_coef = 0.0

	// === Threat detection ===
	// Note: enemyHasStr is now in BattleState.enemyHasStr
	static boolean _enemies_have_snc = false
	static boolean _need_shields = false
	static boolean _is_cac = false

	// === COVID tracking ===
	static boolean _has_covid = false
	static Map<Entity, boolean> _entity_has_covid = [:]

	// === Cached data ===
	static Map<Cell, integer>? _nearest_enemy_path_dist = null  // path distances FROM nearest enemy
	static Entity? _nearest_enemy = null

	// === Position cache (like MapDanger pattern) ===
	static Map<Cell, Position> _position = [:]  // [cell: position]
	static Map<integer, Map<Cell, Position>> _hash_position = [:]  // [hashcode: [cell: position]]

	/*
	 * Refresh all position-related caches. Called once per turn.
	 */
	static void refresh() {
		// Reset position cache
		_position = [:]
		_hash_position = [:]

		MapPosition._refreshNearestEnemy()
		MapPosition._refreshNearestEnemyPathDist()
		MapPosition._refreshThreatDetection()
		MapPosition._refreshGravityCells()
		MapPosition._refreshCovid()
	}

	/*
	 * Cache path distances from nearest enemy to all cells.
	 * Used for accurate gravity calculation (accounts for walls).
	 */
	static void _refreshNearestEnemyPathDist() {
		if (_nearest_enemy != null) {
			_nearest_enemy_path_dist = MapPath.getCachedReachableCells(_nearest_enemy!.cell, 100, [])
		} else {
			_nearest_enemy_path_dist = null
		}
	}

	/*
	 * Detect enemy threat levels
	 * Note: enemyHasStr is computed in BattleState.refresh()
	 */
	static void _refreshThreatDetection() {
		_enemies_have_snc = false

		for (Entity e in Fight.getEnemiesAlive()) {
			if (e.snc > 200) _enemies_have_snc = true
		}

		_need_shields = (BattleState.enemyHasStr || _enemies_have_snc) &&
						(Fight.self.absShield == 0 || Fight.self.relShield == 0)

		_is_cac = false
		Item? currentWeapon = Fight.self.getWeaponInHand()
		if (currentWeapon != null && currentWeapon!.maxRange <= 2) {
			_is_cac = true
		}
	}

	/*
	 * Compute gravity cells - attraction/repulsion targets with ideal distances
	 */
	static void _refreshGravityCells() {
		_gravity_distance = [:]
		_gravity_coef = [:]
		_total_ally_coef = 0.0  // IMPORTANT: Must use 0.0, not 0 (LeekScript type issue)
		real coef
		boolean isSummon = Fight.self.isBulb

		for (Entity ally in Fight.getAlliesLeeksAlive()) {
			if (ally == Fight.self) continue;
			if (isSummon) coef = ScoringConfig.W_GRAVITY_ALLY_SUMMON
			else if (ally.snc >= 600) coef = ScoringConfig.W_GRAVITY_ALLY_SNC600
			else if (ally.snc >= 400) coef = ScoringConfig.W_GRAVITY_ALLY_SNC400
			else if (ally.wsd >= 400) coef = ScoringConfig.W_GRAVITY_ALLY_WIS400
			else if (ally.rst >= 200) coef = ScoringConfig.W_GRAVITY_ALLY_RST200
			else if (ally.wsd >= 200) coef = ScoringConfig.W_GRAVITY_ALLY_WIS200
			else coef = ScoringConfig.W_GRAVITY_ALLY_DEFAULT
			_gravity_distance[ally.cell] = ScoringConfig.IDEAL_DIST_ALLY
			_gravity_coef[ally.cell] = coef
			_total_ally_coef += coef
		}

		if (!isSummon) {
			real lifeRatio = Fight.self.life / Fight.self.totalLife
			for (Entity bulb in Fight.getAlliesBulbsAlive()) {
				_gravity_distance[bulb.cell] = ScoringConfig.IDEAL_DIST_ALLY
				if (_need_shields) coef = ScoringConfig.W_GRAVITY_METALLIC_NEED_ARMOR
				else if (lifeRatio < 0.9) coef = ScoringConfig.W_GRAVITY_HEALER_NEED_HEAL
				else coef = ScoringConfig.W_GRAVITY_ALLY_DEFAULT
				_gravity_coef[bulb.cell] = coef
				_total_ally_coef += coef
			}
		}

		var enemies = Fight.getEnemiesLeeksAlive()
		integer enemyCount = mapSize(enemies)
		if (enemyCount == 0) enemyCount = 1

		real enemyCoef
		real lifeRatio2 = Fight.self.life / Fight.self.totalLife
		if (!isSummon && lifeRatio2 > 0.8 && !_need_shields) {
			enemyCoef = ceil(_total_ally_coef / enemyCount)
		} else {
			enemyCoef = floor(_total_ally_coef / enemyCount)
		}
		if (enemyCoef < 1) enemyCoef = 1

		integer distToEnemy = _is_cac ? ScoringConfig.IDEAL_DIST_CAC : Scoring.IDEAL_DIST_RANGED
		for (Entity enemy in enemies) {
			_gravity_distance[enemy.cell] = distToEnemy
			_gravity_coef[enemy.cell] = enemyCoef
		}

		if (distToEnemy < 20 && !_need_shields) {
			for (Entity eBulb in Fight.getEnemiesBulbsAlive()) {
				_gravity_distance[eBulb.cell] = ScoringConfig.IDEAL_DIST_CAC
				_gravity_coef[eBulb.cell] = enemyCoef * 0.5
			}
		}

		Cell? centerCell = Board.getCell(306)
		if (centerCell != null) {
			_gravity_distance[centerCell!] = ScoringConfig.IDEAL_DIST_CENTER
			_gravity_coef[centerCell!] = enemyCoef
		}
	}

	/*
	 * Detect COVID chip and tracking
	 */
	static void _refreshCovid() {
		_has_covid = false
		_entity_has_covid = [:]

		Array<integer>? chips = getChips(Fight.self.id)
		if (chips != null) {
			for (integer chipId in chips!) {
				if (chipId == CHIP_COVID) {
					_has_covid = true
					break
				}
			}
		}

		if (_has_covid) {
			for (Entity e in Fight.getEnemiesAlive()) {
				_entity_has_covid[e] = false
				for (EntityEffect eff in e.effects) {
					if (eff.item.id == CHIP_COVID) {
						_entity_has_covid[e] = true
						break
					}
				}
			}
		}
	}

	/*
	 * Cache nearest enemy (leek, mob, or turret - not bulb or chest)
	 */
	static void _refreshNearestEnemy() {
		_nearest_enemy = null
		integer nearestDist = 999

		for (Entity e in Fight.getEnemiesAlive()) {
			// Only consider leeks, mobs, and turrets
			if (e.entityType == ENTITY_BULB || e.entityType == ENTITY_CHEST) continue

			integer dist = getCellDistance(Fight.self.cell.id, e.cell.id)
			if (dist < nearestDist) {
				nearestDist = dist
				_nearest_enemy = e
			}
		}
	}

	/*
	 * Get cached path distances from nearest enemy.
	 */
	static Map<Cell, integer>? getNearestEnemyPathDist() {
		return _nearest_enemy_path_dist
	}

	/*
	 * Main position evaluation function.
	 * Uses cache (like MapDanger.getCellDanger) to avoid recomputation.
	 */
	static Position evaluatePosition(Cell cell, Consequences? consequences) {
		Benchmark.start("MP.evalPos")

		// Check cache first (like MapDanger pattern)
		if (consequences != null && consequences!.isAlteringDanger) {
			if (_hash_position[consequences!.hashcode] != null &&
				_hash_position[consequences!.hashcode]![cell] != null) {
				Benchmark.stop("MP.evalPos")
				return _hash_position[consequences!.hashcode]![cell]!
			}
		} else {
			if (_position[cell] != null) {
				Benchmark.stop("MP.evalPos")
				return _position[cell]!
			}
		}

		// Cache miss - compute fresh
		Danger baseDanger = MapDanger.getCellDanger(cell, consequences)
		Position pos = Position(baseDanger)

		real lifePercent = Fight.self.getCurrentHP(consequences) / Fight.self.totalLife
		pos.applyLifeScaling(lifePercent)

		pos.addProximityScore(MapPosition._computeProximityPenalty(cell, _nearest_enemy))
		pos.addGravityScore(MapPosition._computeGravityScore(cell))
		pos.addTacticalScore(MapPosition._computeTacticalScore(cell, consequences))

		if (BattleState.enemyHasStr || _enemies_have_snc) {
			real shieldValue = Fight.self.getCurrentAbs(consequences) * ScoringConfig.W_SHIELD_ABS +
							   Fight.self.getCurrentRel(consequences) * ScoringConfig.W_SHIELD_REL
			pos.addShieldScore(shieldValue)
		}

		// Store in cache
		if (consequences != null && consequences!.isAlteringDanger) {
			if (_hash_position[consequences!.hashcode] == null) {
				_hash_position[consequences!.hashcode] = [:]
			}
			_hash_position[consequences!.hashcode]![cell] = pos
		} else {
			_position[cell] = pos
		}

		Benchmark.stop("MP.evalPos")
		return pos
	}

	/*
	 * Compute proximity penalty for nearby enemies
	 * 
	 * Optimization: Pre-compute area cells and use Map for O(1) lookup
	 * instead of calling getAreaCells() + inArray() O(n) at each iteration.
	 * Saves ~380 ops per call Ã— ~50-100 positions = ~19k-38k ops per turn.
	 */
	static real _computeProximityPenalty(Cell cell, Entity? primaryTarget) {
		real penalty = 0
		Cell? primaryCell = primaryTarget != null ? primaryTarget!.cell : null

		// Pre-compute area cells ONCE (instead of recalculating each iteration)
		Array<Cell> area1 = cell.getAreaCells(AREA_CIRCLE_1)
		Array<Cell> area2 = cell.getAreaCells(AREA_CIRCLE_2)
		Array<Cell> area3 = cell.getAreaCells(AREA_CIRCLE_3)

		// Create Maps for O(1) lookup (instead of inArray O(n) scan)
		Map<Cell, boolean> area1Set = [:]
		for (Cell c in area1) area1Set[c] = true

		Map<Cell, boolean> area2Set = [:]
		for (Cell c in area2) area2Set[c] = true

		// Loop 1: AREA_CIRCLE_1 (innermost ring)
		for (Cell c in area1) {
			if (c == cell) continue
			Entity? enemy = Board.entityCells[c]
			if (enemy != null && !enemy!.isFriend && c != primaryCell) {
				penalty -= ScoringConfig.W_PROXIMITY_AREA1
			}
		}

		// Loop 2: AREA_CIRCLE_2 minus AREA_CIRCLE_1 (middle ring only)
		for (Cell c in area2) {
			if (area1Set[c]) continue  // O(1) lookup instead of inArray O(n)
			Entity? enemy = Board.entityCells[c]
			if (enemy != null && !enemy!.isFriend && c != primaryCell) {
				penalty -= ScoringConfig.W_PROXIMITY_AREA2
			}
		}

		// Loop 3: AREA_CIRCLE_3 minus AREA_CIRCLE_2 (outer ring only)
		for (Cell c in area3) {
			if (area2Set[c]) continue  // O(1) lookup instead of inArray O(n)
			Entity? enemy = Board.entityCells[c]
			if (enemy != null && !enemy!.isFriend && c != primaryCell) {
				penalty -= ScoringConfig.W_PROXIMITY_AREA3
			}
		}

		return penalty
	}

	/*
	 * Compute gravity score - penalize deviation from ideal distances
	 * Uses path distance for nearest enemy (accounts for walls), cell distance for others
	 */
	static real _computeGravityScore(Cell cell) {
		real score = 0
		boolean hasGravity = false
		for (var x in _gravity_distance) { hasGravity = true; break; }
		if (!hasGravity) return score;

		for (Cell targetCell : integer idealDist in _gravity_distance) {
			real coef = _gravity_coef[targetCell]!
			integer actualDist

			// Use path distance for nearest enemy (accurate), cell distance for others
			if (_nearest_enemy != null && targetCell == _nearest_enemy!.cell && _nearest_enemy_path_dist != null) {
				actualDist = _nearest_enemy_path_dist![cell] != null ? _nearest_enemy_path_dist![cell]! : 99
			} else {
				actualDist = getCellDistance(cell.id, targetCell.id)
			}

			integer deviation = abs(idealDist - actualDist)

			if (_is_cac && _nearest_enemy != null && targetCell == _nearest_enemy!.cell) {
				integer enemyMP = _nearest_enemy!.mp - _nearest_enemy!.altMP
				if (actualDist <= enemyMP + Fight.self.mp) {
					score += ScoringConfig.W_CAC_IN_RANGE
				}
			}

			score -= deviation * coef
		}

		return score
	}

	/*
	 * Compute tactical bonuses (lock, COVID, etc.)
	 */
	static real _computeTacticalScore(Cell cell, Consequences? consequences) {
		real bonus = 0

		// Lock bonus
		if (_nearest_enemy != null) {
			Array<Cell> enemyAdjacent = _nearest_enemy!.cell.getAreaCells(AREA_CIRCLE_1)
			integer walkableCount = 0
			Cell? onlyWalkable = null
			for (Cell c in enemyAdjacent) {
				if (c == _nearest_enemy!.cell) continue
				if (!c.isWall && Board.entityCells[c] == null) {
					walkableCount++
					onlyWalkable = c
				}
			}
			if (walkableCount == 1 && onlyWalkable == cell) {
				bonus += Scoring.W_LOCK_BONUS
			}
		}

		// COVID bonus
		if (_has_covid) {
			for (Cell c in cell.getAreaCells(AREA_CIRCLE_2)) {
				Entity? enemy = Board.entityCells[c]
				if (enemy != null && !enemy!.isFriend) {
					boolean hasCovid = _entity_has_covid[enemy!] == true
					if (!hasCovid) {
						if (enemy!.isBulb) {
							bonus += ScoringConfig.W_COVID_SUMMON
						} else {
							bonus += ScoringConfig.W_COVID_LEEK
						}
					}
				}
			}
		}

		return bonus
	}

	/*
	 * Find the best position from reachable cells.
	 */
	static Position findBestPosition(Cell from, integer mpLeft, Consequences? consequences) {
		Benchmark.start("MP.findBest")
		Map<Cell, integer> reachableCells = MapPath.getCachedReachableCells(from, mpLeft, Fight.self.cellsToIgnore)

		Position? bestPosition = null
		for (Cell cell : integer mp in reachableCells) {
			if (mp > mpLeft) break
			Position pos = MapPosition.evaluatePosition(cell, consequences)
			if (bestPosition == null || pos.score > bestPosition!.score) {
				bestPosition = pos
			}
		}

		if (bestPosition == null) {
			bestPosition = MapPosition.evaluatePosition(from, consequences)
		}

		Benchmark.stop("MP.findBest")
		return bestPosition!
	}

	/*
	 * Display position scores on the map (for debugging)
	 * Color: based on danger only (red = high danger, green = low danger)
	 * Text: positioningScore | danger
	 * Uses cached positions from evaluatePosition - cheap after findBestPosition runs
	 */
	static void showPosition(Cell from, integer mpleft, Consequences? consequences) {
		Benchmark.start("MP.showPos")
		Map<Cell, integer> reachableCells = MapPath.getCachedReachableCells(from, mpleft, Fight.self.cellsToIgnore)
		for (Cell c : integer d in reachableCells) {
			Position pos = MapPosition.evaluatePosition(c, consequences)
			// Color: based on danger only (like showDanger)
			integer red = ((pos.dmg * 255) / Fight.self.life) as integer
			if (red > 255) mark(c.id, getColor(0, 0, 0))
			else mark(c.id, getColor(red, 255 - red, 0))
			// Text: positioning score (non-danger components) | danger
			integer posScore = round(pos.proximityScore + pos.gravityScore + pos.tacticalScore + pos.shieldScore)
			integer dangerVal = round(pos.dmg)
			markText(c.id, posScore + " | " + dangerVal)
		}
		Benchmark.stop("MP.showPos")
	}
}
