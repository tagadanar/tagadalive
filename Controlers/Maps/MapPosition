/*
 * Controller for position evaluation and end-of-turn positioning decisions.
 * Handles gravity cells, threat detection, and comprehensive position scoring.
 *
 * ┌─────────────────────────────────────────────────────────────────────────┐
 * │ POSITION SCORING ARCHITECTURE (3-file split):                          │
 * │  • AI/ScoringConfig: Weight constants and thresholds                   │
 * │  • Model/Combos/Position: Position class with score components         │
 * │  • Controlers/Maps/MapPosition (this file): Search for best position   │
 * └─────────────────────────────────────────────────────────────────────────┘
 */
class MapPosition {
	// === Gravity configuration ===
	static Map<Cell, integer> _gravity_distance = [:]  // [cell: ideal distance]
	static Map<Cell, real> _gravity_coef = [:]         // [cell: weight]

	// === Threat detection ===
	// Note: enemyHasStr is now in BattleState.enemyHasStr
	static boolean _enemies_have_snc = false
	static boolean _need_shields = false
	static boolean _is_cac = false

	// === Cached data ===
	static Map<Cell, integer>? _nearest_enemy_path_dist = null  // path distances FROM nearest enemy
	static Entity? _nearest_enemy = null

	// === Position cache (like MapDanger pattern) ===
	static Map<Cell, Position> _position = [:]  // [cell: position]
	static Map<integer, Map<Cell, Position>> _hash_position = [:]  // [hashcode: [cell: position]]

	/*
	 * Refresh all position-related caches. Called once per turn.
	 */
	static void refresh() {
		// Reset position cache
		_position = [:]
		_hash_position = [:]

		MapPosition._refreshNearestEnemy()
		MapPosition._refreshNearestEnemyPathDist()
		MapPosition._refreshThreatDetection()
		MapPosition._refreshGravityCells()

		// Precompute position grid for fast MCTS lookups
		MapPosition._precomputeGrid()
	}

	/*
	 * Precompute position scores for reachable cells.
	 * Pre-fills _position cache for O(1) lookups during MCTS rollout.
	 * Uses Fight.self.extendedReachableCells (computed in Entity.init).
	 * Cells outside this range are lazy-evaluated on demand.
	 *
	 * Cost: ~100-150 cells × ~500 ops = ~50k-75k ops (down from ~310k)
	 */
	static void _precomputeGrid() {
		Benchmark.start("MP.precompute")
		// Use extendedReachableCells (includes MP buff potential)
		// Lazy evaluation handles edge cases
		for (Cell cell : integer dist in Fight.self.extendedReachableCells) {
			// evaluatePosition caches result in _position[cell]
			MapPosition.evaluatePosition(cell, null)
		}
		Benchmark.stop("MP.precompute")
	}

	/*
	 * Cache path distances from nearest enemy to all cells.
	 * Used for accurate gravity calculation (accounts for walls).
	 */
	static void _refreshNearestEnemyPathDist() {
		if (_nearest_enemy != null) {
			// Ignore all entities to get pure terrain path distance
			_nearest_enemy_path_dist = MapPath.getCachedReachableCells(_nearest_enemy!.cell, 100, arrayToSet(mapKeys(Board.entityCells)) as Set<Cell>)
		} else {
			_nearest_enemy_path_dist = null
		}
	}

	/*
	 * Detect enemy threat levels
	 * Note: enemyHasStr is computed in BattleState.refresh()
	 */
	static void _refreshThreatDetection() {
		_enemies_have_snc = false

		for (Entity e in Fight.getEnemiesAlive()) {
			if (e.snc > ScoringConfig.THREAT_SNC_THRESHOLD) _enemies_have_snc = true
		}

		_need_shields = (BattleState.enemyHasStr || _enemies_have_snc) &&
						(Fight.self.absShield == 0 || Fight.self.relShield == 0)

		_is_cac = false
		Item? currentWeapon = Fight.self.getWeaponInHand()
		if (currentWeapon != null && currentWeapon!.maxRange <= 2) {
			_is_cac = true
		}
	}

	/*
	 * Compute gravity cells - attraction/repulsion targets with ideal distances
	 *
	 * Gravity system by fight type:
	 * - Team fight: ally turret + enemy turret
	 * - Farmer fight: nearest enemy + farthest ally from barycentre (help isolated teammates)
	 * - Solo/default: nearest enemy + center
	 *
	 * Ally attraction is now handled by the support map (MapSupport) which provides
	 * more accurate positioning based on actual support potential (heal + shields).
	 */
	static void _refreshGravityCells() {
		_gravity_distance = [:]
		_gravity_coef = [:]

		integer fightType = getFightType()

		if (fightType == FIGHT_TYPE_TEAM) {
			// Team fight: attract to ally turret (protect) and enemy turret (attack)
			for (Entity ally in Fight.getAlliesAlive()) {
				if (ally.entityType == ENTITY_TURRET) {
					_gravity_distance[ally.cell] = ScoringConfig.IDEAL_DIST_ALLY
					_gravity_coef[ally.cell] = ScoringConfig.W_GRAVITY_ALLY_TURRET
					break  // Only one turret per team
				}
			}
			for (Entity enemy in Fight.getEnemiesAlive()) {
				if (enemy.entityType == ENTITY_TURRET) {
					integer distToEnemy = _is_cac ? ScoringConfig.IDEAL_DIST_CAC : Scoring.IDEAL_DIST_RANGED
					_gravity_distance[enemy.cell] = distToEnemy
					_gravity_coef[enemy.cell] = ScoringConfig.W_GRAVITY_ENEMY_TURRET
					break  // Only one turret per team
				}
			}
		} else if (fightType == FIGHT_TYPE_FARMER) {
			// Farmer fight: nearest enemy + farthest ally from barycentre

			// Nearest enemy
			if (_nearest_enemy != null) {
				integer distToEnemy = _is_cac ? ScoringConfig.IDEAL_DIST_CAC : Scoring.IDEAL_DIST_RANGED
				_gravity_distance[_nearest_enemy!.cell] = distToEnemy
				_gravity_coef[_nearest_enemy!.cell] = ScoringConfig.W_GRAVITY_NEAREST_ENEMY
			}

			// Farthest ally from barycentre (team cohesion - help isolated teammates)
			Entity? farthestAlly = MapTactical.getFarthestAllyFromBarycentre()
			if (farthestAlly != null) {
				_gravity_distance[farthestAlly!.cell] = ScoringConfig.IDEAL_DIST_ALLY
				_gravity_coef[farthestAlly!.cell] = ScoringConfig.W_GRAVITY_ALLY_BARYCENTRE
			}
		} else {
			// Solo/default: nearest enemy + center

			// Nearest enemy
			if (_nearest_enemy != null) {
				integer distToEnemy = _is_cac ? ScoringConfig.IDEAL_DIST_CAC : Scoring.IDEAL_DIST_RANGED
				_gravity_distance[_nearest_enemy!.cell] = distToEnemy
				_gravity_coef[_nearest_enemy!.cell] = ScoringConfig.W_GRAVITY_NEAREST_ENEMY
			}

			// Center
			Cell? centerCell = Board.getCell(306)
			if (centerCell != null) {
				_gravity_distance[centerCell!] = ScoringConfig.IDEAL_DIST_CENTER
				_gravity_coef[centerCell!] = ScoringConfig.W_GRAVITY_CENTER
			}
		}

		// Fennel King boss: gravity toward farthest crystal from graal
		if (BossFennel.isActive() && !BossFennel.isPuzzleSolved()) {
			Entity? farthestCrystal = BossFennel.getFarthestCrystalFromGraal()
			if (farthestCrystal != null) {
				_gravity_distance[farthestCrystal!.cell] = 1
				_gravity_coef[farthestCrystal!.cell] = BossFennel.W_GRAVITY_GRAAL
			}
		}

		// Chests: gravity to collect loot
		for (Entity enemy in Fight.getEnemiesAlive()) {
			if (enemy.entityType == ENTITY_CHEST) {
				_gravity_distance[enemy.cell] = 1  // Get adjacent to open
				_gravity_coef[enemy.cell] = ScoringConfig.W_GRAVITY_CHEST
			}
		}
	}

	/*
	 * Cache nearest enemy (leek, mob, or turret - not bulb or chest)
	 * During Fennel puzzle: calculate from farthest crystal position instead of self
	 */
	static void _refreshNearestEnemy() {
		_nearest_enemy = null
		integer nearestDist = 999

		// During Fennel puzzle, find enemy nearest to farthest crystal (not self)
		Cell referenceCell = Fight.self.cell
		if (BossFennel.isActive() && !BossFennel.isPuzzleSolved()) {
			Entity? farthestCrystal = BossFennel.getFarthestCrystalFromGraal()
			if (farthestCrystal != null) {
				referenceCell = farthestCrystal!.cell
			}
		}

		for (Entity e in Fight.getEnemiesAlive()) {
			// Only consider leeks, mobs, and turrets
			if (e.entityType == ENTITY_BULB || e.entityType == ENTITY_CHEST) continue

			integer dist = getCellDistance(referenceCell.id, e.cell.id)
			if (dist < nearestDist) {
				nearestDist = dist
				_nearest_enemy = e
			}
		}
	}

	/*
	 * Get cached path distances from nearest enemy.
	 */
	static Map<Cell, integer>? getNearestEnemyPathDist() {
		return _nearest_enemy_path_dist
	}

	/*
	 * Main position evaluation function.
	 * Uses cache (like MapDanger.getCellDanger) to avoid recomputation.
	 *
	 * OPTIMIZATION: When consequences alter danger (kills, debuffs), we reuse
	 * precomputed proximity/gravity/tactical scores from _position[cell] since
	 * these don't depend on consequences (they use Board.entityCells which is
	 * real state, not simulated). Only danger, life scaling, and shields are
	 * recomputed. Saves ~550 ops per call with altering consequences.
	 */
	static Position evaluatePosition(Cell cell, Consequences? consequences) {
		Benchmark.start("MP.evalPos")

		// Check cache first (like MapDanger pattern)
		if (consequences != null && consequences!.isAlteringDanger) {
			integer key = consequences!.hashcode * 997 + consequences!.dangerMPHash
			if (_hash_position[key] != null &&
				_hash_position[key]![cell] != null) {
				Benchmark.stop("MP.evalPos")
				return _hash_position[key]![cell]!
			}
		} else {
			if (_position[cell] != null) {
				Benchmark.stop("MP.evalPos")
				return _position[cell]!
			}
		}

		// Cache miss - compute fresh
		Danger baseDanger = MapDanger.getCellDanger(cell, consequences)
		Position pos = Position(baseDanger)

		pos.applyLifeScaling(consequences)

		// OPTIMIZATION: Reuse precomputed tactical scores for altering consequences
		// These scores don't depend on consequences (use real board state, not simulated)
		if (consequences != null && consequences!.isAlteringDanger && _position[cell] != null) {
			Position base = _position[cell]!
			pos.proximityScore = base.proximityScore
			pos.gravityScore = base.gravityScore
			pos.tacticalScore = base.tacticalScore
			pos.score += base.proximityScore + base.gravityScore + base.tacticalScore
		} else {
			// Full computation for base case (or when no precomputed cache available)
			pos.addProximityScore(MapPosition._computeProximityPenalty(cell, _nearest_enemy))
			pos.addGravityScore(MapPosition._computeGravityScore(cell))
			pos.addTacticalScore(MapPosition._computeTacticalScore(cell))
		}

		// Store in cache
		if (consequences != null && consequences!.isAlteringDanger) {
			integer key = consequences!.hashcode * 997 + consequences!.dangerMPHash
			if (_hash_position[key] == null) {
				_hash_position[key] = [:]
			}
			_hash_position[key]![cell] = pos
		} else {
			_position[cell] = pos
		}

		Benchmark.stop("MP.evalPos")
		return pos
	}

	/*
	 * Compute proximity penalty for nearby allies (avoid AoE clustering)
	 *
	 * Optimization: Use Set area cells and use setContains for O(1) lookup
	 * instead of calling getAreaCells() + inArray() O(n) at each iteration.
	 * Saves ~380 ops per call × ~50-100 positions = ~19k-38k ops per turn.
	 */
	static real _computeProximityPenalty(Cell cell, Entity? primaryTarget) {
		real penalty = 0.0

		// Pre-compute area cells ONCE (instead of recalculating each iteration)
		Set<Cell> area1 = cell.getAreaCells(AREA_CIRCLE_1)
		Set<Cell> area2 = cell.getAreaCells(AREA_CIRCLE_2)
		Set<Cell> area3 = cell.getAreaCells(AREA_CIRCLE_3)

		// Loop 1: AREA_CIRCLE_1 (innermost ring)
		for (Cell c in area1) {
			if (c == cell) continue
			Entity? entity = Board.entityCells[c]
			if (entity != null && entity!.isFriend) {
				penalty -= ScoringConfig.W_PROXIMITY_AREA1
			}
		}

		// Loop 2: AREA_CIRCLE_2 minus AREA_CIRCLE_1 (middle ring only)
		for (Cell c in area2) {
			if (setContains(area1, c)) continue  // O(1) lookup instead of inArray O(n)
			Entity? entity = Board.entityCells[c]
			if (entity != null && entity!.isFriend) {
				penalty -= ScoringConfig.W_PROXIMITY_AREA2
			}
		}

		// Loop 3: AREA_CIRCLE_3 minus AREA_CIRCLE_2 (outer ring only)
		for (Cell c in area3) {
			if (setContains(area2, c)) continue  // O(1) lookup instead of inArray O(n)
			Entity? entity = Board.entityCells[c]
			if (entity != null && entity!.isFriend) {
				penalty -= ScoringConfig.W_PROXIMITY_AREA3
			}
		}

		return penalty
	}

	/*
	 * Compute gravity score - penalize deviation from ideal distances
	 * Uses path distance for nearest enemy (accounts for walls), cell distance for others
	 */
	static real _computeGravityScore(Cell cell) {
		real score = 0.0
		boolean hasGravity = false
		for (var x in _gravity_distance) { hasGravity = true; break; }
		if (!hasGravity) return score;

		for (Cell targetCell : integer idealDist in _gravity_distance) {
			real coef = _gravity_coef[targetCell]!
			integer actualDist

			// Use path distance for nearest enemy (accurate), cell distance for others
			if (_nearest_enemy != null && targetCell == _nearest_enemy!.cell && _nearest_enemy_path_dist != null) {
				actualDist = _nearest_enemy_path_dist![cell] != null ? _nearest_enemy_path_dist![cell]! : 99
			} else {
				actualDist = getCellDistance(cell.id, targetCell.id)
			}

			integer deviation = abs(idealDist - actualDist)

			if (_is_cac && _nearest_enemy != null && targetCell == _nearest_enemy!.cell) {
				integer enemyMP = _nearest_enemy!.mp - _nearest_enemy!.altMP
				if (actualDist <= enemyMP + Fight.self.mp) {
					score += ScoringConfig.W_CAC_IN_RANGE
				}
			}

			score -= deviation * coef
		}

		return score
	}

	/*
	 * Compute tactical bonuses (lock, COVID, etc.)
	 * Note: Uses real board state (Board.entityCells, _nearest_enemy, etc.)
	 * which doesn't depend on consequences - positions are fixed until turn executes.
	 */
	static real _computeTacticalScore(Cell cell) {
		real bonus = 0.0

		// Lock bonus
		if (_nearest_enemy != null) {
			Set<Cell> enemyAdjacent = _nearest_enemy!.cell.getAreaCells(AREA_CIRCLE_1)
			integer walkableCount = 0
			Cell? onlyWalkable = null
			for (Cell c in enemyAdjacent) {
				if (c == _nearest_enemy!.cell) continue
				if (Board.entityCells[c] == null) {
					walkableCount++
					onlyWalkable = c
				}
			}
			if (walkableCount == 1 && onlyWalkable == cell) {
				bonus += Scoring.W_LOCK_BONUS
			}
		}

		// COVID positioning: when self has COVID effect, get close to enemies (spread) and away from allies (protect)
		// Skip if antidote ready - we'll cure ourselves, no need for spread/protect positioning
		if (Fight.self.hasCovid && !Fight.antidoteReady) {
			for (Cell c in cell.getAreaCells(AREA_CIRCLE_2)) {
				Entity? entity = Board.entityCells[c]
				if (entity != null && entity! != Fight.self) {
					if (!entity!.isFriend && !entity!.hasCovid) {
						// Bonus for enemies without COVID (can spread to them)
						if (entity!.isBulb) {
							bonus += ScoringConfig.W_COVID_SUMMON
						} else {
							bonus += ScoringConfig.W_COVID_LEEK
						}
					} else if (entity!.isFriend && !entity!.hasCovid) {
						// Penalty for allies without COVID (avoid infecting them)
						if (entity!.isBulb) {
							bonus -= ScoringConfig.W_COVID_SUMMON
						} else {
							bonus -= ScoringConfig.W_COVID_LEEK
						}
					}
				}
			}
		}

		return bonus
	}

	/*
	 * Find the best position from reachable cells.
	 */
	static Position findBestPosition(Cell from, integer mpLeft, Consequences? consequences) {
		Benchmark.start("MP.findBest")
		Map<Cell, integer> reachableCells = MapPath.getCachedReachableCells(from, mpLeft, Fight.self.cellsToIgnore)

		Position? bestPosition = null
		for (Cell cell : integer mp in reachableCells) {
			if (mp > mpLeft) continue  // Skip cells exceeding MP budget (cache may return superset)
			Position pos = MapPosition.evaluatePosition(cell, consequences)
			if (bestPosition == null || pos.score > bestPosition!.score) {
				bestPosition = pos
			}
		}

		if (bestPosition == null) {
			bestPosition = MapPosition.evaluatePosition(from, consequences)
		}

		Benchmark.stop("MP.findBest")
		return bestPosition!
	}

	/*
	 * Find the best position from an arbitrary reachable cell map.
	 * Like findBestPosition but takes a pre-computed map instead of computing one.
	 * Used by escape OTK to search the full movement envelope.
	 */
	static Position findBestPositionFromMap(Map<Cell, integer> reachableMap, Consequences? csq) {
		Benchmark.start("MP.findBestMap")
		Position? best = null
		for (Cell cell : integer mp in reachableMap) {
			Position pos = MapPosition.evaluatePosition(cell, csq)
			if (best == null || pos.score > best!.score) best = pos
		}
		if (best == null) best = MapPosition.evaluatePosition(Fight.self.cell, csq)
		Benchmark.stop("MP.findBestMap")
		return best!
	}

	/*
	 * Fast position score lookup for MCTS rollout.
	 * Returns best reachable position SCORE (not Position object).
	 * Uses precomputed grid when consequences don't alter danger.
	 * Lazy-evaluates cells outside precomputed range (rare edge cases).
	 *
	 * @param fromCell - current cell position
	 * @param mp - remaining movement points
	 * @param csq - consequences from action chain (may be null)
	 * @return best achievable position score
	 */
	static real findBestPositionScoreFast(Cell fromCell, integer mp, Consequences? csq) {
		// If consequences alter danger (kills, debuffs), fall back to full evaluation
		if (csq != null && csq!.isAlteringDanger) {
			return MapPosition.findBestPosition(fromCell, mp, csq).score
		}

		// Fast path: use precomputed _position cache with lazy evaluation fallback
		Map<Cell, integer> reachable = MapPath.getCachedReachableCells(fromCell, mp, Fight.self.cellsToIgnore)

		real best = -999999.0
		for (Cell cell : integer cost in reachable) {
			if (cost > mp) continue
			Position? pos = _position[cell]
			// Lazy evaluation for cells outside precomputed range
			if (pos == null) {
				pos = MapPosition.evaluatePosition(cell, null)
			}
			if (pos!.score > best) {
				best = pos!.score
			}
		}

		// Fallback to current cell if nothing found
		if (best == -999999.0) {
			Position? fromPos = _position[fromCell]
			if (fromPos == null) {
				fromPos = MapPosition.evaluatePosition(fromCell, null)
			}
			best = fromPos!.score
		}

		return best
	}

	/*
	 * Display position scores on the map (for debugging)
	 * Color: based on danger only (red = high danger, green = low danger)
	 * Text: positioningScore | danger
	 * Uses cached positions from evaluatePosition - cheap after findBestPosition runs
	 */
	static void showPosition(Cell from, integer mpleft, Consequences? consequences) {
		Benchmark.start("MP.showPos")
		Map<Cell, integer> reachableCells = MapPath.getCachedReachableCells(from, mpleft, Fight.self.cellsToIgnore)
		for (Cell c : integer d in reachableCells) {
			Position pos = MapPosition.evaluatePosition(c, consequences)
			// Color: based on position score (green = high/good, red = low/bad)
			integer scoreVal = round(pos.score)
			// Normalize score to 0-255 range (assuming score ranges roughly -500 to +100)
			integer green = ((scoreVal + 500) * 255 / 600) as integer
			if (green < 0) green = 0
			if (green > 255) green = 255
			mark(c.id, getColor(255 - green, green, 0))
			// Text: position score
			markText(c.id, scoreVal)
		}
		Benchmark.stop("MP.showPos")
	}
}
