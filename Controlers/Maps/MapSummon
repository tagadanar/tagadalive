/*
 * MapSummon - Intelligent summon cell selection based on offensive potential
 *
 * For each summon chip, computes the N best cells to summon a bulb by scoring
 * the bulb expected damage output on reachable targets.
 *
 * Currently supports: All bulb types (Lightning, Fire, Iced, Rocky, Puny, Healer, Metallic, Wizard, Savant, Tactician)
 *
 * Usage:
 *   // After init(), call to get best summon cells for lightning bulb
 *   MapSummon.refresh()
 *   Array<SummonCandidate> best = MapSummon.getBestCells(CHIP_LIGHTNING_BULB, 3)
 *   for (SummonCandidate c in best) {
 *       debug("Cell " + c.cell.id + " score=" + c.score + " target=" + c.target.name)
 *   }
 *
 * NOTE: Buff actions for bulbs are now generated dynamically by ComboBuilder
 * via MapAction.getPendingBuffActions() after a summon or resurrection is added to a combo.
 */

class MapSummon {

	// ═══════════════════════════════════════════════════════════════════════════
	// BULB PROFILES - Static data for each bulb type
	// ═══════════════════════════════════════════════════════════════════════════

	// Lightning Bulb profile
	// Stats: life 400-600, str 0-400, agi 0-100, mp 4-6, tp 6-10, snc 0-200
	static BulbProfile PROFILE_LIGHTNING = BulbProfile(
		Entity.BULB_LIGHTNING, CHIP_LIGHTNING_BULB,
		400, 600,   // life
		0, 400,     // str
		0, 100,     // agi
		4, 6,       // mp
		6, 10,      // tp
		0, 200,     // snc
		0, 0,       // wsd
		0, 0,       // mgc
		0, 0        // rst
	)

	// Fire Bulb profile
	// Stats: life 300-500, str 0-300, agi 0-100, mp 3-5, tp 4-9, wsd 0-200
	static BulbProfile PROFILE_FIRE = BulbProfile(
		Entity.BULB_FIRE, CHIP_FIRE_BULB,
		300, 500,   // life
		0, 300,     // str
		0, 100,     // agi
		3, 5,       // mp
		4, 9,       // tp
		0, 0,       // snc
		0, 200,     // wsd
		0, 0,       // mgc
		0, 0        // rst
	)

	// Iced Bulb profile
	// Stats: life 300-500, str 0-300, agi 0-100, mp 3-4, tp 5-8, snc 0-200
	static BulbProfile PROFILE_ICED = BulbProfile(
		Entity.BULB_ICED, CHIP_ICED_BULB,
		300, 500,   // life
		0, 300,     // str
		0, 100,     // agi
		3, 4,       // mp
		5, 8,       // tp
		0, 200,     // snc
		0, 0,       // wsd
		0, 0,       // mgc
		0, 0        // rst
	)

	// Rocky Bulb profile
	// Stats: life 400-600, str 0-200, agi 0-100, mp 2-3, tp 4-8, rst 0-200
	static BulbProfile PROFILE_ROCKY = BulbProfile(
		Entity.BULB_ROCKY, CHIP_ROCKY_BULB,
		400, 600,   // life
		0, 200,     // str
		0, 100,     // agi
		2, 3,       // mp
		4, 8,       // tp
		0, 0,       // snc
		0, 0,       // wsd
		0, 0,       // mgc
		0, 200      // rst
	)

	// Puny Bulb profile (defensive only - no offensive chips)
	// Stats: life 50-300, str 0-100, agi 0-100, mp 3-5, tp 4-7, snc 0-100, wsd 0-100, rst 0-100
	static BulbProfile PROFILE_PUNY = BulbProfile(
		Entity.BULB_PUNY, CHIP_PUNY_BULB,
		50, 300,    // life
		0, 100,     // str
		0, 100,     // agi
		3, 5,       // mp
		4, 7,       // tp
		0, 100,     // snc
		0, 100,     // wsd
		0, 0,       // mgc
		0, 100      // rst
	)

	// Healer Bulb profile (targets allies, not enemies)
	// Stats: life 300-400, str 0, agi 0-100, mp 3-6, tp 4-8, wsd 0-300
	static BulbProfile PROFILE_HEALER = BulbProfile(
		Entity.BULB_HEALER, CHIP_HEALER_BULB,
		300, 400,   // life
		0, 0,       // str
		0, 100,     // agi
		3, 6,       // mp
		4, 8,       // tp
		0, 0,       // snc
		0, 300,     // wsd
		0, 0,       // mgc
		0, 0        // rst
	)

	// Metallic Bulb profile (shields allies)
	// Stats: life 800-1100, str 0, agi 0-100, mp 1-2, tp 5-9, snc 0-200, rst 0-300
	static BulbProfile PROFILE_METALLIC = BulbProfile(
		Entity.BULB_METALLIC, CHIP_METALLIC_BULB,
		800, 1100,  // life
		0, 0,       // str
		0, 100,     // agi
		1, 2,       // mp
		5, 9,       // tp
		0, 200,     // snc
		0, 0,       // wsd
		0, 0,       // mgc
		0, 300      // rst
	)

	// Wizard Bulb profile (poison damage, MGC-based)
	// Stats: life 300-600, str 0, agi 0-100, mp 4-7, tp 5-8, mgc 0-240
	static BulbProfile PROFILE_WIZARD = BulbProfile(
		Entity.BULB_WIZARD, CHIP_WIZARD_BULB,
		300, 600,   // life
		0, 0,       // str
		0, 100,     // agi
		4, 7,       // mp
		5, 8,       // tp
		0, 0,       // snc
		0, 0,       // wsd
		0, 240,     // mgc
		0, 0        // rst
	)

	// Savant Bulb profile (defensive only - no offensive chips)
	// Stats: life 400-600, str 0, agi 0-200, mp 4-6, tp 6-8, snc 0-300
	static BulbProfile PROFILE_SAVANT = BulbProfile(
		Entity.BULB_SAVANT, CHIP_SAVANT_BULB,
		400, 600,   // life
		0, 0,       // str
		0, 200,     // agi
		4, 6,       // mp
		6, 8,       // tp
		0, 300,     // snc
		0, 0,       // wsd
		0, 0,       // mgc
		0, 0        // rst
	)

	// Tactician Bulb profile (defensive only - no offensive chips)
	// Stats: life 500-700, str 0, agi 0-200, mp 6, tp 6
	static BulbProfile PROFILE_TACTICIAN = BulbProfile(
		Entity.BULB_TACTICIAN, CHIP_TACTICIAN_BULB,
		500, 700,   // life
		0, 0,       // str
		0, 200,     // agi
		6, 6,       // mp (flat)
		6, 6,       // tp (flat)
		0, 0,       // snc
		0, 0,       // wsd
		0, 0,       // mgc
		0, 0        // rst
	)

	// Map chip ID -> profile for easy lookup
	static Map<integer, BulbProfile> PROFILES = [
		CHIP_LIGHTNING_BULB: PROFILE_LIGHTNING,
		CHIP_FIRE_BULB: PROFILE_FIRE,
		CHIP_ICED_BULB: PROFILE_ICED,
		CHIP_ROCKY_BULB: PROFILE_ROCKY,
		CHIP_PUNY_BULB: PROFILE_PUNY,
		CHIP_HEALER_BULB: PROFILE_HEALER,
		CHIP_METALLIC_BULB: PROFILE_METALLIC,
		CHIP_WIZARD_BULB: PROFILE_WIZARD,
		CHIP_SAVANT_BULB: PROFILE_SAVANT,
		CHIP_TACTICIAN_BULB: PROFILE_TACTICIAN
	]

	// Offensive chips per bulb type (for combo simulation)
	// First chip determines attack range for positioning!
	// Lightning: CHIP_LIGHTNING (main), CHIP_FLASH, CHIP_SHOCK
	// Fire: CHIP_METEORITE (main), CHIP_FLAME, CHIP_SPARK, CHIP_DEVIL_STRIKE
	// Iced: CHIP_STALACTITE (main), CHIP_ICEBERG, CHIP_ICE
	// Rocky: CHIP_ROCKFALL (main), CHIP_ROCK, CHIP_PEBBLE
	// Healer: CHIP_VACCINE (main), CHIP_DRIP, CHIP_CURE, CHIP_BANDAGE (targets allies!)
	// Metallic: CHIP_ARMOR (main), CHIP_SHIELD, CHIP_WALL (shields allies!)
	// Wizard: CHIP_TOXIN (main), CHIP_VENOM (poison, MGC-based)
	static Map<integer, Array<integer>> BULB_OFFENSIVE_CHIPS = [
		Entity.BULB_LIGHTNING: [CHIP_LIGHTNING, CHIP_FLASH, CHIP_SHOCK],
		Entity.BULB_FIRE: [CHIP_METEORITE, CHIP_FLAME, CHIP_SPARK, CHIP_DEVIL_STRIKE],
		Entity.BULB_ICED: [CHIP_STALACTITE, CHIP_ICEBERG, CHIP_ICE],
		Entity.BULB_ROCKY: [CHIP_ROCKFALL, CHIP_ROCK, CHIP_PEBBLE],
		// Entity.BULB_HEALER: [CHIP_VACCINE, CHIP_DRIP, CHIP_CURE, CHIP_BANDAGE],
		// Entity.BULB_METALLIC: [CHIP_ARMOR, CHIP_SHIELD, CHIP_WALL],
		// Entity.BULB_WIZARD: [CHIP_TOXIN, CHIP_VENOM]
	]

	// Target modes for bulb types
	static integer TARGET_MODE_ENEMY = 0       // Damage enemies (default)
	static integer TARGET_MODE_ALLY_HEAL = 1   // Heal allies
	static integer TARGET_MODE_ALLY_SHIELD = 2 // Shield allies

	static Map<integer, integer> BULB_TARGET_MODE = [
		Entity.BULB_HEALER: TARGET_MODE_ALLY_HEAL,
		Entity.BULB_METALLIC: TARGET_MODE_ALLY_SHIELD
	]

	// ═══════════════════════════════════════════════════════════════════════════
	// CACHED RESULTS - Populated by refresh()
	// ═══════════════════════════════════════════════════════════════════════════

	// Map: summonChip -> sorted Array<SummonCandidate>
	static Map<integer, Array<SummonCandidate>> _candidates = [:]

	// Map: summonChip -> (Cell -> SummonCandidate) for O(1) lookup
	static Map<integer, Map<Cell, SummonCandidate>> _candidateByCell = [:]

	// Operation counter for this module
	static integer _opsUsed = 0

	// ═══════════════════════════════════════════════════════════════════════════
	// PUBLIC API
	// ═══════════════════════════════════════════════════════════════════════════

	/*
	 * Refresh placement analysis for all available summon chips.
	 * Generates SummonCandidate list for cell selection.
	 * Buff selection is now handled dynamically by ComboBuilder after summon.
	 */
	static void refresh() {
		Benchmark.start("MapSummon")
		integer startOps = getOperations()
		_candidates = [:]
		_candidateByCell = [:]

		integer summonerLevel = Fight.self.level

		// Process each summon chip the player has
		for (Item item in Fight.self.items) {
			if (!item.isSummon) continue
			if (getCooldown(item.id, Fight.self.id) > 0) continue

			BulbProfile? profile = PROFILES[item.id]
			if (profile == null) {
				// Unsupported bulb type - skip silently for now
				continue
			}

			Array<SummonCandidate> candidates = MapSummon._evaluateSummonChip(
				item, profile!, summonerLevel
			)
			_candidates[item.id] = candidates

			// Build O(1) lookup map by cell
			Map<Cell, SummonCandidate> cellMap = [:]
			for (SummonCandidate c in candidates) {
				cellMap[c.cell] = c
			}
			_candidateByCell[item.id] = cellMap
		}

		_opsUsed = getOperations() - startOps
		Benchmark.stop("MapSummon")
	}

	/*
	 * Get the N best summon cells for a given summon chip.
	 * Must call refresh() first.
	 *
	 * @param chipId  The summon chip (e.g., CHIP_LIGHTNING_BULB)
	 * @param n       Max results to return
	 * @return Sorted array of SummonCandidate (best first), may be empty
	 */
	static Array<SummonCandidate> getBestCells(integer chipId, integer n) {
		Array<SummonCandidate>? candidates = _candidates[chipId]
		if (candidates == null) return []

		integer resultCount = min(n, count(candidates!))
		Array<SummonCandidate> result = []
		for (integer i = 0; i < resultCount; i++) {
			push(result, candidates![i])
		}
		return result
	}

	/*
	 * Get the single best cell for a summon chip, or null if none valid.
	 */
	static Cell? getBestCell(integer chipId) {
		Array<SummonCandidate> best = MapSummon.getBestCells(chipId, 1)
		return count(best) > 0 ? best[0].cell : null
	}

	/*
	 * Get ALL candidates for a summon chip (un-truncated).
	 * Used by MapAction for boss-fight candidate injection.
	 */
	static Array<SummonCandidate> getAllCandidates(integer chipId) {
		Array<SummonCandidate>? candidates = _candidates[chipId]
		if (candidates == null) return []
		return candidates!
	}

	/*
	 * Get the computed score for a summon at a specific cell.
	 * Score includes: damage * coefficient + kill bonus (if applicable) * distFactor
	 * Used by EffectHandlers.summon() to score summon actions.
	 *
	 * @param chipId     The summon chip ID
	 * @param targetCell The cell where bulb will be summoned
	 * @return Computed score, or 0 if not found
	 */
	static real getComputedScore(integer chipId, Cell targetCell) {
		Map<Cell, SummonCandidate>? cellMap = _candidateByCell[chipId]
		if (cellMap == null) return 0
		SummonCandidate? c = cellMap![targetCell]
		return c != null ? c!.score : 0
	}

	/*
	 * Get the target entity for a summon at a specific cell.
	 * Used by Consequences to create PendingBulb with accurate damage scoring.
	 */
	static Entity? getTargetForCell(integer chipId, Cell targetCell) {
		Map<Cell, SummonCandidate>? cellMap = _candidateByCell[chipId]
		if (cellMap == null) return null
		SummonCandidate? c = cellMap![targetCell]
		return c != null ? c!.target : null
	}

	/*
	 * Get the offensive chips for a bulb type.
	 * Used by Consequences to compute actual damage scores.
	 */
	static Array<Item> getOffensiveChips(integer bulbType) {
		Array<integer>? chipIds = BULB_OFFENSIVE_CHIPS[bulbType]
		if (chipIds == null) return []

		Array<Item> chips = []
		for (integer chipId in chipIds!) {
			Item? chip = Items.getItem(chipId)
			if (chip != null) push(chips, chip!)
		}
		return chips
	}

	/*
	 * Compute damage score for given damage and target.
	 * Used by Consequences.handlePendingBulbBuff for accurate scoring.
	 */
	static real computeDamageScore(real damage, Entity target) {
		real dmgCoef = Scoring.getDynamicCoef(target, Stats.HP, null)
		real score = (-damage) * dmgCoef  // -damage * -coef = positive
		if (damage >= target.life) {
			score += (-1) * dmgCoef * ScoringConfig.KILL_VALUE
		}
		return score
	}

	/*
	 * Calculate knapsack damage for a specific enemy target.
	 * @return Total damage achievable with bulb's chips and TP
	 */
	static real _calcKnapsackDamageForEnemy(BulbStats stats, Array<Item> chips, Entity enemy) {
		Array<BulbChipAction> actions = []
		for (Item chip in chips) {
			real dmg = BulbSimulator.calcChipDamage(chip, stats, enemy)
			if (dmg > 0) {
				push(actions, BulbChipAction(chip, chip.cost, dmg, chip.maxUse))
			}
		}
		if (count(actions) == 0) return 0
		return BulbSimulator.knapsackDamage(actions, stats.tp)
	}

	/*
	 * Debug output: show all computed placements
	 */
	static void debugAll() {
		debug("=== MapSummon Results (ops=" + _opsUsed + ") ===")
		for (integer chipId : Array<SummonCandidate> candidates in _candidates) {
			Item? item = Items.getItem(chipId)
			string chipName = item != null ? item!.name : ("chip#" + chipId)
			debug("  " + chipName + ": " + count(candidates) + " candidates")
			integer shown = 0
			for (SummonCandidate c in candidates) {
				debug("    " + c)
				shown++
				if (shown >= 5) {
					if (count(candidates) > 5) debug("    ... and " + (count(candidates) - 5) + " more")
					break
				}
			}
		}
		debug("=== End MapSummon ===")
	}

	// ═══════════════════════════════════════════════════════════════════════════
	// DEFENSIVE SUMMON SYSTEM
	// For bulbs without offensive potential (Puny, Savant, Tactician, or solo Healer/Metallic)
	// These spawn after final position, at farthest available cell
	// ═══════════════════════════════════════════════════════════════════════════

	/*
	 * Check if a summon chip should use the defensive (delayed) spawn system.
	 * True if:
	 * - No offensive chips defined for this bulb type, OR
	 * - Ally-targeting bulb (Healer/Metallic) with no other allies (solo fight)
	 */
	static boolean isDefensiveSummon(integer chipId) {
		BulbProfile? profile = PROFILES[chipId]
		if (profile == null) return false

		// Check if offensive chips are defined
		Array<integer>? chipIds = BULB_OFFENSIVE_CHIPS[profile!.bulbType]
		if (chipIds == null || count(chipIds!) == 0) {
			return true  // No offensive chips = defensive bulb
		}

		// Check if ally-targeting bulb in solo (no other allies)
		integer? modeVal = BULB_TARGET_MODE[profile!.bulbType]
		if (modeVal != null && modeVal! != TARGET_MODE_ENEMY) {
			// Count allies excluding self
			integer allyCount = 0
			for (Entity ally in Fight.getAlliesAlive()) {
				if (ally.id != Fight.self.id) allyCount++
			}
			if (allyCount == 0) return true  // Solo fight, ally-targeting bulb
		}

		return false
	}

	/*
	 * Find the farthest valid spawn cell from a given position within summon range.
	 * Used by Combo.play() for delayed defensive summons.
	 *
	 * @param summonItem The summon chip
	 * @param fromCell Position to cast from (leek's final position)
	 * @return Farthest empty cell within range, or null if none
	 */
	static Cell? getFarthestSpawnCell(Item summonItem, Cell fromCell) {
		Cell? bestCell = null
		integer bestDist = -1

		// Check all cells in summon range
		for (integer x = fromCell.x - summonItem.maxRange; x <= fromCell.x + summonItem.maxRange; x++) {
			for (integer y = fromCell.y - summonItem.maxRange; y <= fromCell.y + summonItem.maxRange; y++) {
				integer dist = abs(fromCell.x - x) + abs(fromCell.y - y)
				if (dist < summonItem.minRange || dist > summonItem.maxRange) continue

				Cell? cell = Board.cellsXY[x] != null ? Board.cellsXY[x]![y] : null
				if (cell == null) continue
				if (cell!.isWall) continue
				if (Board.entityCells[cell!] != null) continue  // Must be empty

				// Check LOS if required
				if (summonItem.needLOS && !lineOfSight(fromCell.id, cell!.id, [])) continue

				// Prefer farthest cell
				if (dist > bestDist) {
					bestDist = dist
					bestCell = cell
				}
			}
		}

		return bestCell
	}

	/*
	 * Find safe spawn cells for defensive summons or resurrection.
	 * Prioritizes low danger, then low MP cost.
	 * Only checks cells within chip range from reachable positions.
	 *
	 * @param item The summon/resurrection chip
	 * @param maxCandidates Maximum candidates to return
	 * @return Array<DefensiveCandidate> sorted by danger ASC, then mpCost ASC
	 */
	static Array<DefensiveCandidate> getDefensiveCandidates(Item item, integer maxCandidates) {
		Map<Cell, integer> reachable = Fight.self.reachableCells
		Cell selfCell = Fight.self.cell

		// Track best (lowest cost) fromCell for each spawnCell
		Map<integer, Cell> bestFromCell = [:]
		Map<integer, integer> bestCost = [:]
		Map<integer, Cell> spawnCellRefs = [:]

		// Check cells in range from current position (cost = 0)
		MapSummon._addTargetsInRange(item, selfCell, 0, bestFromCell, bestCost, spawnCellRefs)

		// Check cells in range from each reachable position
		for (Cell fromCell : integer cost in reachable) {
			MapSummon._addTargetsInRange(item, fromCell, cost, bestFromCell, bestCost, spawnCellRefs)
		}

		// Build candidates with danger scores
		Array<DefensiveCandidate> candidates = []
		for (integer cellId : Cell fromCell in bestFromCell) {
			Cell spawnCell = spawnCellRefs[cellId]!
			integer cost = bestCost[cellId]!

			Danger d = MapDanger.getCellDanger(spawnCell)
			real danger = d.dmg + d.psnDmg

			push(candidates, DefensiveCandidate(spawnCell, fromCell, cost, danger))
		}

		candidates = arraySort(candidates, (DefensiveCandidate a, DefensiveCandidate b) -> integer {
			if (a.danger < b.danger) return -1
			if (a.danger > b.danger) return 1
			return a.mpCost - b.mpCost
		}) as Array<DefensiveCandidate>

		integer n = min(maxCandidates, count(candidates))
		Array<DefensiveCandidate> result = []
		for (integer i = 0; i < n; i++) {
			push(result, candidates[i])
		}
		return result
	}

	/*
	 * Helper: add empty cells within item range from a position.
	 * Updates maps only if this fromCell has lower cost than existing.
	 */
	static void _addTargetsInRange(Item item, Cell fromCell, integer cost,
			Map<integer, Cell> bestFromCell, Map<integer, integer> bestCost, Map<integer, Cell> spawnCellRefs) {
		integer minR = item.minRange
		integer maxR = item.maxRange

		for (integer dx = -maxR; dx <= maxR; dx++) {
			for (integer dy = -maxR; dy <= maxR; dy++) {
				integer dist = abs(dx) + abs(dy)
				if (dist < minR || dist > maxR) continue

				integer tx = fromCell.x + dx
				integer ty = fromCell.y + dy
				Cell? targetCell = Board.cellsXY[tx] != null ? Board.cellsXY[tx]![ty] : null
				if (targetCell == null) continue
				if (targetCell!.isWall) continue
				if (Board.entityCells[targetCell!] != null) continue  // Must be empty

				// Check LOS if required
				if (item.needLOS && !lineOfSight(fromCell.id, targetCell!.id, [Fight.self.id])) continue

				integer cellId = targetCell!.id
				integer? existing = bestCost[cellId]
				if (existing == null || cost < existing!) {
					bestFromCell[cellId] = fromCell
					bestCost[cellId] = cost
					spawnCellRefs[cellId] = targetCell!
				}
			}
		}
	}

	/*
	 * Get the best resurrection candidate for the current dead target.
	 * Returns null if no 0-danger cell exists or resurrection not ready.
	 *
	 * Strict safety: only 0-danger cells (entity won't take damage).
	 * Among 0-danger cells, picks lowest MP cost (candidates sorted by danger ASC, mpCost ASC).
	 *
	 * @return PendingResurrect with best spawn cell, or null
	 */
	static PendingResurrect? getResurrectionCandidate() {
		if (!Fight.resurrectionReady) return null
		if (Fight.resurrectTargetId == null) return null
		if (Fight.resurrectionItem == null) return null

		integer deadId = Fight.resurrectTargetId!
		integer? originalMaxHP = getTotalLife(deadId)
		if (originalMaxHP == null || originalMaxHP! <= 0) return null

		Array<DefensiveCandidate> candidates = MapSummon.getDefensiveCandidates(Fight.resurrectionItem!, 10)

		for (DefensiveCandidate c in candidates) {
			if (c.danger <= 0) {
				return PendingResurrect(deadId, originalMaxHP!, c.spawnCell, c.fromCell)
			}
		}

		return null  // No 0-danger cell found
	}

	// Map bulb type to single letter for display
	static Map<integer, string> BULB_LETTERS = [
		Entity.BULB_LIGHTNING: "L",
		Entity.BULB_FIRE: "F",
		Entity.BULB_ICED: "I",
		Entity.BULB_ROCKY: "R",
		Entity.BULB_PUNY: "P",
		Entity.BULB_HEALER: "H",
		Entity.BULB_METALLIC: "M",
		Entity.BULB_WIZARD: "W",
		Entity.BULB_SAVANT: "S",
		Entity.BULB_TACTICIAN: "T"
	]

	/*
	 * Display summon cells on the map (for debugging)
	 * Color: orange = best cell per summon chip
	 * Text: bulb letter + score (e.g. "L:8905" for lightning)
	 */
	static void showSummonCells() {
		for (integer chipId : Array<SummonCandidate> candidates in _candidates) {
			if (count(candidates) == 0) continue

			SummonCandidate best = candidates[0]
			BulbProfile? profile = PROFILES[chipId]
			string? letterVal = profile != null ? BULB_LETTERS[profile!.bulbType] : null
			string letter = letterVal != null ? letterVal! : "?"
			mark(best.cell.id, getColor(255, 165, 0))
			markText(best.cell.id, letter + ":" + round(best.score))
		}
	}

	/*
	 * Display resurrection candidate on the map (for debugging)
	 * Color: magenta = spawn cell, cyan = cast from cell
	 */
	static void showResurrectionCandidate() {
		debug("RESU SHOW: ready=" + Fight.resurrectionReady + " targetId=" + Fight.resurrectTargetId)

		PendingResurrect? candidate = MapSummon.getResurrectionCandidate()
		if (candidate == null) {
			debug("RESU SHOW: no candidate found")
			return;
		}

		// Spawn cell - bright magenta
		mark(candidate!.spawnCell.id, getColor(255, 0, 255))
		markText(candidate!.spawnCell.id, "RESU:" + candidate!.entityId)

		// Cast from cell - cyan
		mark(candidate!.fromCell.id, getColor(0, 255, 255))
		markText(candidate!.fromCell.id, "FROM")

		debug("RESU SHOW: spawn=c" + candidate!.spawnCell.id + " from=c" + candidate!.fromCell.id + " hp=" + candidate!.currentHP + "/" + candidate!.newMaxHP)
	}

	// ═══════════════════════════════════════════════════════════════════════════
	// INTERNAL METHODS
	// ═══════════════════════════════════════════════════════════════════════════

	/*
	 * Get cells FROM which a bulb can attack a target cell with given chip.
	 * Uses chip's launchType to determine valid attack positions.
	 * Includes occupied cells since bulb doesn't exist yet.
	 */
	static Array<Cell> _getAttackCells(Cell targetCell, Item chip) {
		// Use Targets launchType handler with shouldReturnOccupiedCells=true
		if (Targets.launchType[chip.launchType] == null) {
			return []
		}
		return (Targets.launchType[chip.launchType]!)(chip, targetCell, [], true)
	}

	/*
	 * Get valid spawn cells within bulbMP walking distance of an attack cell.
	 * Uses actual pathfinding (not Manhattan distance).
	 * Only returns empty cells (required for summon).
	 */
	static Array<Cell> _getSpawnCellsFromAttack(Cell attackCell, integer bulbMP) {
		// Get all cells reachable from attackCell within bulbMP
		// (reverse logic: if bulb can walk FROM spawn TO attack,
		//  then attack is reachable FROM spawn, which means spawn is in this set)
		Map<Cell, integer> reachable = MapPath.getReachableCells([attackCell: 0], bulbMP, <>)

		Array<Cell> result = []
		for (Cell c : integer dist in reachable) {
			if (Board.entityCells[c] != null) continue  // Must be empty for summon
			push(result, c)
		}
		return result
	}

	/*
	 * Calculate knapsack healing for a specific ally target.
	 */
	static real _calcKnapsackHealForAlly(BulbStats stats, Array<Item> chips, Entity ally) {
		Array<BulbChipAction> actions = []
		for (Item chip in chips) {
			real heal = BulbSimulator.calcChipHeal(chip, stats, ally)
			if (heal > 0) {
				push(actions, BulbChipAction(chip, chip.cost, heal, chip.maxUse))
			}
		}
		if (count(actions) == 0) return 0
		return BulbSimulator.knapsackDamage(actions, stats.tp)  // reuse knapsack algo
	}

	/*
	 * Calculate knapsack shield value for a specific ally target.
	 * Scores each chip's shield effects using proper coefficients before knapsack.
	 */
	static real _calcKnapsackShieldForAlly(BulbStats stats, Array<Item> chips, Entity ally) {
		Array<BulbChipAction> actions = []

		// Get coefficients once
		real absCoef = Scoring.getDynamicCoef(ally, Stats.ABSSHIELD, null)
		real relCoef = Scoring.getDynamicCoef(ally, Stats.RELSHIELD, null)

		for (Item chip in chips) {
			real absShield = BulbSimulator.calcChipAbsShield(chip, stats, ally)
			real relShield = BulbSimulator.calcChipRelShield(chip, stats, ally)

			// Score = absValue * absCoef + relValue * relCoef
			real score = absShield * absCoef + relShield * relCoef
			if (score > 0) {
				push(actions, BulbChipAction(chip, chip.cost, score, chip.maxUse))
			}
		}
		if (count(actions) == 0) return 0
		return BulbSimulator.knapsackDamage(actions, stats.tp)  // reuse knapsack algo
	}

	/*
	 * Evaluate all valid summon cells using BACKWARD PATH algorithm:
	 * 1. For each enemy: find attack cells (where bulb can use main chip)
	 * 2. From each attack cell: walk back bulbMP to find spawn cells
	 * 3. All spawn cells for same target share the knapsack score
	 * 4. Keep best score per spawn cell
	 * 5. Among best-scored cells, prefer lowest leek MP cost
	 */
	static Array<SummonCandidate> _evaluateSummonChip(Item summonItem, BulbProfile profile, integer summonerLevel) {
		BulbStats stats = profile.computeStats(summonerLevel)

		// Get offensive chips for this bulb type
		Array<integer>? chipIds = BULB_OFFENSIVE_CHIPS[profile.bulbType]
		if (chipIds == null || count(chipIds!) == 0) return []

		// Load chip Items
		Array<Item> chips = []
		for (integer chipId in chipIds!) {
			Item? chip = Items.getItem(chipId)
			if (chip != null) push(chips, chip!)
		}
		if (count(chips) == 0) return []

		// Main chip (first in list) determines attack positions
		Item mainChip = chips[0]
		integer bulbMP = stats.mp
		integer bulbReach = bulbMP + mainChip.maxRange

		// Map: spawnCell.id -> (score, target, expectedValue)
		// We keep the best score per cell
		Map<integer, real> cellScores = [:]
		Map<integer, Entity> cellTargets = [:]
		Map<integer, real> cellDamages = [:]  // damage, heal, or shield value
		Map<integer, Cell> cellRefs = [:]  // id -> Cell reference

		// Determine target mode: enemy damage, ally heal, or ally shield
		integer? modeVal = BULB_TARGET_MODE[profile.bulbType]
		integer targetMode = modeVal != null ? modeVal! : TARGET_MODE_ENEMY
		boolean targetsAllies = targetMode != TARGET_MODE_ENEMY

		Map<integer, Entity> targets = targetsAllies
			? Fight.getAlliesAlive()
			: Fight.getEnemiesAlive()

		// Process each target (for-in on Map iterates values in LS4)
		for (Entity target in targets) {
			// Skip self for ally-targeting bulbs (defensive bulbs use separate self-cast system)
			if (targetsAllies && target.id == Fight.self.id) continue
			// Skip invincible enemies and Fennel puzzle entities
			if (!targetsAllies && target.isInvincible) continue
			if (!targetsAllies && BossFennel.shouldNotTarget(target)) continue

			// Calculate knapsack value based on mode
			real value = 0
			if (targetMode == TARGET_MODE_ENEMY) {
				value = MapSummon._calcKnapsackDamageForEnemy(stats, chips, target)
			} else if (targetMode == TARGET_MODE_ALLY_HEAL) {
				value = MapSummon._calcKnapsackHealForAlly(stats, chips, target)
			} else if (targetMode == TARGET_MODE_ALLY_SHIELD) {
				value = MapSummon._calcKnapsackShieldForAlly(stats, chips, target)
			}
			if (value <= 0) continue

			// Calculate score
			real score = 0
			real coef = Scoring.getDynamicCoef(target, Stats.HP, null)
			if (targetMode == TARGET_MODE_ALLY_SHIELD) {
				// Shield value is pre-scored in _calcKnapsackShieldForAlly
				score = value
			} else {
				score = targetsAllies
					? value * coef       // heal * positive ally coef = positive
					: (-value) * coef    // -damage * negative enemy coef = positive
			}

			// Add kill bonus for damage only
			if (targetMode == TARGET_MODE_ENEMY) {
				boolean isKill = value >= target.life
				if (isKill) {
					score += (-1) * coef * ScoringConfig.KILL_VALUE
				}
			}

			// Find attack cells: where bulb can hit target with main chip
			Array<Cell> attackCells = MapSummon._getAttackCells(target.cell, mainChip)
			if (count(attackCells) == 0) continue

			// Pick the attack cell closest to self (spawn cells will be nearer to leek's reachable area)
			Cell nearestAttack = attackCells[0]
			integer nearestDist = getCellDistance(nearestAttack.id, Fight.self.cell.id)
			for (Cell c in attackCells) {
				integer d = getCellDistance(c.id, Fight.self.cell.id)
				if (d < nearestDist) {
					nearestDist = d
					nearestAttack = c
				}
			}

			// Get spawn cells from nearest attack cell only
			Array<Cell> spawnCells = MapSummon._getSpawnCellsFromAttack(nearestAttack, bulbMP)

			for (Cell spawnCell in spawnCells) {
				integer cellId = spawnCell.id

				// Keep only if this is a better score
				real? existingScore = cellScores[cellId]
				if (existingScore != null && existingScore! >= score) continue

				cellScores[cellId] = score
				cellTargets[cellId] = target
				cellDamages[cellId] = value
				cellRefs[cellId] = spawnCell
			}
		}

		// Get leek reachable cells (where leek can move to cast summon)
		Map<Cell, integer> leekReachable = Fight.self.reachableCells

		// Find intersection: for each spawn cell, find best cast position
		Array<SummonCandidate> candidates = []

		for (integer cellId : real score in cellScores) {
			Cell spawnCell = cellRefs[cellId]!
			// Get cells from which leek can cast summon on this spawn cell
			Array<Cell> castCells = Targets.getCellsToUseItemOnCell(summonItem, spawnCell, [Fight.self.id])

			// Find best (lowest cost) reachable cast cell
			Cell? bestFrom = null
			integer bestCost = 9999
			for (Cell castCell in castCells) {
				integer? cost = leekReachable[castCell]
				if (cost != null && cost! < bestCost) {
					bestCost = cost!
					bestFrom = castCell
				}
			}

			if (bestFrom == null) continue

			Entity target = cellTargets[cellId]!
			real expectedDmg = cellDamages[cellId]!
			integer distToTarget = getCellDistance(spawnCell.id, target.cell.id)

			push(candidates, SummonCandidate(
				spawnCell, bestFrom!, score, target,
				expectedDmg, distToTarget, bulbReach
			))
		}

		// Boss cell bonus: prefer spawn cells closest to boss cell (shorter path = less blockage)
		integer? bossCell = BossPotiMalef.getResurrectionCell()
		if (bossCell != null) {
			for (SummonCandidate c in candidates) {
				integer distToBoss = getCellDistance(c.cell.id, bossCell!)
				if (distToBoss <= bulbMP) {
					c.score += 100000.0 + (bulbMP - distToBoss) * 1000.0
				}
			}
		}

		// Sort by score DESC, then leek MP cost ASC as tiebreaker
		candidates = arraySort(candidates, (SummonCandidate a, SummonCandidate b) -> integer {
			if (a.score > b.score + 1) return -1
			if (b.score > a.score + 1) return 1
			integer? costA = leekReachable[a.fromCell]
			integer? costB = leekReachable[b.fromCell]
			return (costA != null ? costA! : 0) - (costB != null ? costB! : 0)
		}) as Array<SummonCandidate>

		return candidates
	}

}
