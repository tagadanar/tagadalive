/*
 * MapSummon - Intelligent summon cell selection based on offensive potential
 *
 * For each summon chip, computes the N best cells to summon a bulb by scoring
 * the bulb's expected damage output on reachable targets.
 *
 * Currently supports: Lightning Bulb
 * TODO: Add other bulb types (fire, healer, iced, etc.)
 *
 * Usage:
 *   // After init(), call to get best summon cells for lightning bulb
 *   MapSummon.refresh()
 *   Array<SummonCandidate> best = MapSummon.getBestCells(CHIP_LIGHTNING_BULB, 3)
 *   for (SummonCandidate c in best) {
 *       debug("Cell " + c.cell.id + " score=" + c.score + " target=" + c.target.name)
 *   }
 */

class MapSummon {

	// Filter constants for _findBuffsForCell
	static integer BUFF_FILTER_OFFENSIVE = 1
	static integer BUFF_FILTER_DEFENSIVE = 2

	// ═══════════════════════════════════════════════════════════════════════════
	// BULB PROFILES - Static data for each bulb type
	// ═══════════════════════════════════════════════════════════════════════════

	// Lightning Bulb profile
	// Stats: life 400-600, str 0-400, agi 0-100, mp 4-6, snc 0-200, tp 6-10, mgc 0
	// Reference chip: CHIP_LIGHTNING
	static BulbProfile PROFILE_LIGHTNING = BulbProfile(
		Entity.BULB_LIGHTNING, CHIP_LIGHTNING_BULB, CHIP_LIGHTNING,
		400, 600,   // life
		0, 400,     // str
		0, 100,     // agi
		4, 6,       // mp
		0, 200,     // snc
		6, 10,      // tp
		0, 0        // mgc (lightning bulb uses STR, not MGC)
	)

	// Map chip ID -> profile for easy lookup
	static Map<integer, BulbProfile> PROFILES = [
		CHIP_LIGHTNING_BULB: PROFILE_LIGHTNING
	]

	// Offensive chips per bulb type (for combo simulation)
	// Lightning: CHIP_LIGHTNING (main), CHIP_FLASH (cheap), CHIP_SHOCK (medium)
	static Map<integer, Array<integer>> BULB_OFFENSIVE_CHIPS = [
		Entity.BULB_LIGHTNING: [CHIP_LIGHTNING, CHIP_FLASH, CHIP_SHOCK]
	]

	// ═══════════════════════════════════════════════════════════════════════════
	// CACHED RESULTS - Populated by refresh()
	// ═══════════════════════════════════════════════════════════════════════════

	// Map: summonChip -> sorted Array<SummonCandidate>
	static Map<integer, Array<SummonCandidate>> _candidates = [:]

	// Map: summonChip -> sorted Array<OffensivePlan>
	static Map<integer, Array<OffensivePlan>> _offensivePlans = [:]

	// Map: summonChip -> sorted Array<DefensivePlan>
	static Map<integer, Array<DefensivePlan>> _defensivePlans = [:]

	// Map: summonChip -> (Cell -> SummonCandidate) for O(1) lookup
	static Map<integer, Map<Cell, SummonCandidate>> _candidateByCell = [:]

	// Operation counter for this module
	static integer _opsUsed = 0

	// ═══════════════════════════════════════════════════════════════════════════
	// PUBLIC API
	// ═══════════════════════════════════════════════════════════════════════════

	/*
	 * Refresh placement analysis for all available summon chips.
	 * Generates both offensive plans (damage + buffs) and defensive plans (safe cell + survival buffs).
	 * Call after init() when Fight.self is available.
	 */
	static void refresh() {
		Benchmark.start("MapSummon")
		integer startOps = getOperations()
		_candidates = [:]
		_offensivePlans = [:]
		_defensivePlans = [:]
		_candidateByCell = [:]

		integer summonerLevel = Fight.self.level
		integer leekTP = Fight.self.tp
		Map<Cell, integer> leekReachable = Fight.self.reachableCells

		// Cache buff chips once for plan generation (unified cache)
		MapSummon._cacheBuffChips()

		// Process each summon chip the player has
		for (Item item in Fight.self.items) {
			if (!item.isSummon) continue
			if (getCooldown(item.id, Fight.self.id) > 0) continue

			BulbProfile? profile = PROFILES[item.id]
			if (profile == null) {
				// Unsupported bulb type - skip silently for now
				continue
			}

			Array<SummonCandidate> candidates = MapSummon._evaluateSummonChip(
				item, profile!, summonerLevel
			)
			_candidates[item.id] = candidates

			// Build O(1) lookup map by cell
			Map<Cell, SummonCandidate> cellMap = [:]
			for (SummonCandidate c in candidates) {
				cellMap[c.cell] = c
			}
			_candidateByCell[item.id] = cellMap

			BulbStats baseStats = profile!.computeStats(summonerLevel)
			integer availableTP = leekTP - item.cost

			// === OFFENSIVE PLANS ===
			// Generate plans for best candidate only (to limit operations)
			if (count(candidates) > 0) {
				Array<integer>? chipIds = BULB_OFFENSIVE_CHIPS[profile!.bulbType]
				Array<Item> chips = []
				if (chipIds != null) {
					for (integer chipId in chipIds!) {
						Item? chip = Items.getItem(chipId)
						if (chip != null) push(chips, chip!)
					}
				}

				Array<OffensivePlan> allPlans = []

				// Only process best candidate to limit operations
				SummonCandidate c = candidates[0]

				// Find buffs that can target this spawn cell
				// Use post-summon reachability (from where leek will be AFTER casting summon)
				integer summonMoveCost = leekReachable[c.fromCell] != null ? leekReachable[c.fromCell]! : 0
				integer remainingMP = Fight.self.mp - summonMoveCost
				Map<Cell, integer> postSummonReachable = MapPath.getReachableCells([c.fromCell: 0], remainingMP, [])
				Array<Buff> buffs = MapSummon._findBuffsForCell(c.cell, postSummonReachable, MapSummon.BUFF_FILTER_OFFENSIVE)

				// Generate offensive plan
				Array<OffensivePlan> plans = MapSummon._generateOffensivePlan(
					c, item, baseStats, chips, availableTP, buffs
				)
				for (OffensivePlan p in plans) {
					push(allPlans, p)
				}

				// Sort all plans by score DESC
				allPlans = arraySort(allPlans, (OffensivePlan a, OffensivePlan b) -> b.score - a.score) as Array<OffensivePlan>
				_offensivePlans[item.id] = allPlans
			}

			// === DEFENSIVE PLANS ===
			// Find safe cells (0-danger) and generate defensive plans
			Array<DefensivePlan> defPlans = MapSummon._generateDefensivePlan(
				item, baseStats, availableTP, leekReachable
			)
			if (count(defPlans) > 0) {
				_defensivePlans[item.id] = defPlans
			}
		}

		_opsUsed = getOperations() - startOps
		Benchmark.stop("MapSummon")
	}

	/*
	 * Get the N best summon cells for a given summon chip.
	 * Must call refresh() first.
	 *
	 * @param chipId  The summon chip (e.g., CHIP_LIGHTNING_BULB)
	 * @param n       Max results to return
	 * @return Sorted array of SummonCandidate (best first), may be empty
	 */
	static Array<SummonCandidate> getBestCells(integer chipId, integer n) {
		Array<SummonCandidate>? candidates = _candidates[chipId]
		if (candidates == null) return []

		integer resultCount = min(n, count(candidates!))
		Array<SummonCandidate> result = []
		for (integer i = 0; i < resultCount; i++) {
			push(result, candidates![i])
		}
		return result
	}

	/*
	 * Get the single best cell for a summon chip, or null if none valid.
	 */
	static Cell? getBestCell(integer chipId) {
		Array<SummonCandidate> best = MapSummon.getBestCells(chipId, 1)
		return count(best) > 0 ? best[0].cell : null
	}

	/*
	 * Get the N best OffensivePlans for a given summon chip.
	 * Plans include optional buffs to cast on the bulb after summoning.
	 * Must call refresh() first.
	 *
	 * @param chipId  The summon chip (e.g., CHIP_LIGHTNING_BULB)
	 * @param n       Max results to return
	 * @return Sorted array of OffensivePlan (best score first), may be empty
	 */
	static Array<OffensivePlan> getBestOffensivePlans(integer chipId, integer n) {
		Array<OffensivePlan>? plans = _offensivePlans[chipId]
		if (plans == null) return []

		integer resultCount = min(n, count(plans!))
		Array<OffensivePlan> result = []
		for (integer i = 0; i < resultCount; i++) {
			push(result, plans![i])
		}
		return result
	}

	/*
	 * Get the single best OffensivePlan for a summon chip, or null if none valid.
	 */
	static OffensivePlan? getBestOffensivePlan(integer chipId) {
		Array<OffensivePlan> best = MapSummon.getBestOffensivePlans(chipId, 1)
		return count(best) > 0 ? best[0] : null
	}

	/*
	 * Get the N best DefensivePlans for a given summon chip.
	 * Defensive plans prioritize safe cells (0-danger) and survival buffs.
	 * Must call refresh() first.
	 *
	 * @param chipId  The summon chip (e.g., CHIP_LIGHTNING_BULB)
	 * @param n       Max results to return
	 * @return Sorted array of DefensivePlan (best score first), may be empty
	 */
	static Array<DefensivePlan> getBestDefensivePlans(integer chipId, integer n) {
		Array<DefensivePlan>? plans = _defensivePlans[chipId]
		if (plans == null) return []

		integer resultCount = min(n, count(plans!))
		Array<DefensivePlan> result = []
		for (integer i = 0; i < resultCount; i++) {
			push(result, plans![i])
		}
		return result
	}

	/*
	 * Get the single best DefensivePlan for a summon chip, or null if none valid.
	 */
	static DefensivePlan? getBestDefensivePlan(integer chipId) {
		Array<DefensivePlan> best = MapSummon.getBestDefensivePlans(chipId, 1)
		return count(best) > 0 ? best[0] : null
	}

	/*
	 * Get the computed score for a summon at a specific cell.
	 * Score includes: damage * coefficient + kill bonus (if applicable) * distFactor
	 * Used by EffectHandlers.summon() to score summon actions.
	 *
	 * @param chipId     The summon chip ID
	 * @param targetCell The cell where bulb will be summoned
	 * @return Computed score, or 0 if not found
	 */
	static real getComputedScore(integer chipId, Cell targetCell) {
		Map<Cell, SummonCandidate>? cellMap = _candidateByCell[chipId]
		if (cellMap == null) return 0
		SummonCandidate? c = cellMap![targetCell]
		return c != null ? c!.score : 0
	}

	/*
	 * Get the target entity for a summon at a specific cell.
	 * Used by Consequences to create PendingBulb with accurate damage scoring.
	 */
	static Entity? getTargetForCell(integer chipId, Cell targetCell) {
		Map<Cell, SummonCandidate>? cellMap = _candidateByCell[chipId]
		if (cellMap == null) return null
		SummonCandidate? c = cellMap![targetCell]
		return c != null ? c!.target : null
	}

	/*
	 * Get the offensive chips for a bulb type.
	 * Used by Consequences to compute actual damage scores.
	 */
	static Array<Item> getOffensiveChips(integer bulbType) {
		Array<integer>? chipIds = BULB_OFFENSIVE_CHIPS[bulbType]
		if (chipIds == null) return []

		Array<Item> chips = []
		for (integer chipId in chipIds!) {
			Item? chip = Items.getItem(chipId)
			if (chip != null) push(chips, chip!)
		}
		return chips
	}

	/*
	 * Compute damage score for given damage and target.
	 * Used by Consequences.handlePendingBulbBuff for accurate scoring.
	 */
	static real computeDamageScore(real damage, Entity target) {
		real dmgCoef = Scoring.getDynamicCoef(target, Stats.HP, null)
		real score = (-damage) * dmgCoef  // -damage * -coef = positive
		if (damage >= target.life) {
			score += (-1) * dmgCoef * ScoringConfig.KILL_VALUE
		}
		return score
	}

	/*
	 * Debug output: show all computed placements and plans
	 */
	static void debugAll() {
		debug("=== MapSummon Results (ops=" + _opsUsed + ") ===")
		for (integer chipId : Array<SummonCandidate> candidates in _candidates) {
			Item? item = Items.getItem(chipId)
			string chipName = item != null ? item!.name : ("chip#" + chipId)
			debug("  " + chipName + ": " + count(candidates) + " candidates")
			integer shown = 0
			for (SummonCandidate c in candidates) {
				debug("    " + c)
				shown++
				if (shown >= 5) {
					if (count(candidates) > 5) debug("    ... and " + (count(candidates) - 5) + " more")
					break
				}
			}

			// Show offensive plans
			Array<OffensivePlan>? plans = _offensivePlans[chipId]
			if (plans != null && count(plans!) > 0) {
				debug("  Offensive Plans: " + count(plans!))
				shown = 0
				for (OffensivePlan p in plans!) {
					debug("    " + p)
					shown++
					if (shown >= 3) {
						if (count(plans!) > 3) debug("    ... and " + (count(plans!) - 3) + " more plans")
						break
					}
				}
			}

			// Show defensive plans
			Array<DefensivePlan>? defPlans = _defensivePlans[chipId]
			if (defPlans != null && count(defPlans!) > 0) {
				debug("  Defensive Plans: " + count(defPlans!))
				for (DefensivePlan p in defPlans!) {
					debug("    " + p)
				}
			}
		}
		debug("=== End MapSummon ===")
	}

	/*
	 * Display summon cells on the map (for debugging)
	 * Color: orange = summon cell with no reachable enemy
	 *        red (low) to green (high) gradient = has candidates (by score)
	 *        blue = best cell
	 * Text: rounded score for candidates, "X" for no-reach cells
	 */
	static void showSummonCells() {
		for (integer chipId : Array<SummonCandidate> candidates in _candidates) {
			if (count(candidates) == 0) continue

			// Find max score for gradient
			real maxScore = 1.0
			for (SummonCandidate c in candidates) {
				if (c.score > maxScore) maxScore = c.score
			}

			// Mark candidate cells
			boolean first = true
			for (SummonCandidate c in candidates) {
				if (first) {
					// Best cell = blue
					mark(c.cell.id, getColor(0, 100, 255))
					markText(c.cell.id, round(c.score) + "")
					first = false
				} else {
					// Score gradient: red (low) to green (high)
					integer green = ((c.score * 255) / maxScore) as integer
					integer red = 255 - green
					mark(c.cell.id, getColor(red, green, 0))
					markText(c.cell.id, round(c.score) + "")
				}
			}
		}
	}

	// ═══════════════════════════════════════════════════════════════════════════
	// INTERNAL METHODS
	// ═══════════════════════════════════════════════════════════════════════════

	/*
	 * Get cells FROM which a bulb can attack a target cell with given chip.
	 * Uses chip's launchType to determine valid attack positions.
	 * Includes occupied cells since bulb doesn't exist yet.
	 */
	static Array<Cell> _getAttackCells(Cell targetCell, Item chip) {
		// Use Targets launchType handler with shouldReturnOccupiedCells=true
		if (Targets.launchType[chip.launchType] == null) {
			return []
		}
		return (Targets.launchType[chip.launchType]!)(chip, targetCell, [], true)
	}

	/*
	 * Get valid spawn cells within bulbMP walking distance of an attack cell.
	 * Uses actual pathfinding (not Manhattan distance).
	 * Only returns empty cells (required for summon).
	 */
	static Array<Cell> _getSpawnCellsFromAttack(Cell attackCell, integer bulbMP) {
		// Get all cells reachable from attackCell within bulbMP
		// (reverse logic: if bulb can walk FROM spawn TO attack,
		//  then attack is reachable FROM spawn, which means spawn is in this set)
		Map<Cell, integer> reachable = MapPath.getReachableCells([attackCell: 0], bulbMP, [])

		Array<Cell> result = []
		for (Cell c : integer dist in reachable) {
			if (Board.entityCells[c] != null) continue  // Must be empty for summon
			push(result, c)
		}
		return result
	}

	/*
	 * Calculate knapsack damage for a specific enemy target.
	 * @return Total damage achievable with bulb's chips and TP
	 */
	static real _calcKnapsackDamageForEnemy(BulbStats stats, Array<Item> chips, Entity enemy) {
		Array<BulbChipAction> actions = []
		for (Item chip in chips) {
			real dmg = BulbSimulator.calcChipDamage(chip, stats, enemy)
			if (dmg > 0) {
				push(actions, BulbChipAction(chip, chip.cost, dmg, chip.maxUse))
			}
		}
		if (count(actions) == 0) return 0
		return BulbSimulator.knapsackDamage(actions, stats.tp)
	}

	/*
	 * Evaluate all valid summon cells using BACKWARD PATH algorithm:
	 * 1. For each enemy: find attack cells (where bulb can use main chip)
	 * 2. From each attack cell: walk back bulbMP to find spawn cells
	 * 3. All spawn cells for same target share the knapsack score
	 * 4. Keep best score per spawn cell
	 * 5. Among best-scored cells, prefer lowest leek MP cost
	 */
	static Array<SummonCandidate> _evaluateSummonChip(Item summonItem, BulbProfile profile, integer summonerLevel) {
		BulbStats stats = profile.computeStats(summonerLevel)

		// Get offensive chips for this bulb type
		Array<integer>? chipIds = BULB_OFFENSIVE_CHIPS[profile.bulbType]
		if (chipIds == null || count(chipIds!) == 0) {
			debugW("MapSummon: no offensive chips defined for bulb type: " + profile.bulbType)
			return []
		}

		// Load chip Items
		Array<Item> chips = []
		for (integer chipId in chipIds!) {
			Item? chip = Items.getItem(chipId)
			if (chip != null) push(chips, chip!)
		}
		if (count(chips) == 0) return []

		// Main chip (first in list) determines attack positions
		Item mainChip = chips[0]
		integer bulbMP = stats.mp
		integer bulbReach = bulbMP + mainChip.maxRange

		// Map: spawnCell.id -> (score, target, expectedDmg)
		// We keep the best score per cell
		Map<integer, real> cellScores = [:]
		Map<integer, Entity> cellTargets = [:]
		Map<integer, real> cellDamages = [:]
		Map<integer, Cell> cellRefs = [:]  // id -> Cell reference

		// Process each enemy
		for (Entity enemy in Fight.getEnemiesAlive()) {
			if (enemy.isInvincible) continue

			// Calculate knapsack damage for this enemy (same for all spawn cells)
			real knapsackDmg = MapSummon._calcKnapsackDamageForEnemy(stats, chips, enemy)
			if (knapsackDmg <= 0) continue

			// Calculate score for this damage
			real dmgCoef = Scoring.getDynamicCoef(enemy, Stats.HP, null)
			real score = (-knapsackDmg) * dmgCoef  // -damage * -coef = positive

			// Add kill bonus if applicable
			boolean isKill = knapsackDmg >= enemy.life
			if (isKill) {
				score += (-1) * dmgCoef * ScoringConfig.KILL_VALUE
			}

			// Find attack cells: where bulb can hit enemy with main chip
			Array<Cell> attackCells = MapSummon._getAttackCells(enemy.cell, mainChip)
			if (count(attackCells) == 0) continue

			// Pick the attack cell closest to self (spawn cells will be nearer to leek's reachable area)
			Cell nearestAttack = attackCells[0]
			integer nearestDist = getCellDistance(nearestAttack.id, Fight.self.cell.id)
			for (Cell c in attackCells) {
				integer d = getCellDistance(c.id, Fight.self.cell.id)
				if (d < nearestDist) {
					nearestDist = d
					nearestAttack = c
				}
			}

			// Get spawn cells from nearest attack cell only
			Array<Cell> spawnCells = MapSummon._getSpawnCellsFromAttack(nearestAttack, bulbMP)

			for (Cell spawnCell in spawnCells) {
				integer cellId = spawnCell.id

				// Keep only if this is a better score
				real? existingScore = cellScores[cellId]
				if (existingScore != null && existingScore! >= score) continue

				cellScores[cellId] = score
				cellTargets[cellId] = enemy
				cellDamages[cellId] = knapsackDmg
				cellRefs[cellId] = spawnCell
			}
		}

		// Get leek reachable cells (where leek can move to cast summon)
		Map<Cell, integer> leekReachable = Fight.self.reachableCells

		// Find intersection: for each spawn cell, find best cast position
		Array<SummonCandidate> candidates = []

		for (integer cellId : real score in cellScores) {
			Cell spawnCell = cellRefs[cellId]!
			// Get cells from which leek can cast summon on this spawn cell
			Array<Cell> castCells = Targets.getCellsToUseItemOnCell(summonItem, spawnCell, [Fight.self.id])

			// Find best (lowest cost) reachable cast cell
			Cell? bestFrom = null
			integer bestCost = 9999
			for (Cell castCell in castCells) {
				integer? cost = leekReachable[castCell]
				if (cost != null && cost! < bestCost) {
					bestCost = cost!
					bestFrom = castCell
				}
			}

			if (bestFrom == null) continue

			Entity target = cellTargets[cellId]!
			real expectedDmg = cellDamages[cellId]!
			integer distToTarget = getCellDistance(spawnCell.id, target.cell.id)

			push(candidates, SummonCandidate(
				spawnCell, bestFrom!, score, target,
				expectedDmg, distToTarget, bulbReach
			))
		}

		// Sort by leek MP cost ASC
		candidates = arraySort(candidates, (SummonCandidate a, SummonCandidate b) -> integer {
			integer? costA = leekReachable[a.fromCell]
			integer? costB = leekReachable[b.fromCell]
			return (costA != null ? costA! : 0) - (costB != null ? costB! : 0)
		}) as Array<SummonCandidate>

		return candidates
	}

	// ═══════════════════════════════════════════════════════════════════════════
	// UNIFIED BUFF CACHE - Single pass for all buff stats
	// ═══════════════════════════════════════════════════════════════════════════

	static Array<Item> _buffChips = []
	// Offensive stats
	static Map<integer, integer> _buffStr = [:]   // chipId -> strBoost
	static Map<integer, integer> _buffAgi = [:]   // chipId -> agiBoost
	static Map<integer, integer> _buffTp = [:]    // chipId -> tpBoost
	static Map<integer, integer> _buffMp = [:]    // chipId -> mpBoost
	static Map<integer, integer> _buffMgc = [:]   // chipId -> mgcBoost
	// Defensive stats
	static Map<integer, integer> _buffAbsShield = [:]  // chipId -> absShield
	static Map<integer, integer> _buffRelShield = [:]  // chipId -> relShield %
	static Map<integer, integer> _buffResistance = [:] // chipId -> resistance
	static Map<integer, integer> _buffLife = [:]       // chipId -> lifeBoost

	/*
	 * Pre-compute all buff effects in a single pass (called once per refresh).
	 * Populates both offensive (STR, AGI, TP, MP, MGC) and defensive (shields, resistance, life) stats.
	 */
	static void _cacheBuffChips() {
		_buffChips = []
		_buffStr = [:]
		_buffAgi = [:]
		_buffTp = [:]
		_buffMp = [:]
		_buffMgc = [:]
		_buffAbsShield = [:]
		_buffRelShield = [:]
		_buffResistance = [:]
		_buffLife = [:]

		integer snc = Fight.self.snc  // Caster's science for scaling
		integer rst = Fight.self.rst  // Caster's resistance for shield scaling

		for (Item chip in Fight.self.items) {
			if (chip.isWeap) continue
			if (getCooldown(chip.id, Fight.self.id) > 0) continue

			// Offensive
			integer strBoost = 0
			integer agiBoost = 0
			integer tpBoost = 0
			integer mpBoost = 0
			integer mgcBoost = 0
			// Defensive
			integer absShield = 0
			integer relShield = 0
			integer resistance = 0
			integer lifeBoost = 0

			for (ItemEffect effect in chip.effects) {
				// Offensive effects
				if (effect.type == EFFECT_BUFF_STRENGTH) {
					strBoost += EffectCalc.scaledBuff(effect.avg, snc, 1.0)
				} else if (effect.type == EFFECT_RAW_BUFF_STRENGTH) {
					strBoost += EffectCalc.rawBuff(effect.avg, 1.0)
				} else if (effect.type == EFFECT_BUFF_AGILITY) {
					agiBoost += EffectCalc.scaledBuff(effect.avg, snc, 1.0)
				} else if (effect.type == EFFECT_RAW_BUFF_AGILITY) {
					agiBoost += EffectCalc.rawBuff(effect.avg, 1.0)
				} else if (effect.type == EFFECT_BUFF_TP) {
					tpBoost += EffectCalc.scaledBuff(effect.avg, snc, 1.0)
				} else if (effect.type == EFFECT_RAW_BUFF_TP) {
					tpBoost += EffectCalc.rawBuff(effect.avg, 1.0)
				} else if (effect.type == EFFECT_BUFF_MP) {
					mpBoost += EffectCalc.scaledBuff(effect.avg, snc, 1.0)
				} else if (effect.type == EFFECT_RAW_BUFF_MP) {
					mpBoost += EffectCalc.rawBuff(effect.avg, 1.0)
				} else if (effect.type == EFFECT_RAW_BUFF_MAGIC) {
					mgcBoost += EffectCalc.rawBuff(effect.avg, 1.0)
				}
				// Defensive effects
				else if (effect.type == EFFECT_ABSOLUTE_SHIELD) {
					absShield += EffectCalc.scaledShield(effect.avg, rst, 1.0)
				} else if (effect.type == EFFECT_RELATIVE_SHIELD) {
					relShield += effect.avg as integer
				} else if (effect.type == EFFECT_BUFF_RESISTANCE) {
					resistance += EffectCalc.scaledBuff(effect.avg, snc, 1.0)
				} else if (effect.type == EFFECT_RAW_BUFF_RESISTANCE) {
					resistance += EffectCalc.rawBuff(effect.avg, 1.0)
				} else if (effect.type == EFFECT_BOOST_MAX_LIFE) {
					lifeBoost += effect.avg as integer
				}
			}

			// Skip chips with no relevant buffs
			boolean hasOffensive = strBoost > 0 || agiBoost > 0 || tpBoost > 0 || mpBoost > 0 || mgcBoost > 0
			boolean hasDefensive = absShield > 0 || relShield > 0 || resistance > 0 || lifeBoost > 0
			if (!hasOffensive && !hasDefensive) continue

			push(_buffChips, chip)
			_buffStr[chip.id] = strBoost
			_buffAgi[chip.id] = agiBoost
			_buffTp[chip.id] = tpBoost
			_buffMp[chip.id] = mpBoost
			_buffMgc[chip.id] = mgcBoost
			_buffAbsShield[chip.id] = absShield
			_buffRelShield[chip.id] = relShield
			_buffResistance[chip.id] = resistance
			_buffLife[chip.id] = lifeBoost
		}
	}

	/*
	 * Find buff chips that can target a spawn cell.
	 * @param filter MapSummon.BUFF_FILTER_OFFENSIVE or MapSummon.BUFF_FILTER_DEFENSIVE
	 */
	static Array<Buff> _findBuffsForCell(Cell spawnCell, Map<Cell, integer> leekReachable, integer filter) {
		Array<Buff> result = []

		for (Item chip in _buffChips) {
			// Check filter
			integer strBoost = _buffStr[chip.id]!
			integer agiBoost = _buffAgi[chip.id]!
			integer tpBoost = _buffTp[chip.id]!
			integer mpBoost = _buffMp[chip.id]!
			integer mgcBoost = _buffMgc[chip.id]!
			integer absShield = _buffAbsShield[chip.id]!
			integer relShield = _buffRelShield[chip.id]!
			integer resistance = _buffResistance[chip.id]!
			integer lifeBoost = _buffLife[chip.id]!

			boolean isOffensive = strBoost > 0 || agiBoost > 0 || tpBoost > 0 || mpBoost > 0 || mgcBoost > 0
			boolean isDefensive = absShield > 0 || relShield > 0 || resistance > 0 || lifeBoost > 0 || tpBoost > 0

			if (filter == MapSummon.BUFF_FILTER_OFFENSIVE && !isOffensive) continue
			if (filter == MapSummon.BUFF_FILTER_DEFENSIVE && !isDefensive) continue

			// Use getTargetableCells which INCLUDES occupied cells
			Array<Cell> castCells = Targets.getTargetableCells(chip, spawnCell, [Fight.self.id])

			Cell? bestFrom = null
			integer bestCost = 9999
			for (Cell castCell in castCells) {
				integer? cost = leekReachable[castCell]
				if (cost != null && cost! < bestCost) {
					bestCost = cost!
					bestFrom = castCell
				}
			}

			if (bestFrom == null) continue

			push(result, Buff(
				chip, bestFrom!, chip.cost,
				strBoost, agiBoost, tpBoost, mpBoost, mgcBoost,
				absShield, relShield, resistance, lifeBoost
			))
		}

		return result
	}

	/*
	 * Generate a single OffensivePlan for a candidate using Combo-based approach.
	 * Attempts to add buffs if available; returns summon-only combo if no buffs possible.
	 *
	 * @param candidate    Base summon candidate
	 * @param summonChip   The summon chip
	 * @param baseStats    Unbuffed bulb stats
	 * @param chips        Bulb's offensive chips
	 * @param availableTP  TP remaining after summon cost
	 * @param buffs        Available buff options (may be empty)
	 * @return Array with single OffensivePlan (with or without buffs)
	 */
	static Array<OffensivePlan> _generateOffensivePlan(
		SummonCandidate candidate, Item summonChip, BulbStats baseStats,
		Array<Item> chips, integer availableTP, Array<Buff> buffs
	) {
		Array<OffensivePlan> plans = []

		// === Create summon action ===
		// Consequences will register pendingBulb and score base damage
		Action summonAction = Action(summonChip, candidate.fromCell, candidate.cell)

		// Build combo: summon + any available buffs
		Combo combo = Combo()
		boolean summonAdded = combo.add(summonAction)

		if (!summonAdded) {
			// Summon didn't improve score (shouldn't happen, but handle gracefully)
			return plans
		}

		// Try to add buffs if we have TP and buff chips available
		Array<Buff> selectedBuffs = []
		if (count(buffs) > 0 && availableTP > 0) {
			// Score each buff using Consequences (same scoring as ComboExplorer)
			Consequences baseCSQ = combo.getCurrentConsequences()
			real baseScore = baseCSQ.score
			Map<Buff, real> buffEfficiency = [:]

			for (Buff buff in buffs) {
				// Clone consequences and evaluate buff action in one step
				Action buffAction = Action(buff.chip, buff.fromCell, candidate.cell)
				Consequences csq = Consequences(buffAction, baseCSQ)

				real scoreDelta = csq.score - baseScore
				buffEfficiency[buff] = scoreDelta / buff.cost
			}

			// Sort buffs by efficiency (score delta / cost) - same principle as ComboExplorer
			buffs = arraySort(buffs, (Buff a, Buff b) -> real {
				return buffEfficiency[b]! - buffEfficiency[a]!
			}) as Array<Buff>

			integer usedTP = 0
			Map<Item, integer> usesThisTurn = [:]

			for (Buff buff in buffs) {
				if (usedTP + buff.cost > availableTP) continue

				// Create buff action targeting spawn cell
				Action buffAction = Action(buff.chip, buff.fromCell, candidate.cell)

				// Use ComboBuilder.tryAddAction() for validation
				boolean added = ComboBuilder.tryAddAction(combo, buffAction, usesThisTurn, 0)

				if (added) {
					push(selectedBuffs, buff)
					usedTP += buff.cost
				}
			}
		}

		// Find best final position (adds position score to combo)
		Consequences csq = combo.getCurrentConsequences()
		Position pos = MapPosition.findBestPosition(csq.currentCell, csq.currentMP, csq)
		combo.addFinalPosition(pos)

		// Compute final stats and expected damage
		BulbStats finalStats = baseStats.withBuffs(selectedBuffs)
		real finalDmg = count(selectedBuffs) > 0
			? MapSummon._calcKnapsackDamageForEnemy(finalStats, chips, candidate.target)
			: candidate.expectedDmg

		// combo.getScore() includes: summon + buff deltas (if any) + position
		real finalScore = combo.getScore()

		integer totalTP = summonChip.cost
		for (Buff buff in selectedBuffs) {
			totalTP += buff.cost
		}

		OffensivePlan plan = OffensivePlan(
			candidate.cell, candidate.fromCell, summonChip, selectedBuffs,
			totalTP, finalScore, candidate.target, finalDmg, finalStats, combo
		)
		push(plans, plan)

		return plans
	}

	/*
	 * Generate defensive plans: find lowest-danger cells and add survival buffs.
	 * Prefers 0-danger cells, but falls back to the lowest available danger.
	 * Returns a single plan with the safest cell and available defensive buffs.
	 *
	 * @param summonChip    The summon chip
	 * @param baseStats     Base bulb stats (for life calculation)
	 * @param availableTP   TP remaining after summon cost
	 * @param leekReachable Cells the leek can reach
	 * @return Array with single DefensivePlan (may be empty if no reachable cells)
	 */
	static Array<DefensivePlan> _generateDefensivePlan(
		Item summonChip, BulbStats baseStats, integer availableTP, Map<Cell, integer> leekReachable
	) {
		Array<DefensivePlan> plans = []

		// Find candidate cells to summon on, ranked by danger (lowest first)
		// A cell is valid if: empty and leek can cast summon on it
		Array<Cell> candidateCells = []
		Map<Cell, Cell> cellFromCell = [:]    // spawnCell -> castFromCell
		Map<Cell, integer> cellCost = [:]     // spawnCell -> MP cost to reach cast cell
		Map<Cell, real> cellDangerVal = [:]   // spawnCell -> total danger value

		for (Cell cell in Board.cells) {
			if (Board.entityCells[cell] != null) continue  // Must be empty

			// Get danger value (lower is better, 0 = safe)
			Danger cellDanger = MapDanger.getCellDanger(cell)
			real dangerVal = cellDanger.dmg + cellDanger.psnDmg

			// Find where leek can cast summon from
			Array<Cell> castCells = Targets.getCellsToUseItemOnCell(summonChip, cell, [Fight.self.id])

			Cell? bestFrom = null
			integer bestCost = 9999
			for (Cell castCell in castCells) {
				integer? cost = leekReachable[castCell]
				if (cost != null && cost! < bestCost) {
					bestCost = cost!
					bestFrom = castCell
				}
			}

			if (bestFrom == null) continue

			push(candidateCells, cell)
			cellFromCell[cell] = bestFrom!
			cellCost[cell] = bestCost
			cellDangerVal[cell] = dangerVal
		}

		if (count(candidateCells) == 0) return plans

		// Sort by danger first (ascending), then by MP cost (ascending)
		candidateCells = arraySort(candidateCells, (Cell a, Cell b) -> integer {
			real dangerDiff = cellDangerVal[a]! - cellDangerVal[b]!
			if (dangerDiff != 0) return dangerDiff < 0 ? -1 : 1
			return cellCost[a]! - cellCost[b]!
		}) as Array<Cell>

		// Use the safest (lowest danger) cell
		Cell spawnCell = candidateCells[0]
		Cell fromCell = cellFromCell[spawnCell]!
		integer dangerValue = round(cellDangerVal[spawnCell]!)

		// Create summon action
		Action summonAction = Action(summonChip, fromCell, spawnCell)

		// Build combo: summon + defensive buffs
		Combo combo = Combo()
		boolean summonAdded = combo.add(summonAction)

		if (!summonAdded) {
			// Summon didn't work (shouldn't happen for defensive, but handle gracefully)
			return plans
		}

		// Find defensive buffs that can target this spawn cell
		integer summonMoveCost = cellCost[spawnCell]!
		integer remainingMP = Fight.self.mp - summonMoveCost
		Map<Cell, integer> postSummonReachable = MapPath.getReachableCells([fromCell: 0], remainingMP, [])
		Array<Buff> availableBuffs = MapSummon._findBuffsForCell(spawnCell, postSummonReachable, MapSummon.BUFF_FILTER_DEFENSIVE)

		// Try to add defensive buffs
		Array<Buff> selectedBuffs = []
		if (count(availableBuffs) > 0 && availableTP > 0) {
			// Score each buff using Consequences (same scoring as ComboExplorer)
			Consequences baseCSQ = combo.getCurrentConsequences()
			real baseScore = baseCSQ.score
			Map<Buff, real> buffEfficiency = [:]

			for (Buff buff in availableBuffs) {
				// Clone consequences and evaluate buff action in one step
				Action buffAction = Action(buff.chip, buff.fromCell, spawnCell)
				Consequences csq = Consequences(buffAction, baseCSQ)

				real scoreDelta = csq.score - baseScore
				buffEfficiency[buff] = scoreDelta / buff.cost
			}

			// Sort buffs by efficiency (score delta / cost) - same principle as ComboExplorer
			availableBuffs = arraySort(availableBuffs, (Buff a, Buff b) -> real {
				return buffEfficiency[b]! - buffEfficiency[a]!
			}) as Array<Buff>

			integer usedTP = 0
			Map<Item, integer> usesThisTurn = [:]

			for (Buff buff in availableBuffs) {
				if (usedTP + buff.cost > availableTP) continue

				// Create buff action targeting spawn cell
				Action buffAction = Action(buff.chip, buff.fromCell, spawnCell)

				// Use ComboBuilder.tryAddAction() for validation
				boolean added = ComboBuilder.tryAddAction(combo, buffAction, usesThisTurn, 0)

				if (added) {
					push(selectedBuffs, buff)
					usedTP += buff.cost
				}
			}
		}

		// Find best final position
		Consequences csq = combo.getCurrentConsequences()
		Position pos = MapPosition.findBestPosition(csq.currentCell, csq.currentMP, csq)
		combo.addFinalPosition(pos)

		// Calculate total TP cost
		integer totalTP = summonChip.cost
		for (Buff buff in selectedBuffs) {
			totalTP += buff.cost
		}

		// Score based on bulb survival value (life + shields)
		real score = combo.getScore()

		DefensivePlan plan = DefensivePlan(
			spawnCell, fromCell, summonChip, selectedBuffs,
			totalTP, score, dangerValue, combo
		)
		push(plans, plan)

		return plans
	}

}
