/*
 * MapTactical - Intelligent tactical chip selection
 *
 * Handles tactical chips that affect positioning or game state in ways
 * beyond simple damage/healing. V1 focuses on CHIP_INVERSION (position swap).
 *
 * Usage:
 *   // After init(), check available inversions
 *   MapTactical.refresh()
 *   if (Fight.inversionReady) {
 *       Array<InversionCandidate> targets = MapTactical.getInversionCandidates()
 *       for (InversionCandidate c in targets) {
 *           debug("Can swap with " + c.target.name + " from c" + c.fromCell.id + " (mp=" + c.mpCost + ")")
 *       }
 *   }
 */

class MapTactical {

	// ═══════════════════════════════════════════════════════════════════════════
	// CACHED RESULTS - Populated by refresh()
	// ═══════════════════════════════════════════════════════════════════════════

	// Sorted array of valid inversion targets (by mpCost ascending)
	static Array<InversionCandidate> _inversionCandidates = []

	// O(1) lookup: targetId -> InversionCandidate
	static Map<integer, InversionCandidate> _candidateByTargetId = [:]

	// Best candidates by score (for action generation)
	static InversionCandidate? _bestAllyCandidate = null
	static InversionCandidate? _bestEnemyCandidate = null

	// Team barycentres (center of mass)
	static Cell? _allyBarycentre = null
	static Cell? _enemyBarycentre = null

	// Operation counter for this module
	static integer _opsUsed = 0

	// LOS cache: key = (fromId << 10) | toId -> cells on line (persistent across turns)
	static Map<integer, Array<Cell>> _losCache = [:]

	// ═══════════════════════════════════════════════════════════════════════════
	// PUBLIC API
	// ═══════════════════════════════════════════════════════════════════════════

	/*
	 * Refresh tactical analysis for current turn.
	 * Computes valid inversion targets and best cast positions.
	 * Requires Fight.refresh() to be called first (sets inversionReady/inversionItem).
	 */
	static void refresh() {
		integer startOps = getOperations()
		_inversionCandidates = []
		_candidateByTargetId = [:]
		_bestAllyCandidate = null
		_bestEnemyCandidate = null

		// Compute team barycentres
		_allyBarycentre = _computeBarycentre(Fight.getAlliesAlive())
		_enemyBarycentre = _computeBarycentre(Fight.getEnemiesAlive())

		// Exit early if chip not available (checked in Fight.refresh)
		if (!Fight.inversionReady || Fight.inversionItem == null) {
			_opsUsed = getOperations() - startOps
			return;
		}

		Item invItem = Fight.inversionItem!

		// Check TP (cooldown already checked in Fight.refresh)
		if (Fight.self.tp < invItem.cost) {
			_opsUsed = getOperations() - startOps
			return;
		}

		// Get self's extended reachable cells (includes MP buff potential)
		Map<Cell, integer> reachable = Fight.self.extendedReachableCells
		Cell selfCell = Fight.self.cell

		// Process all entities (allies + enemies, excluding self)
		Map<integer, Entity> allEntities = Fight.getAllAlive()

		for (integer entityId : Entity entity in allEntities) {
			// Skip self
			if (entityId == Fight.self.id) continue
			// Skip static entities (turrets) - can't swap positions
			if (entity.isStatic) continue

			// Get cells from which we can cast inversion on this target
			Array<Cell> fromCells = Targets.getCellsToUseItemOnCell(invItem, entity.cell, [Fight.self.id])

			// Check if selfCell is already in range (no movement needed)
			Cell? bestFrom = null
			integer bestCost = 9999

			// First check if selfCell is in the valid cast cells
			for (Cell fromCell in fromCells) {
				if (fromCell.id == selfCell.id) {
					bestFrom = selfCell
					bestCost = 0
					break
				}
			}

			// If not in range, find closest reachable cell
			if (bestFrom == null) {
				for (Cell fromCell in fromCells) {
					integer? cost = reachable[fromCell]
					if (cost != null && cost! < bestCost) {
						bestCost = cost!
						bestFrom = fromCell
					}
				}
			}

			// Skip if no reachable cast position
			if (bestFrom == null) continue

			// Score swaps
			real score = 0
			if (entity.isFriend) {
				// Ally swaps: danger reduction treated as "virtual heal"
				// After swap: ally ends up on fromCell (where we stand to cast), we end up on entity.cell
				Danger oldDanger = MapDanger.getCellDanger(entity.cell)
				Danger newDanger = MapDanger.getCellDanger(bestFrom!)
				real oldTotal = oldDanger.dmg + oldDanger.psnDmg
				real newTotal = newDanger.dmg + newDanger.psnDmg
				real dangerReduction = oldTotal - newTotal
				real coef = Scoring.getDynamicCoef(entity, Stats.HP, null)
				score = dangerReduction * coef

				// DEATH bonus if swap saves ally from death
				// DEATH_VALUE (-10000) * ally KILL coef (-1.0) = +10000
				boolean stillCanDie = (newTotal * ScoringConfig.CANDIE_THRESHOLD >= entity.life)
				if (entity.canDie && !stillCanDie) {
					score += ScoringConfig.DEATH_VALUE * Scoring.getDynamicCoef(entity, Stats.KILL, null)
				}
			} else {
				// Enemy swaps: pull enemy to fromCell where allies can hit them
				// After swap: enemy ends up at fromCell (our cast position), we end up at entity.cell
				// Score = delta in ally damage potential (new position vs current position)
				// dmgDelta positive = more damage at new pos = GOOD for us
				// coef is negative for enemies, so negate to get positive score for good swaps

				// Create inversion action to get consequences (e.g., vulnerability effect)
				Action invAction = Action(invItem, bestFrom!, entity.cell)
				Consequences invConseq = invAction.consequences

				// Use consequences for new pos (vulnerability applied), but not for current pos (before inversion)
				real dmgAtNewPos = MapDamage.getDamageBeforeEnemy(bestFrom!, entity, invConseq)
				real dmgAtCurrentPos = MapDamage.getDamageBeforeEnemy(entity.cell, entity, null)
				real dmgDelta = dmgAtNewPos - dmgAtCurrentPos
				real coef = Scoring.getDynamicCoef(entity, Stats.HP, invConseq)
				score = dmgDelta * (-coef)  // Negate: more damage to enemy = positive score

				// KILL bonus if allies can kill enemy at new position
				if (dmgAtNewPos >= entity.life) {
					score += ScoringConfig.KILL_VALUE * Scoring.getDynamicCoef(entity, Stats.KILL, invConseq)
				}
			}

			// Create candidate
			InversionCandidate candidate = InversionCandidate(
				bestFrom!,
				entity,
				entity.cell,
				bestCost,
				score
			)

			push(_inversionCandidates, candidate)
			_candidateByTargetId[entityId] = candidate
		}

		// Sort by mpCost ascending (cheapest first)
		_inversionCandidates = arraySort(_inversionCandidates, (InversionCandidate a, InversionCandidate b) -> integer {
			return a.mpCost - b.mpCost
		}) as Array<InversionCandidate>

		// Select best ally and best enemy candidates (by score)
		for (InversionCandidate c in _inversionCandidates) {
			if (c.target.isFriend) {
				if (_bestAllyCandidate == null || c.score > _bestAllyCandidate!.score) {
					_bestAllyCandidate = c
				}
			} else {
				if (_bestEnemyCandidate == null || c.score > _bestEnemyCandidate!.score) {
					_bestEnemyCandidate = c
				}
			}
		}

		_opsUsed = getOperations() - startOps
	}

	/*
	 * Compute barycentre (center of mass) for a set of entities.
	 * Returns the cell at the rounded average position, or null if empty.
	 */
	static Cell? _computeBarycentre(Map<integer, Entity> entities) {
		integer n = mapSize(entities)
		if (n == 0) return null

		real sumX = 0
		real sumY = 0

		for (integer id : Entity e in entities) {
			sumX += e.cell.x
			sumY += e.cell.y
		}

		integer avgX = round(sumX / n)
		integer avgY = round(sumY / n)

		// Direct lookup - may be null or wall, that's ok for visualization
		return Board.cellsXY[avgX]![avgY]
	}

	/*
	 * Get ally team barycentre, or null if no allies.
	 */
	static Cell? getAllyBarycentre() {
		return _allyBarycentre
	}

	/*
	 * Get enemy team barycentre, or null if no enemies.
	 */
	static Cell? getEnemyBarycentre() {
		return _enemyBarycentre
	}

	/*
	 * Get all valid inversion candidates, sorted by MP cost ascending.
	 */
	static Array<InversionCandidate> getInversionCandidates() {
		return _inversionCandidates
	}

	/*
	 * Get the inversion candidate for a specific target, or null if not valid.
	 */
	static InversionCandidate? getCandidateForTarget(integer targetId) {
		return _candidateByTargetId[targetId]
	}

	/*
	 * Get the best ally inversion candidate (highest score), or null if none.
	 */
	static InversionCandidate? getBestAllyCandidate() {
		return _bestAllyCandidate
	}

	/*
	 * Get the best enemy inversion candidate (highest score), or null if none.
	 */
	static InversionCandidate? getBestEnemyCandidate() {
		return _bestEnemyCandidate
	}

	/*
	 * Display inversion targets and team barycentres on the map (for debugging).
	 * White = team barycentres
	 * Blue = ally inversion targets
	 * Red = enemy inversion targets
	 */
	static void showTactical() {
		integer white = getColor(255, 255, 255)
		integer blue = getColor(100, 149, 237)   // Cornflower blue for allies
		integer red = getColor(220, 80, 80)      // Red for enemies

		// Display team barycentres
		if (_allyBarycentre != null) {
			mark(_allyBarycentre!.id, white)
			markText(_allyBarycentre!.id, "A-BAR")
		}
		if (_enemyBarycentre != null) {
			mark(_enemyBarycentre!.id, white)
			markText(_enemyBarycentre!.id, "E-BAR")
		}

		// Display inversion candidates
		for (InversionCandidate c in _inversionCandidates) {
			integer color = c.target.isFriend ? blue : red

			// Mark fromCell (cast position)
			mark(c.fromCell.id, color)

			// Mark targetCell (destination after swap)
			mark(c.targetCell.id, color)

			// Text label with score
			markText(c.fromCell.id, "I:" + round(c.score))
		}
	}

	/*
	 * Generate action pool for post-inversion phase.
	 * Creates actions with correct `from` cells relative to new position after swap.
	 * Actions are scored with inversion consequences applied (e.g., shield reductions).
	 *
	 * @param candidate The inversion candidate (defines new position)
	 * @param remainingTP TP available after inversion
	 * @param remainingMP MP available after moving to cast inversion
	 * @return Array of actions playable from new position
	 */
	static Array<Action> getPostInversionPool(
		InversionCandidate candidate,
		integer remainingTP,
		integer remainingMP
	) {
		Array<Action> postPool = []

		// Debug: show target
		debug("INV_POOL>target=" + candidate.target.name)

		// New position after swap: we end up at target's cell
		Cell newSelfCell = candidate.targetCell
		// Enemy ends up at our cast position (fromCell)
		Cell enemyNewCell = candidate.fromCell

		// Create inversion action to get its consequences
		// Post-inversion actions will be scored with these effects applied
		// (e.g., if inversion reduces relshield, damage actions score higher)
		Item invItem = Fight.inversionItem!
		Action invAction = Action(invItem, candidate.fromCell, candidate.targetCell)
		Consequences invConseq = invAction.consequences

		// Compute reachability from new position
		// Add enemyNewCell as obstacle (swapped entity is there now)
		// IMPORTANT: Use Fight.self.cellsToIgnore directly for consistency with Consequences.construct()
		Set<Cell> newObstacles = <enemyNewCell>
		Map<Cell, integer> newReachable = MapPath.getCachedReachableCells(
			newSelfCell, remainingMP, Fight.self.cellsToIgnore, newObstacles)

		// For each offensive item, find actions on enemies
		// NOTE: Don't filter by TP here - let the combo builder/knapsack decide what fits
		for (Item item in Fight.self.items) {
			// Skip non-offensive items (O(1) check via precomputed flag)
			if (!item.isOffensive) continue
			// Skip items on cooldown (they're truly unavailable)
			if (getCooldown(item.id, Fight.self.id) > 0) continue
			// Skip inversion itself (already used)
			if (item.id == Fight.inversionItem!.id) continue

			// For each enemy, find closest reachable cast cell
			for (Entity enemy in Fight.getEnemiesAlive()) {
				if (enemy.isInvincible) continue

				// Enemy cell: swapped enemy is at enemyNewCell, others at their original cell
				Cell enemyCell = (enemy == candidate.target) ? enemyNewCell : enemy.cell

				// Use shared cache (ignores ALL entities) - we'll verify LOS lazily with DDA
				Array<Cell> castCells = MapDanger.getCachedTargetableCells(item, enemyCell)

				// Build set for O(1) lookup
				Set<integer> castSet = <>
				for (Cell c in castCells) setPut(castSet, c.id)

				// Find closest reachable cast cell with lazy LOS check
				Cell? bestCast = null
				integer bestDist = 9999

				// Check if newSelfCell is valid (no movement needed)
				if (setContains(castSet, newSelfCell.id)) {
					if (MapTactical._hasValidLOS(newSelfCell, enemyCell, candidate.target, enemyNewCell)) {
						bestCast = newSelfCell
						bestDist = 0
					}
				}

				// If not, iterate reachable in BFS order - first valid is closest
				if (bestCast == null) {
					for (Cell c : integer dist in newReachable) {
						if (!setContains(castSet, c.id)) continue
						// Lazy LOS check via DDA
						if (MapTactical._hasValidLOS(c, enemyCell, candidate.target, enemyNewCell)) {
							bestCast = c
							bestDist = dist
							break  // BFS order guarantees first match is closest
						}
					}
				}

				if (bestCast == null) continue

				// Create action with correct from cell
				EffectSnapshot snapshot = EffectCache.computeSnapshotForTarget(item, enemy, enemyCell, invConseq)
				Action action = Action(item, bestCast!, enemyCell, snapshot)
				action.overrideTargets = snapshot.targets
				if (action.score != null && action.score! > 0) {
					push(postPool, action)
				}
			}
		}

		// Add self-cast buffs (always available from any position)
		// NOTE: Don't filter by TP - let combo builder decide
		for (Item item in Fight.self.items) {
			if (item.isSummon || item.isTactical) continue
			if (getCooldown(item.id, Fight.self.id) > 0) continue
			if (item.minRange > 0) continue  // Not self-castable

			// Check if item has buff effects (not pure damage)
			boolean hasBuff = false
			for (ItemEffect e in item.effects) {
				integer t = e.type
				if (t == EFFECT_BUFF_STRENGTH || t == EFFECT_RAW_BUFF_STRENGTH ||
					t == EFFECT_BUFF_AGILITY || t == EFFECT_RAW_BUFF_AGILITY ||
					t == EFFECT_BUFF_TP || t == EFFECT_RAW_BUFF_TP ||
					t == EFFECT_BUFF_MP || t == EFFECT_RAW_BUFF_MP ||
					t == EFFECT_ABSOLUTE_SHIELD || t == EFFECT_RAW_ABSOLUTE_SHIELD ||
					t == EFFECT_RELATIVE_SHIELD || t == EFFECT_RAW_RELATIVE_SHIELD ||
					t == EFFECT_HEAL || t == EFFECT_BOOST_MAX_LIFE) {
					hasBuff = true
					break
				}
			}

			if (hasBuff) {
				Action action = Action(item, Fight.selfCell, Fight.selfCell)
				if (action.score != null && action.score! > 0) {
					push(postPool, action)
				}
			}
		}

		// Add support actions for swapped ally (reuse MapAction's item filtering)
		if (candidate.target.isFriend) {
			Set<Item>? targetingItems = MapAction.getItemsTargetingEntity(candidate.target)
			if (targetingItems != null) {
				// Ally's new position after swap
				Cell allyNewCell = candidate.fromCell

				for (Item item in targetingItems!) {
					// NOTE: Don't filter by TP - let combo builder decide
					if (getCooldown(item.id, Fight.self.id) > 0) continue

					// Use shared cache (ignores ALL entities) - verify LOS lazily
					Array<Cell> castCells = MapDanger.getCachedTargetableCells(item, allyNewCell)

					// Build set for O(1) lookup
					Set<integer> castSet = <>
					for (Cell c in castCells) setPut(castSet, c.id)

					// Find closest reachable cast cell with lazy LOS check
					Cell? bestCast = null
					integer bestDist = 9999

					// Check if newSelfCell is valid (no movement needed)
					// For ally support, swapped entity IS the target, so no extra blocking
					if (setContains(castSet, newSelfCell.id)) {
						if (MapTactical._hasValidLOS(newSelfCell, allyNewCell, candidate.target, allyNewCell)) {
							bestCast = newSelfCell
							bestDist = 0
						}
					}

					// If not, iterate reachable in BFS order
					if (bestCast == null) {
						for (Cell c : integer dist in newReachable) {
							if (!setContains(castSet, c.id)) continue
							if (MapTactical._hasValidLOS(c, allyNewCell, candidate.target, allyNewCell)) {
								bestCast = c
								bestDist = dist
								break
							}
						}
					}

					if (bestCast == null) continue

					// Create action targeting ally at new position
					EffectSnapshot snapshot = EffectCache.computeSnapshotForTarget(item, candidate.target, allyNewCell, invConseq)
					Action action = Action(item, bestCast!, allyNewCell, snapshot)
					action.overrideTargets = snapshot.targets
					if (action.score != null && action.score! > 0) {
						push(postPool, action)
					}
				}
			}
		}

		debug("INV_POOL>pool=" + count(postPool))
		return postPool
	}

	/*
	 * Compute cell scores for post-inversion state.
	 * Uses ONLY the post-inversion pool (not base MapAction actions) because
	 * the swapped entity can block LOS to any enemy, not just itself.
	 *
	 * @param candidate The inversion candidate (defines swap target)
	 * @param newSelfCell Where we land after swap (= candidate.targetCell)
	 * @param reachableCells Cells reachable from newSelfCell with remaining MP
	 * @param postByCell Actions from getPostInversionPool() grouped by fromCell
	 * @return PostInversionCellData with scores, actions, and MP costs per cell
	 */
	static PostInversionCellData getPostInversionCellScores(
		InversionCandidate candidate,
		Cell newSelfCell,
		Map<Cell, integer> reachableCells,
		Map<Cell, Array<Action>> postByCell
	) {
		PostInversionCellData result = PostInversionCellData()

		// Only use post-inversion pool (already has LOS blocking handled)
		for (Cell cell : Array<Action> postActions in postByCell) {
			// Compute MP cost
			integer mpCost = 0
			if (cell != newSelfCell) {
				integer? cost = reachableCells[cell]
				if (cost == null) continue  // Unreachable
				mpCost = cost!
			}

			// Collect valid actions
			Array<Action> validActions = []
			real score = 0

			for (Action a in postActions) {
				if (a.score != null && a.score! > 0) {
					score += a.score!
					push(validActions, a)
				}
			}

			if (score <= 0) continue  // No useful actions

			result.scores[cell] = score
			result.actions[cell] = validActions
			result.mpCosts[cell] = mpCost
		}

		return result
	}

	/*
	 * Debug output: show all computed inversion targets and barycentres
	 */
	static void debugAll() {
		debug("=== MapTactical Results (ops=" + _opsUsed + ") ===")

		// Barycentres
		string allyBar = _allyBarycentre != null ? "c" + _allyBarycentre!.id : "none"
		string enemyBar = _enemyBarycentre != null ? "c" + _enemyBarycentre!.id : "none"
		debug("  Barycentres: ally=" + allyBar + " enemy=" + enemyBar)

		// Inversion candidates
		if (!Fight.inversionReady) {
			debug("  CHIP_INVERSION: not available")
		} else {
			debug("  CHIP_INVERSION: " + count(_inversionCandidates) + " valid targets")
			for (InversionCandidate c in _inversionCandidates) {
				string tag = c.target.isFriend ? "ALLY" : "ENEMY"
				debug("    [" + tag + "] " + c)
			}
		}
		debug("=== End MapTactical ===")
	}

	/*
	 * Check if LOS is valid from castCell to targetCell after inversion.
	 * Uses DDA to trace the line and checks for blockers:
	 * - Walls block LOS
	 * - Entities block LOS (except self and swapTarget who moved)
	 * - swapTarget at their NEW position (swapTargetNewCell) blocks LOS
	 *
	 * @param castCell Cell we're casting from
	 * @param targetCell Cell we're targeting
	 * @param swapTarget Entity that swapped (ignore at original position)
	 * @param swapTargetNewCell Where swapTarget is now (check as blocker)
	 * @return true if LOS is clear, false if blocked
	 */
	static boolean _hasValidLOS(Cell castCell, Cell targetCell, Entity swapTarget, Cell swapTargetNewCell) {
		// Same cell = always valid
		if (castCell == targetCell) return true

		// Get cells on the line (cached DDA)
		Array<Cell> line = _getCellsLineOfSight(castCell, targetCell)

		// Check each cell on the line (skip endpoints)
		for (Cell c in line) {
			if (c == castCell || c == targetCell) continue

			// Wall blocks LOS
			if (c.isWall) return false

			// Swapped entity at new position blocks LOS
			if (c == swapTargetNewCell) return false

			// Other entities block LOS (except self and swapTarget who moved)
			Entity? entityOnCell = Board.entityCells[c]
			if (entityOnCell != null && entityOnCell != Fight.self && entityOnCell != swapTarget) {
				return false
			}
		}

		return true
	}

	/*
	 * Get cells on line of sight between two cells (DDA algorithm).
	 * Uses doubled coordinates to avoid floating point.
	 * Results are cached (grid is static for the fight).
	 *
	 * @param from Starting cell
	 * @param to Target cell
	 * @return Array of cells on the line (includes from and to)
	 */
	static Array<Cell> _getCellsLineOfSight(Cell from, Cell to) {
		// Cache key: pack two cell IDs into one integer (cell IDs < 613, so << 10 is safe)
		integer key = (from.id << 10) | to.id

		// Check cache first
		Array<Cell>? cached = _losCache[key]
		if (cached != null) return cached!

		// Compute LOS line
		Array<Cell> cells = []
		integer x = from.x
		integer y = from.y

		// Centers *2 (avoids .5)
		integer cx0 = (x << 1) + 1
		integer cy0 = (y << 1) + 1
		integer cx1 = (to.x << 1) + 1
		integer cy1 = (to.y << 1) + 1

		integer adx = abs(cx1 - cx0)
		integer ady = abs(cy1 - cy0)
		integer sx = cx0 < cx1 ? 1 : -1
		integer sy = cy0 < cy1 ? 1 : -1

		// Parameter t as numerator (common denominator = adx*ady)
		integer tMaxX = ady
		integer tMaxY = adx

		integer tStepX = ady << 1
		integer tStepY = adx << 1

		// DDA can step through coordinates with no cell (e.g. corner of diamond board)
		Cell? c = Board.cellsXY[x]![y]
		if (c != null) push(cells, c!)

		while (x != to.x || y != to.y) {
			if (tMaxX < tMaxY) {
				x += sx
				tMaxX += tStepX
			} else {
				y += sy
				tMaxY += tStepY
			}
			c = Board.cellsXY[x]![y]
			if (c != null) push(cells, c!)
		}

		// Store in cache
		_losCache[key] = cells
		return cells
	}

	/*
	 * Get set of cast cells that would have LOS blocked by obstacle.
	 * Uses DDA line tracing - exact and efficient (no game API calls).
	 *
	 * @param castCells Potential cast cells for this item/enemy
	 * @param targetCell Where the enemy is (target of attack)
	 * @param obstacle Cell that might block LOS (swapped entity position)
	 * @return Set of cell IDs that are blocked, or null if none blocked
	 */
	static Set<integer>? _getBlockedCastCells(Array<Cell> castCells, Cell targetCell, Cell obstacle) {
		// Quick check: if obstacle is the target, nothing is blocked
		if (obstacle == targetCell) return null

		Set<integer> blocked = <>

		for (Cell c in castCells) {
			// Skip if cast cell is the obstacle itself
			if (c == obstacle) {
				setPut(blocked, c.id)
				continue
			}

			// Skip if cast cell is the target (no LOS needed)
			if (c == targetCell) continue

			// Trace LOS from cast cell to target, check if obstacle is on the line
			Array<Cell> losLine = _getCellsLineOfSight(c, targetCell)
			for (Cell lineCell in losLine) {
				if (lineCell == obstacle) {
					setPut(blocked, c.id)
					break
				}
			}
		}

		return setSize(blocked) > 0 ? blocked : null
	}

}
