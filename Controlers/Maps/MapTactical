/*
 * MapTactical - Intelligent tactical chip selection
 *
 * Handles tactical chips that affect positioning or game state in ways
 * beyond simple damage/healing:
 *   - CHIP_INVERSION: Position swap with any entity (ally or enemy)
 *   - CHIP_REPOTTING: Position swap with allied bulb (deals damage to bulb)
 *
 * Usage:
 *   MapTactical.refresh()
 *
 *   // Inversion (any entity)
 *   if (Fight.inversionReady) {
 *       Array<InversionCandidate> targets = MapTactical.getInversionCandidates()
 *   }
 *
 *   // Repotting (allied bulbs only)
 *   if (Fight.repottingReady) {
 *       Array<RepottingCandidate> bulbs = MapTactical.getRepottingCandidates()
 *   }
 */

class MapTactical {

	// ═══════════════════════════════════════════════════════════════════════════
	// CACHED RESULTS - Populated by refresh()
	// ═══════════════════════════════════════════════════════════════════════════

	// Sorted array of valid inversion targets (by mpCost ascending)
	static Array<InversionCandidate> _inversionCandidates = []

	// O(1) lookup: targetId -> InversionCandidate
	static Map<integer, InversionCandidate> _candidateByTargetId = [:]

	// Best candidates by score (for action generation)
	static InversionCandidate? _bestAllyCandidate = null
	static InversionCandidate? _bestEnemyCandidate = null

	// Sorted array of valid repotting targets (allied bulbs only, by mpCost ascending)
	static Array<RepottingCandidate> _repottingCandidates = []

	// O(1) lookup: targetId -> RepottingCandidate
	static Map<integer, RepottingCandidate> _repottingCandidateByTargetId = [:]

	// Team barycentres (center of mass)
	static Cell? _allyBarycentre = null
	static Cell? _enemyBarycentre = null

	// Operation counter for this module
	static integer _opsUsed = 0

	// LOS cache: key = (fromId << 10) | toId -> cells on line (persistent across turns)
	static Map<integer, Array<Cell>> _losCache = [:]

	// ═══════════════════════════════════════════════════════════════════════════
	// PUBLIC API
	// ═══════════════════════════════════════════════════════════════════════════

	/*
	 * Refresh tactical analysis for current turn.
	 * Computes valid inversion targets and best cast positions.
	 * Requires Fight.refresh() to be called first (sets inversionReady/inversionItem).
	 */
	static void refresh() {
		integer startOps = getOperations()
		_inversionCandidates = []
		_candidateByTargetId = [:]
		_bestAllyCandidate = null
		_bestEnemyCandidate = null
		_repottingCandidates = []
		_repottingCandidateByTargetId = [:]

		// Compute team barycentres
		_allyBarycentre = _computeBarycentre(Fight.getAlliesAlive())
		_enemyBarycentre = _computeBarycentre(Fight.getEnemiesAlive())

		// Initialize inversion candidates if chip is available
		if (Fight.inversionReady && Fight.inversionItem != null) {
			_initInversionCandidates()
		}

		// Initialize repotting candidates if chip is available
		if (Fight.repottingReady && Fight.repottingItem != null) {
			_initRepottingCandidates()
		}

		_opsUsed = getOperations() - startOps
	}

	/*
	 * Find the best cell to cast an item on a target.
	 * Returns [Cell, integer] with best cast cell and MP cost, or null if unreachable.
	 *
	 * @param item The item to cast
	 * @param targetCell The target's cell
	 * @param reachable Reachable cells map (cell -> MP cost)
	 * @param selfCell Current position (checked first for 0-cost cast)
	 * @return [bestFromCell, mpCost] or null if no valid cast position
	 */
	static Array<any>? _findBestCastCell(Item item, Cell targetCell, Map<Cell, integer> reachable, Cell selfCell) {
		Array<Cell> fromCells = Targets.getCellsToUseItemOnCell(item, targetCell, [Fight.self.id])

		// First check if selfCell is in the valid cast cells (0 MP cost)
		for (Cell fromCell in fromCells) {
			if (fromCell.id == selfCell.id) {
				return [selfCell, 0]
			}
		}

		// Find closest reachable cell
		Cell? bestFrom = null
		integer bestCost = 9999
		for (Cell fromCell in fromCells) {
			integer? cost = reachable[fromCell]
			if (cost != null && cost! < bestCost) {
				bestCost = cost!
				bestFrom = fromCell
			}
		}

		return bestFrom != null ? [bestFrom!, bestCost] : null
	}

	/*
	 * Initialize inversion candidates for current turn.
	 * Computes valid targets, scores, and best candidates.
	 * Called only when Fight.inversionReady && Fight.inversionItem != null.
	 */
	static void _initInversionCandidates() {
		Item invItem = Fight.inversionItem!

		// Check TP (cooldown already checked in Fight.refresh)
		if (Fight.self.tp < invItem.cost) return;

		// Get self's extended reachable cells (includes MP buff potential)
		Map<Cell, integer> reachable = Fight.self.extendedReachableCells
		Cell selfCell = Fight.self.cell

		// Process all entities (allies + enemies, excluding self)
		Map<integer, Entity> allEntities = Fight.getAllAlive()

		for (integer entityId : Entity entity in allEntities) {
			// Skip self
			if (entityId == Fight.self.id) continue
			// Skip static entities (turrets) - can't swap positions
			if (entity.isStatic) continue

			// Find best cast position
			Array<any>? castResult = _findBestCastCell(invItem, entity.cell, reachable, selfCell)
			if (castResult == null) continue

			Cell bestFrom = castResult![0] as Cell
			integer bestCost = castResult![1] as integer

			// Score swaps
			real score = 0
			if (entity.isFriend) {
				// Ally swaps: danger reduction treated as "virtual heal"
				// After swap: ally ends up on fromCell (where we stand to cast), we end up on entity.cell
				Danger oldDanger = MapDanger.getCellDanger(entity.cell)
				Danger newDanger = MapDanger.getCellDanger(bestFrom)
				real oldTotal = oldDanger.dmg + oldDanger.psnDmg
				real newTotal = newDanger.dmg + newDanger.psnDmg
				real dangerReduction = oldTotal - newTotal
				real coef = Scoring.getDynamicCoef(entity, Stats.HP, null)
				score = dangerReduction * coef

				// DEATH bonus if swap saves ally from death
				// DEATH_VALUE (-10000) * ally KILL coef (-1.0) = +10000
				boolean stillCanDie = (newTotal * ScoringConfig.CANDIE_THRESHOLD >= entity.life)
				if (entity.canDie && !stillCanDie) {
					score += ScoringConfig.DEATH_VALUE * Scoring.getDynamicCoef(entity, Stats.KILL, null)
				}
			} else {
				// Enemy swaps: pull enemy to fromCell where allies can hit them
				// After swap: enemy ends up at fromCell (our cast position), we end up at entity.cell
				// Score = delta in ally damage potential (new position vs current position)
				// dmgDelta positive = more damage at new pos = GOOD for us
				// coef is negative for enemies, so negate to get positive score for good swaps

				// Create inversion action to get consequences (e.g., vulnerability effect)
				Action invAction = Action(invItem, bestFrom, entity.cell)
				Consequences invConseq = invAction.consequences

				// Use consequences for new pos (vulnerability applied), but not for current pos (before inversion)
				real dmgAtNewPos = MapDamage.getDamageBeforeEnemy(bestFrom, entity, invConseq)
				real dmgAtCurrentPos = MapDamage.getDamageBeforeEnemy(entity.cell, entity, null)
				real dmgDelta = dmgAtNewPos - dmgAtCurrentPos
				real coef = Scoring.getDynamicCoef(entity, Stats.HP, invConseq)
				score = dmgDelta * (-coef)  // Negate: more damage to enemy = positive score

				// // KILL bonus if allies can kill enemy at new position
				// if (dmgAtNewPos >= entity.life) {
				// 	score += ScoringConfig.KILL_VALUE * Scoring.getDynamicCoef(entity, Stats.KILL, invConseq)
				// }
			}

			// Create candidate
			InversionCandidate candidate = InversionCandidate(
				bestFrom,
				entity,
				entity.cell,
				bestCost,
				score
			)

			push(_inversionCandidates, candidate)
			_candidateByTargetId[entityId] = candidate
		}

		// Sort by mpCost ascending (cheapest first)
		_inversionCandidates = arraySort(_inversionCandidates, (InversionCandidate a, InversionCandidate b) -> integer {
			return a.mpCost - b.mpCost
		}) as Array<InversionCandidate>

		// Select best ally and best enemy candidates (by score)
		for (InversionCandidate c in _inversionCandidates) {
			if (c.target.isFriend) {
				if (_bestAllyCandidate == null || c.score > _bestAllyCandidate!.score) {
					_bestAllyCandidate = c
				}
			} else {
				if (_bestEnemyCandidate == null || c.score > _bestEnemyCandidate!.score) {
					_bestEnemyCandidate = c
				}
			}
		}
	}

	/*
	 * Initialize repotting candidates for current turn.
	 * Only considers allied bulbs. Filters out bulbs that would die from the damage.
	 * Called only when Fight.repottingReady && Fight.repottingItem != null.
	 */
	static void _initRepottingCandidates() {
		Item repItem = Fight.repottingItem!

		// Check TP (cooldown already checked in Fight.refresh)
		if (Fight.self.tp < repItem.cost) return;

		// Get self's extended reachable cells
		Map<Cell, integer> reachable = Fight.self.extendedReachableCells
		Cell selfCell = Fight.self.cell

		// Process only allied bulbs
		for (integer entityId : Entity entity in Fight.getAlliesBulbsAlive()) {
			// Skip self (shouldn't happen for bulbs, but safe)
			if (entityId == Fight.self.id) continue

			// Find best cast position (reuses helper from inversion)
			Array<any>? castResult = _findBestCastCell(repItem, entity.cell, reachable, selfCell)
			if (castResult == null) continue

			Cell bestFrom = castResult![0] as Cell
			integer bestCost = castResult![1] as integer

			// Estimate damage to bulb
			integer bulbDamage = _estimateRepottingDamage(repItem, entity)

			// Skip if repotting would kill the bulb
			if (bulbDamage >= entity.life) continue

			// Create candidate (no score - danger evaluated at combo end)
			RepottingCandidate candidate = RepottingCandidate(
				bestFrom,
				entity,
				entity.cell,
				bestCost,
				bulbDamage
			)

			push(_repottingCandidates, candidate)
			_repottingCandidateByTargetId[entityId] = candidate
		}

		// Sort by mpCost ascending (cheapest first)
		_repottingCandidates = arraySort(_repottingCandidates, (RepottingCandidate a, RepottingCandidate b) -> integer {
			return a.mpCost - b.mpCost
		}) as Array<RepottingCandidate>
	}

	/*
	 * Estimate damage dealt to bulb by CHIP_REPOTTING.
	 * TODO: Implement proper damage calculation when needed.
	 */
	static integer _estimateRepottingDamage(Item repItem, Entity bulb) {
		// For now, ignore damage - assume bulb survives
		return 0
	}

	/*
	 * Compute barycentre (center of mass) for a set of entities.
	 * Returns the cell at the rounded average position, or null if empty.
	 */
	static Cell? _computeBarycentre(Map<integer, Entity> entities) {
		integer n = mapSize(entities)
		if (n == 0) return null

		real sumX = 0
		real sumY = 0

		for (integer id : Entity e in entities) {
			sumX += e.cell.x
			sumY += e.cell.y
		}

		integer avgX = round(sumX / n)
		integer avgY = round(sumY / n)

		// Direct lookup - may be null or wall, that's ok for visualization
		return Board.cellsXY[avgX]![avgY]
	}

	/*
	 * Get ally team barycentre, or null if no allies.
	 */
	static Cell? getAllyBarycentre() {
		return _allyBarycentre
	}

	/*
	 * Get enemy team barycentre, or null if no enemies.
	 */
	static Cell? getEnemyBarycentre() {
		return _enemyBarycentre
	}

	/*
	 * Get all valid inversion candidates, sorted by MP cost ascending.
	 */
	static Array<InversionCandidate> getInversionCandidates() {
		return _inversionCandidates
	}

	/*
	 * Get the inversion candidate for a specific target, or null if not valid.
	 */
	static InversionCandidate? getCandidateForTarget(integer targetId) {
		return _candidateByTargetId[targetId]
	}

	/*
	 * Get the best ally inversion candidate (highest score), or null if none.
	 */
	static InversionCandidate? getBestAllyCandidate() {
		return _bestAllyCandidate
	}

	/*
	 * Get the best enemy inversion candidate (highest score), or null if none.
	 */
	static InversionCandidate? getBestEnemyCandidate() {
		return _bestEnemyCandidate
	}

	/*
	 * Get all valid repotting candidates (allied bulbs), sorted by MP cost ascending.
	 */
	static Array<RepottingCandidate> getRepottingCandidates() {
		return _repottingCandidates
	}

	/*
	 * Get the repotting candidate for a specific bulb, or null if not valid.
	 */
	static RepottingCandidate? getRepottingCandidateForTarget(integer targetId) {
		return _repottingCandidateByTargetId[targetId]
	}

	/*
	 * Display inversion/repotting targets and team barycentres on the map (for debugging).
	 * White = team barycentres
	 * Blue = ally inversion targets
	 * Red = enemy inversion targets
	 * Green = repotting targets (allied bulbs)
	 */
	static void showTactical() {
		integer white = getColor(255, 255, 255)
		integer blue = getColor(100, 149, 237)   // Cornflower blue for allies
		integer red = getColor(220, 80, 80)      // Red for enemies
		integer green = getColor(100, 200, 100)  // Green for repotting

		// Display team barycentres
		if (_allyBarycentre != null) {
			mark(_allyBarycentre!.id, white)
			markText(_allyBarycentre!.id, "A-BAR")
		}
		if (_enemyBarycentre != null) {
			mark(_enemyBarycentre!.id, white)
			markText(_enemyBarycentre!.id, "E-BAR")
		}

		// Display inversion candidates
		for (InversionCandidate c in _inversionCandidates) {
			integer color = c.target.isFriend ? blue : red

			// Mark fromCell (cast position)
			mark(c.fromCell.id, color)

			// Mark targetCell (destination after swap)
			mark(c.targetCell.id, color)

			// Text label with score
			markText(c.fromCell.id, "I:" + round(c.score))
		}

		// Display repotting candidates
		for (RepottingCandidate c in _repottingCandidates) {
			mark(c.fromCell.id, green)
			mark(c.targetCell.id, green)
			markText(c.fromCell.id, "R:" + c.target.name)
		}
	}

	/*
	 * Generate action pool for post-inversion phase (wrapper for backward compatibility).
	 * @see getPostSwapPool for implementation
	 */
	static Array<Action> getPostInversionPool(
		InversionCandidate candidate,
		integer remainingTP,
		integer remainingMP
	) {
		Item swapItem = Fight.inversionItem!
		boolean includeAllySupport = candidate.target.isFriend
		return getPostSwapPool(
			candidate.target,
			candidate.targetCell,  // newSelfCell
			candidate.fromCell,    // swapTargetNewCell
			swapItem,
			remainingMP,
			includeAllySupport
		)
	}

	/*
	 * Generate action pool for post-repotting phase (wrapper for backward compatibility).
	 * @see getPostSwapPool for implementation
	 */
	static Array<Action> getPostRepottingPool(
		RepottingCandidate candidate,
		integer remainingTP,
		integer remainingMP
	) {
		Item swapItem = Fight.repottingItem!
		return getPostSwapPool(
			candidate.target,
			candidate.targetCell,  // newSelfCell
			candidate.fromCell,    // swapTargetNewCell (bulb's new position)
			swapItem,
			remainingMP,
			false  // Repotting never includes ally support (target IS the ally bulb)
		)
	}

	/*
	 * Unified action pool generation for post-swap phase.
	 * Creates actions with correct `from` cells relative to new position after swap.
	 * Actions are scored with swap consequences applied (e.g., shield reductions).
	 *
	 * @param swapTarget Entity we swapped with (for LOS blocking)
	 * @param newSelfCell Where we land after swap (target's original cell)
	 * @param swapTargetNewCell Where the swapped entity ends up (our cast position)
	 * @param swapItem The swap chip (CHIP_INVERSION or CHIP_REPOTTING)
	 * @param remainingMP MP available after moving to cast the swap
	 * @param includeAllySupport If true, add support actions for swapped ally
	 * @return Array of actions playable from new position
	 */
	static Array<Action> getPostSwapPool(
		Entity swapTarget,
		Cell newSelfCell,
		Cell swapTargetNewCell,
		Item swapItem,
		integer remainingMP,
		boolean includeAllySupport
	) {
		Array<Action> postPool = []

		// Debug: show target
		debug("SWAP_POOL>target=" + swapTarget.name)

		// Create swap action to get its consequences
		// Post-swap actions will be scored with these effects applied
		Action swapAction = Action(swapItem, swapTargetNewCell, newSelfCell)
		Consequences swapConseq = swapAction.consequences

		// Compute reachability from new position
		// swapTargetNewCell is an obstacle (swapped entity is there now)
		Set<Cell> newObstacles = <swapTargetNewCell>
		Map<Cell, integer> newReachable = MapPath.getCachedReachableCells(
			newSelfCell, remainingMP, Fight.self.cellsToIgnore, newObstacles)

		// For each offensive item, find actions on enemies
		for (Item item in Fight.self.items) {
			if (!item.isOffensive) continue
			if (getCooldown(item.id, Fight.self.id) > 0) continue
			if (item.id == swapItem.id) continue  // Skip swap chip itself

			for (Entity enemy in Fight.getEnemiesAlive()) {
				if (enemy.isInvincible) continue

				// Enemy cell: if swapped enemy, use new position; otherwise original
				Cell enemyCell = (enemy == swapTarget) ? swapTargetNewCell : enemy.cell

				// Use shared cache - verify LOS lazily with DDA
				Array<Cell> castCells = MapDanger.getCachedTargetableCells(item, enemyCell)

				// Build set for O(1) lookup
				Set<integer> castSet = <>
				for (Cell c in castCells) setPut(castSet, c.id)

				// Find closest reachable cast cell with lazy LOS check
				Cell? bestCast = null

				// Check if newSelfCell is valid (no movement needed)
				if (setContains(castSet, newSelfCell.id)) {
					if (_hasValidLOS(newSelfCell, enemyCell, swapTarget, swapTargetNewCell)) {
						bestCast = newSelfCell
					}
				}

				// If not, iterate reachable in BFS order - first valid is closest
				if (bestCast == null) {
					for (Cell c : integer dist in newReachable) {
						if (!setContains(castSet, c.id)) continue
						if (_hasValidLOS(c, enemyCell, swapTarget, swapTargetNewCell)) {
							bestCast = c
							break  // BFS order guarantees first match is closest
						}
					}
				}

				if (bestCast == null) continue

				// Create action with correct from cell
				EffectSnapshot snapshot = EffectCache.computeSnapshotForTarget(item, enemy, enemyCell, swapConseq)
				Action action = Action(item, bestCast!, enemyCell, snapshot)
				action.overrideTargets = snapshot.targets
				if (action.score != null && action.score! > 0) {
					push(postPool, action)
				}
			}
		}

		// Add self-cast buffs (always available from any position)
		for (Item item in Fight.self.items) {
			if (item.isSummon || item.isTactical) continue
			if (getCooldown(item.id, Fight.self.id) > 0) continue
			if (item.minRange > 0) continue  // Not self-castable

			// Check if item has buff effects (not pure damage)
			boolean hasBuff = false
			for (ItemEffect e in item.effects) {
				integer t = e.type
				if (t == EFFECT_BUFF_STRENGTH || t == EFFECT_RAW_BUFF_STRENGTH ||
					t == EFFECT_BUFF_AGILITY || t == EFFECT_RAW_BUFF_AGILITY ||
					t == EFFECT_BUFF_TP || t == EFFECT_RAW_BUFF_TP ||
					t == EFFECT_BUFF_MP || t == EFFECT_RAW_BUFF_MP ||
					t == EFFECT_ABSOLUTE_SHIELD || t == EFFECT_RAW_ABSOLUTE_SHIELD ||
					t == EFFECT_RELATIVE_SHIELD || t == EFFECT_RAW_RELATIVE_SHIELD ||
					t == EFFECT_HEAL || t == EFFECT_BOOST_MAX_LIFE) {
					hasBuff = true
					break
				}
			}

			if (hasBuff) {
				Action action = Action(item, Fight.selfCell, Fight.selfCell)
				if (action.score != null && action.score! > 0) {
					push(postPool, action)
				}
			}
		}

		// Add support actions for swapped ally (inversion with ally target only)
		if (includeAllySupport) {
			Set<Item>? targetingItems = MapAction.getItemsTargetingEntity(swapTarget)
			if (targetingItems != null) {
				// Ally's new position after swap
				Cell allyNewCell = swapTargetNewCell

				for (Item item in targetingItems!) {
					if (getCooldown(item.id, Fight.self.id) > 0) continue

					// Use shared cache - verify LOS lazily
					Array<Cell> castCells = MapDanger.getCachedTargetableCells(item, allyNewCell)

					// Build set for O(1) lookup
					Set<integer> castSet = <>
					for (Cell c in castCells) setPut(castSet, c.id)

					// Find closest reachable cast cell with lazy LOS check
					Cell? bestCast = null

					// Check if newSelfCell is valid (no movement needed)
					// For ally support, swapped entity IS the target, so no extra blocking
					if (setContains(castSet, newSelfCell.id)) {
						if (_hasValidLOS(newSelfCell, allyNewCell, swapTarget, allyNewCell)) {
							bestCast = newSelfCell
						}
					}

					// If not, iterate reachable in BFS order
					if (bestCast == null) {
						for (Cell c : integer dist in newReachable) {
							if (!setContains(castSet, c.id)) continue
							if (_hasValidLOS(c, allyNewCell, swapTarget, allyNewCell)) {
								bestCast = c
								break
							}
						}
					}

					if (bestCast == null) continue

					// Create action targeting ally at new position
					EffectSnapshot snapshot = EffectCache.computeSnapshotForTarget(item, swapTarget, allyNewCell, swapConseq)
					Action action = Action(item, bestCast!, allyNewCell, snapshot)
					action.overrideTargets = snapshot.targets
					if (action.score != null && action.score! > 0) {
						push(postPool, action)
					}
				}
			}
		}

		debug("SWAP_POOL>pool=" + count(postPool))
		return postPool
	}

	/*
	 * Compute cell scores for post-swap state (inversion wrapper for backward compatibility).
	 * @see getPostSwapCellScores for implementation
	 */
	static PostInversionCellData getPostInversionCellScores(
		InversionCandidate candidate,
		Cell newSelfCell,
		Map<Cell, integer> reachableCells,
		Map<Cell, Array<Action>> postByCell
	) {
		return getPostSwapCellScores(newSelfCell, reachableCells, postByCell)
	}

	/*
	 * Compute cell scores for post-swap state (repotting wrapper for backward compatibility).
	 * @see getPostSwapCellScores for implementation
	 */
	static PostInversionCellData getPostRepottingCellScores(
		RepottingCandidate candidate,
		Cell newSelfCell,
		Map<Cell, integer> reachableCells,
		Map<Cell, Array<Action>> postByCell
	) {
		return getPostSwapCellScores(newSelfCell, reachableCells, postByCell)
	}

	/*
	 * Compute cell scores for post-swap state.
	 * Uses ONLY the post-swap pool (not base MapAction actions) because
	 * the swapped entity can block LOS to any enemy.
	 *
	 * @param newSelfCell Where we land after swap
	 * @param reachableCells Cells reachable from newSelfCell with remaining MP
	 * @param postByCell Actions from getPostSwapPool() grouped by fromCell
	 * @return PostInversionCellData with scores, actions, and MP costs per cell
	 */
	static PostInversionCellData getPostSwapCellScores(
		Cell newSelfCell,
		Map<Cell, integer> reachableCells,
		Map<Cell, Array<Action>> postByCell
	) {
		PostInversionCellData result = PostInversionCellData()

		for (Cell cell : Array<Action> postActions in postByCell) {
			// Compute MP cost
			integer mpCost = 0
			if (cell != newSelfCell) {
				integer? cost = reachableCells[cell]
				if (cost == null) continue  // Unreachable
				mpCost = cost!
			}

			// Collect valid actions
			Array<Action> validActions = []
			real score = 0

			for (Action a in postActions) {
				if (a.score != null && a.score! > 0) {
					score += a.score!
					push(validActions, a)
				}
			}

			if (score <= 0) continue  // No useful actions

			result.scores[cell] = score
			result.actions[cell] = validActions
			result.mpCosts[cell] = mpCost
		}

		return result
	}

	/*
	 * Debug output: show all computed inversion/repotting targets and barycentres
	 */
	static void debugAll() {
		debug("=== MapTactical Results (ops=" + _opsUsed + ") ===")

		// Barycentres
		string allyBar = _allyBarycentre != null ? "c" + _allyBarycentre!.id : "none"
		string enemyBar = _enemyBarycentre != null ? "c" + _enemyBarycentre!.id : "none"
		debug("  Barycentres: ally=" + allyBar + " enemy=" + enemyBar)

		// Inversion candidates
		if (!Fight.inversionReady) {
			debug("  CHIP_INVERSION: not available")
		} else {
			debug("  CHIP_INVERSION: " + count(_inversionCandidates) + " valid targets")
			for (InversionCandidate c in _inversionCandidates) {
				string tag = c.target.isFriend ? "ALLY" : "ENEMY"
				debug("    [" + tag + "] " + c)
			}
		}

		// Repotting candidates
		if (!Fight.repottingReady) {
			debug("  CHIP_REPOTTING: not available")
		} else {
			debug("  CHIP_REPOTTING: " + count(_repottingCandidates) + " valid bulb targets")
			for (RepottingCandidate c in _repottingCandidates) {
				debug("    [BULB] " + c)
			}
		}
		debug("=== End MapTactical ===")
	}

	/*
	 * Check if LOS is valid from castCell to targetCell after inversion.
	 * Uses DDA to trace the line and checks for blockers:
	 * - Walls block LOS
	 * - Entities block LOS (except self and swapTarget who moved)
	 * - swapTarget at their NEW position (swapTargetNewCell) blocks LOS
	 *
	 * @param castCell Cell we're casting from
	 * @param targetCell Cell we're targeting
	 * @param swapTarget Entity that swapped (ignore at original position)
	 * @param swapTargetNewCell Where swapTarget is now (check as blocker)
	 * @return true if LOS is clear, false if blocked
	 */
	static boolean _hasValidLOS(Cell castCell, Cell targetCell, Entity swapTarget, Cell swapTargetNewCell) {
		// Same cell = always valid
		if (castCell == targetCell) return true

		// Get cells on the line (cached DDA)
		Array<Cell> line = _getCellsLineOfSight(castCell, targetCell)

		// Check each cell on the line (skip endpoints)
		for (Cell c in line) {
			if (c == castCell || c == targetCell) continue

			// Wall blocks LOS
			if (c.isWall) return false

			// Swapped entity at new position blocks LOS
			if (c == swapTargetNewCell) return false

			// Other entities block LOS (except self and swapTarget who moved)
			Entity? entityOnCell = Board.entityCells[c]
			if (entityOnCell != null && entityOnCell != Fight.self && entityOnCell != swapTarget) {
				return false
			}
		}

		return true
	}

	/*
	 * Get cells on line of sight between two cells (DDA algorithm).
	 * Uses doubled coordinates to avoid floating point.
	 * Results are cached (grid is static for the fight).
	 *
	 * @param from Starting cell
	 * @param to Target cell
	 * @return Array of cells on the line (includes from and to)
	 */
	static Array<Cell> _getCellsLineOfSight(Cell from, Cell to) {
		// Cache key: pack two cell IDs into one integer (cell IDs < 613, so << 10 is safe)
		integer key = (from.id << 10) | to.id

		// Check cache first
		Array<Cell>? cached = _losCache[key]
		if (cached != null) return cached!

		// Compute LOS line
		Array<Cell> cells = []
		integer x = from.x
		integer y = from.y

		// Centers *2 (avoids .5)
		integer cx0 = (x << 1) + 1
		integer cy0 = (y << 1) + 1
		integer cx1 = (to.x << 1) + 1
		integer cy1 = (to.y << 1) + 1

		integer adx = abs(cx1 - cx0)
		integer ady = abs(cy1 - cy0)
		integer sx = cx0 < cx1 ? 1 : -1
		integer sy = cy0 < cy1 ? 1 : -1

		// Parameter t as numerator (common denominator = adx*ady)
		integer tMaxX = ady
		integer tMaxY = adx

		integer tStepX = ady << 1
		integer tStepY = adx << 1

		// DDA can step through coordinates with no cell (e.g. corner of diamond board)
		Cell? c = Board.cellsXY[x]![y]
		if (c != null) push(cells, c!)

		while (x != to.x || y != to.y) {
			if (tMaxX < tMaxY) {
				x += sx
				tMaxX += tStepX
			} else {
				y += sy
				tMaxY += tStepY
			}
			c = Board.cellsXY[x]![y]
			if (c != null) push(cells, c!)
		}

		// Store in cache
		_losCache[key] = cells
		return cells
	}

	/*
	 * Get set of cast cells that would have LOS blocked by obstacle.
	 * Uses DDA line tracing - exact and efficient (no game API calls).
	 *
	 * @param castCells Potential cast cells for this item/enemy
	 * @param targetCell Where the enemy is (target of attack)
	 * @param obstacle Cell that might block LOS (swapped entity position)
	 * @return Set of cell IDs that are blocked, or null if none blocked
	 */
	static Set<integer>? _getBlockedCastCells(Array<Cell> castCells, Cell targetCell, Cell obstacle) {
		// Quick check: if obstacle is the target, nothing is blocked
		if (obstacle == targetCell) return null

		Set<integer> blocked = <>

		for (Cell c in castCells) {
			// Skip if cast cell is the obstacle itself
			if (c == obstacle) {
				setPut(blocked, c.id)
				continue
			}

			// Skip if cast cell is the target (no LOS needed)
			if (c == targetCell) continue

			// Trace LOS from cast cell to target, check if obstacle is on the line
			Array<Cell> losLine = _getCellsLineOfSight(c, targetCell)
			for (Cell lineCell in losLine) {
				if (lineCell == obstacle) {
					setPut(blocked, c.id)
					break
				}
			}
		}

		return setSize(blocked) > 0 ? blocked : null
	}

}
