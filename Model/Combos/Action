/*
 * Action réalisable d'une entité vers une autre
 */
class Action {
	public Cell from
	public Cell to
	public Item item
	public Consequences consequences
	public real? score
	public InversionCandidate? invCandidate = null  // Set for inversion actions only
	public RepottingCandidate? repCandidate = null // Set for repotting actions only
	public Set<Entity>? overrideTargets = null     // Bypass Targets.getTargets() for simulated positions

	constructor(Item item, Cell from, Cell to){
		this.item = item
		this.from = from
		this.to = to
		this.consequences = Consequences(this)
		this.score = this.consequences.getScore()
	}

	/*
	 * Shared snapshot constructor - uses pre-computed EffectSnapshot for effect data.
	 * More efficient when many actions share identical effects (same item + aimCell).
	 */
	constructor(Item item, Cell from, Cell to, EffectSnapshot snapshot){
		this.item = item
		this.from = from
		this.to = to
		this.consequences = Consequences.fromSnapshot(snapshot, this)
		this.score = this.consequences.getScore()
	}

	constructor(Action action, Consequences consequences){
		this.item = action.item
		this.from = action.from
		this.to = action.to
		this.invCandidate = action.invCandidate      // Preserve inversion candidate info
		this.repCandidate = action.repCandidate      // Preserve repotting candidate info
		this.overrideTargets = action.overrideTargets // Preserve simulated targets
		this.consequences = Consequences(this, consequences)
		this.score = this.consequences.getScore()
	}
	
	/*
	 * Format chaîne de caractères utilisée pour des tests / debugs.
	 */
	string string(){
		integer|string rounded = this.score != null ? round(this.score!) : "None"
		return "<Action score: "+rounded+" "+this.item.name+"|from:"+this.from.id+"|to:"+this.to.id+">"
	}
}