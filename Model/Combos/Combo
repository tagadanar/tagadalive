/*
 * Ensemble d'actions formant un combo
 * L'objet combo contient les dommages approximatifs calculé dans MapDanger::getPotentialCombo
 */
class Combo {
	Array<Action> actions = []
	Position? finalPosition = null  // End-of-turn position (best scored cell)
	real? score = null
	
	/*
	 * Ajout d'action dans l'ensemble d'actions du combo
	 * @param action Action a ajouter dans le combo
	 * @return true if action was added (improves score), false otherwise
	 */
	boolean add(Action action){
		// Validate usage limit
		if(this.getUsageCount(action.item) >= action.item.maxUse) return false

		Consequences currentCsq = this.getCurrentConsequences()
		real prevScore = currentCsq.score != null ? currentCsq.score! : 0.0
		Action actualized = Action(action, currentCsq)

		// Check score improvement (actualized.score is cumulative)
		if(actualized.score! > prevScore) {
			push(this.actions, actualized)
			return true
		}
		return false
	}

	/*
	 * Count how many times an item is used in this combo
	 */
	integer getUsageCount(Item item) {
		integer count = 0
		for (Action a in this.actions) {
			if (a.item == item) count++
		}
		return count
	}

	void addFinalPosition(Position position){
		this.finalPosition = position
	}
	
	/*
	 * Returns the combo's total score: last action's cumulative score + position score.
	 * Action scores are cumulative (each includes all previous effects), so we only need the last one.
	 */
	real? getScore(){
		if(this.score == null){
			// Last action's score is cumulative (includes all previous action effects)
			if(count(this.actions) > 0) {
				this.score = this.actions[count(this.actions) - 1].score!
			} else {
				this.score = 0.0  // Movement-only combo
			}
			this.score += this.finalPosition!.score
		}
		return this.score
	}
	
	/*
	 * retourne la cell où on serait si on jouait le combo en l'état
	 */
	Cell getCurrentCell(){
		Cell currentCell
		if(this.finalPosition) currentCell = this.finalPosition!.cell
		else if(count(this.actions)>0) {
			currentCell = actions[count(this.actions)-1].from
			// For self-cast actions, get actual position from consequences
			if(currentCell == Fight.selfCell) {
				currentCell = actions[count(this.actions)-1].consequences.currentCell
			}
		}
		else currentCell = Fight.self.cell
		return currentCell
	}
	
	/*
	 * retourne les MP restants après le combo
	 */
	integer getCurrentMP(){
		integer currentMP
		if(count(this.actions)>0) currentMP = actions[count(this.actions)-1].consequences.currentMP
		else currentMP = Fight.self.mp
		return currentMP
	}
	
	/*
	 * retourne la cell où on serait si on jouait le combo en l'état
	 */
	Consequences getCurrentConsequences(){
		// TODO une fois qu'on aura des conseq dans le placement final, handle here !
		if(count(this.actions)>0) return actions[count(this.actions)-1].consequences
		else return Consequences()
	}
	
	/*
	 * Find best empty cell for summoning (prefers cells far from enemies)
	 * Uses Targets.getCellsToUseItemOnCell which returns empty cells within range
	 */
	static Cell? findSummonCell(Item item) {
		Cell currentCell = Board.cells[getCell()!]!
		Map<Cell, integer>? enemyDistMap = MapPosition.getNearestEnemyPathDist()

		Cell? bestCell = null
		integer bestDist = -1

		// Get all valid empty cells within summon range (reuses existing targeting logic)
		Array<Cell> validCells = Targets.getCellsToUseItemOnCell(item, currentCell, [Fight.self.id])

		for (Cell cell in validCells) {
			integer enemyDist = 0
			if (enemyDistMap != null && enemyDistMap![cell] != null) {
				enemyDist = enemyDistMap![cell]!
			}

			if (enemyDist > bestDist) {
				bestDist = enemyDist
				bestCell = cell
			}
		}
		return bestCell
	}

	/*
	 * pour chaque action dans l'ensemble d'actions
	 * on se déplace a l'emplacement définis dans la génération de l'action et on éxécute l'Item sur la cible définis.
	 */
	void play(){
		// étape 1: je fais mes actions (skip summons - delayed to after positioning)
		for(Action action in this.actions){
			if (action.item.isSummon) continue
			if(action.from != Fight.selfCell){
				moveTowardCell(action.from.id)
				Benchmark.logMove(Fight.self.cell.id, action.from.id)
				Fight.self.cell = Board.cells[getCell()!]!
				// Skip action if we didn't reach the attack cell
				if(Fight.self.cell.id != action.from.id) {
					debugW("Skipping " + action.item.name + ": didn't reach c" + action.from.id + ", at c" + getCell())
					continue
				}
			}
			if(action.to == Fight.selfCell){
				action.item.useItemOnCell(Fight.self.cell)
				Benchmark.logBuff(action.item.name)
			} else {
				integer result = action.item.useItemOnCellWithResult(action.to)
				if(result < 0) {
					integer dist = getCellDistance(getCell()!, action.to.id)
					boolean los = lineOfSight(getCell()!, action.to.id, [])!
					debugW("Action failed: " + action.item.name + " from c" + getCell() + " to c" + action.to.id +
						" result=" + result + " dist=" + dist + " range=[" + action.item.minRange + "-" + action.item.maxRange +
						"] LOS=" + los + " TP=" + getTP())
					// Dump combo for debugging TP tracking issues
					debugW("Combo dump (Fight.self.tp was " + Fight.self.tp + "):")
					for (integer i = 0; i < count(this.actions); i++) {
						Action a = this.actions[i]
						debugW("  [" + i + "] " + a.item.name + " cost=" + a.item.cost + " csq.TP=" + a.consequences.currentTP)
					}
				}
				Benchmark.log(action.item.name + ">c" + action.to.id)
			}
		}
		// étape 2: je vais me planquer
		if(this.finalPosition){
			moveTowardCell(this.finalPosition!.cell.id)
			if(Fight.self.cell.id != getCell()){
				Benchmark.logMove(Fight.self.cell.id, getCell()!)
			}
		}
		// étape 2b: summon actions (after reaching final position)
		for (Action action in this.actions) {
			if (!action.item.isSummon) continue
			Cell? targetCell = Combo.findSummonCell(action.item)
			if (targetCell != null) {
				summon(action.item.id, targetCell!.id, function() {
					// Lightweight bulb AI: measure cost of each step
					integer t0 = getOperations()
					Fight.updateForSummon()  // Create bulb + update self + update positions
					integer t1 = getOperations()
					Board.updateForSummon()  // Rebuild entityCells (with updated positions)
					MapPosition._position = [:]  // Invalidate stale proximity cache (leek now in entityCells)
					MapPosition._hash_position = [:]
					integer t2 = getOperations()
					MapPath.refresh()        // Clear path cache
					integer t3 = getOperations()
					Fight.self.init()        // Now safe: Board.entityCells is updated
					integer t4 = getOperations()
					MapAction.refresh()      // Bulb's available actions
					integer t5 = getOperations()
					AI.getCombo().play()
					integer t6 = getOperations()

					// Calculate ops for each step
					integer opsUpdate = t1 - t0
					integer opsBoard = t2 - t1
					integer opsPath = t3 - t2
					integer opsInit = t4 - t3
					integer opsAction = t5 - t4
					integer opsAI = t6 - t5
					integer opsTotal = t6 - t0

					// Record ops to register for statistics
					// Format: "count,total,update,board,path,init,action,ai"
					string regKey = Entity.getBulbRegisterKey(Fight.self.extendedType)
					string? existing = getRegister(regKey)
					integer n = 1
					integer sumTotal = opsTotal
					integer sumUpdate = opsUpdate
					integer sumBoard = opsBoard
					integer sumPath = opsPath
					integer sumInit = opsInit
					integer sumAction = opsAction
					integer sumAI = opsAI
					if (existing != null) {
						Array<string> p = split(existing!, ",")
						n = number(p[0]) + 1
						sumTotal = number(p[1]) + opsTotal
						sumUpdate = number(p[2]) + opsUpdate
						sumBoard = number(p[3]) + opsBoard
						sumPath = number(p[4]) + opsPath
						sumInit = number(p[5]) + opsInit
						sumAction = number(p[6]) + opsAction
						sumAI = number(p[7]) + opsAI
					}
					setRegister(regKey, n + "," + sumTotal + "," + sumUpdate + "," + sumBoard + "," + sumPath + "," + sumInit + "," + sumAction + "," + sumAI)

					// Display mean cost of every step
					debug("BULB_STATS>" + regKey + ">n=" + n +
						">total=" + Benchmark.format(sumTotal / n) +
						">update=" + Benchmark.format(sumUpdate / n) +
						">board=" + Benchmark.format(sumBoard / n) +
						">path=" + Benchmark.format(sumPath / n) +
						">init=" + Benchmark.format(sumInit / n) +
						">action=" + Benchmark.format(sumAction / n) +
						">ai=" + Benchmark.format(sumAI / n))
					say("Salut, moi c'est fab")
				})
				Benchmark.log("SUMMON>" + action.item.name + ">c" + targetCell!.id)
			} else {
				debugW("No valid cell for summon: " + action.item.name)
			}
		}
		// étape 3: si il reste des TP, je prend en main une arme aléatoire
		if(getWeapon(Fight.self.id)==null) {
			Array<Item> weapons = []
			for (Item item in Fight.self.items) {
				if (item.isWeap) push(weapons, item)
			}
			if (count(weapons) > 0) {
				setWeapon(weapons[randInt(0, count(weapons) - 1)].id)
			}
		}
		// étape 4: si il reste des TP, je dis des trucs
		// todo pipotron
	}
	
	/*
	 * Format chaîne de caractères utilisée pour des tests / debugs.
	 */
	string(){
		string str= '<Combo: ['
		for(Action action in this.actions){
			str+= '\n'+action
		}
		str+= '\n'+this.finalPosition+']>'
		return str
	}
}
