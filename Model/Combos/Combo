/*
 * Ensemble d'actions formant un combo
 * L'objet combo contient les dommages approximatifs calculé dans MapDanger::getPotentialCombo
 */
class Combo {
	Array<Action> actions = []
	Position? finalPosition = null  // End-of-turn position (best scored cell)
	real? score = null
	
	/*
	 * Ajout d'action dans l'ensemble d'actions du combo
	 * @param action Action a ajouter dans le combo
	 * @return true if action was added (improves score), false otherwise
	 */
	boolean add(Action action){
		// Validate usage limit
		if(this.getUsageCount(action.item) >= action.item.maxUse) return false

		Consequences currentCsq = this.getCurrentConsequences()
		real prevScore = currentCsq.score != null ? currentCsq.score! : 0.0
		Action actualized = Action(action, currentCsq)

		// Check score improvement (actualized.score is cumulative)
		if(actualized.score! > prevScore) {
			push(this.actions, actualized)
			return true
		}
		return false
	}

	/*
	 * Count how many times an item is used in this combo
	 */
	integer getUsageCount(Item item) {
		integer count = 0
		for (Action a in this.actions) {
			if (a.item == item) count++
		}
		return count
	}
	
	void addFinalPosition(Position position){
		this.finalPosition = position
	}
	
	/*
	 * Returns the combo's total score: last action's cumulative score + position score.
	 * Action scores are cumulative (each includes all previous effects), so we only need the last one.
	 */
	real? getScore(){
		if(this.score == null){
			// Last action's score is cumulative (includes all previous action effects)
			if(count(this.actions) > 0) {
				this.score = this.actions[count(this.actions) - 1].score!
			} else {
				this.score = 0.0  // Movement-only combo
			}
			this.score += this.finalPosition!.score
		}
		return this.score
	}
	
	/*
	 * retourne la cell où on serait si on jouait le combo en l'état
	 */
	Cell getCurrentCell(){
		Cell currentCell
		if(this.finalPosition) currentCell = this.finalPosition!.cell
		else if(count(this.actions)>0) {
			currentCell = actions[count(this.actions)-1].from
			// For self-cast actions, get actual position from consequences
			if(currentCell == Fight.selfCell) {
				currentCell = actions[count(this.actions)-1].consequences.currentCell
			}
		}
		else currentCell = Fight.self.cell
		return currentCell
	}
	
	/*
	 * retourne les MP restants après le combo
	 */
	integer getCurrentMP(){
		integer currentMP
		if(count(this.actions)>0) currentMP = actions[count(this.actions)-1].consequences.currentMP
		else currentMP = Fight.self.mp
		return currentMP
	}
	
	/*
	 * retourne la cell où on serait si on jouait le combo en l'état
	 */
	Consequences getCurrentConsequences(){
		// TODO une fois qu'on aura des conseq dans le placement final, handle here !
		if(count(this.actions)>0) return actions[count(this.actions)-1].consequences
		else return Consequences()
	}
	
	/*
	 * pour chaque action dans l'ensemble d'actions
	 * on se déplace a l'emplacement définis dans la génération de l'action et on éxécute l'Item sur la cible définis.
	 */
	void play(){
		var startCell = getCell()

		// étape 1: je fais mes actions
		for(Action action in this.actions){
			if(action.from != Fight.selfCell){
				moveTowardCell(action.from.id)
				Benchmark.logMove(startCell, getCell())
				startCell = getCell()
				// Skip action if we didn't reach the attack cell
				if(getCell() != action.from.id) {
					debugW("Skipping " + action.item.name + ": didn't reach c" + action.from.id + ", at c" + getCell())
					continue
				}
			}
			if(action.to == Fight.selfCell){
				action.item.useItemOnCell(Board.getCell(getCell())!)
				Benchmark.logBuff(action.item.name)
			} else {
				integer result = action.item.useItemOnCellWithResult(action.to)
				if(result != USE_SUCCESS && result != USE_CRITICAL) {
					integer dist = getCellDistance(getCell(), action.to.id)
					boolean los = lineOfSight(getCell(), action.to.id, [])
					debugW("Action failed: " + action.item.name + " from c" + getCell() + " to c" + action.to.id +
						" result=" + result + " dist=" + dist + " range=[" + action.item.minRange + "-" + action.item.maxRange +
						"] LOS=" + los + " TP=" + getTP())
					// Dump combo for debugging TP tracking issues
					debugW("Combo dump (Fight.self.tp was " + Fight.self.tp + "):")
					for (integer i = 0; i < count(this.actions); i++) {
						Action a = this.actions[i]
						debugW("  [" + i + "] " + a.item.name + " cost=" + a.item.cost + " csq.TP=" + a.consequences.currentTP)
					}
				}
				Benchmark.log(action.item.name + ">c" + action.to.id)
			}
		}
		// étape 2: je vais me planquer
		if(this.finalPosition){
			moveTowardCell(this.finalPosition!.cell.id)
			if(getCell() != startCell){
				Benchmark.logMove(startCell, getCell())
			}
		}
		// étape 3: si il reste des TP, je prend en main une arme aléatoire
		if(getWeapon(Fight.self.id)==null) {
			Array<Item> weapons = []
			for (Item item in Fight.self.items) {
				if (item.isWeap) push(weapons, item)
			}
			if (count(weapons) > 0) {
				setWeapon(weapons[randInt(0, count(weapons) - 1)].id)
			}
		}
		// étape 4: si il reste des TP, je dis des trucs
		// todo pipotron
	}
	
	/*
	 * Format chaîne de caractères utilisée pour des tests / debugs.
	 */
	string(){
		string str= '<Combo: ['
		for(Action action in this.actions){
			str+= '\n'+action
		}
		str+= '\n'+this.finalPosition+']>'
		return str
	}
}
