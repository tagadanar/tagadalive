/*
 * Ensemble d'actions formant un combo
 * L'objet combo contient les dommages approximatifs calculé dans MapDanger::getPotentialCombo
 */
class Combo {
	Array<Action> actions = []
	Position? finalPosition = null  // End-of-turn position (best scored cell)
	real? score = null
	
	/*
	 * Ajout d'action dans l'ensemble d'actions du combo
	 * @param action Action a ajouter dans le combo
	 * @return true if action was added (improves score), false otherwise
	 */
	boolean add(Action action){
		// Validate usage limit
		if(this.getUsageCount(action.item) >= action.item.maxUse) return false

		Consequences currentCsq = this.getCurrentConsequences()
		real prevScore = currentCsq.score != null ? currentCsq.score! : 0.0
		Action actualized = Action(action, currentCsq)

		// Check score improvement (actualized.score is cumulative)
		if(actualized.score! > prevScore) {
			push(this.actions, actualized)
			return true
		}
		return false
	}

	/*
	 * Count how many times an item is used in this combo
	 */
	integer getUsageCount(Item item) {
		integer count = 0
		for (Action a in this.actions) {
			if (a.item == item) count++
		}
		return count
	}

	void addFinalPosition(Position position){
		this.finalPosition = position
	}
	
	/*
	 * Returns the combo's total score: last action's cumulative score + position score.
	 * Action scores are cumulative (each includes all previous effects), so we only need the last one.
	 */
	real? getScore(){
		if(this.score == null){
			// Last action's score is cumulative (includes all previous action effects)
			if(count(this.actions) > 0) {
				this.score = this.actions[count(this.actions) - 1].score!
			} else {
				this.score = 0.0  // Movement-only combo
			}
			this.score += this.finalPosition!.score
		}
		return this.score
	}
	
	/*
	 * retourne la cell où on serait si on jouait le combo en l'état
	 */
	Cell getCurrentCell(){
		Cell currentCell
		if(this.finalPosition) currentCell = this.finalPosition!.cell
		else if(count(this.actions)>0) {
			currentCell = actions[count(this.actions)-1].from
			// For self-cast actions, get actual position from consequences
			if(currentCell == Fight.selfCell) {
				currentCell = actions[count(this.actions)-1].consequences.currentCell
			}
		}
		else currentCell = Fight.self.cell
		return currentCell
	}
	
	/*
	 * retourne les MP restants après le combo
	 */
	integer getCurrentMP(){
		integer currentMP
		if(count(this.actions)>0) currentMP = actions[count(this.actions)-1].consequences.currentMP
		else currentMP = Fight.self.mp
		return currentMP
	}
	
	/*
	 * retourne la cell où on serait si on jouait le combo en l'état
	 */
	Consequences getCurrentConsequences(){
		// TODO une fois qu'on aura des conseq dans le placement final, handle here !
		if(count(this.actions)>0) return actions[count(this.actions)-1].consequences
		else return Consequences()
	}

	/*
	 * pour chaque action dans l'ensemble d'actions
	 * on se déplace a l'emplacement définis dans la génération de l'action et on éxécute l'Item sur la cible définis.
	 */
	void play(){
		// Collect delayed summons (defensive bulbs spawned after final position)
		Array<Action> delayedSummons = []

		// étape 1: je fais mes actions
		for(Action action in this.actions){
			// Move to attack position if needed
			if(action.from != Fight.selfCell){
				moveTowardCell(action.from.id)
				Benchmark.logMove(Fight.self.cell.id, action.from.id)
				Fight.self.cell = Board.cells[getCell()!]!
				// Skip action if we didn't reach the attack cell
				if(Fight.self.cell.id != action.from.id) {
					debugW("Skipping " + action.item.name + ": didn't reach c" + action.from.id + ", at c" + getCell())
					continue
				}
			}

			// Handle resurrection BEFORE summons (resurrection has isSummon=true but needs special API)
			if (action.item.id == CHIP_RESURRECTION) {
				if (Fight.resurrectTargetId == null) {
					debugW("Resurrect action but Fight.resurrectTargetId is null!")
					continue
				}
				integer resResult = resurrect(Fight.resurrectTargetId!, action.to.id)
				if (resResult <= 0) {
					debugW("Resurrect failed: entity=" + Fight.resurrectTargetId! + " cell=" + action.to.id + " result=" + resResult)
				}
				Benchmark.log("RESURRECT>entity" + Fight.resurrectTargetId! + ">c" + action.to.id)
				Fight.resurrectTargetId = null  // Clear after use
				continue
			}

			// Handle summons
			if (action.item.isSummon) {
				// Delayed summon: to == Fight.selfCell means spawn after final position
				if (action.to == Fight.selfCell) {
					push(delayedSummons, action)
					continue
				}

				// Normal summon: spawn immediately at target cell
				summon(action.item.id, action.to.id, BulbGreedy.runTurn)
				Benchmark.log("SUMMON>" + action.item.name + ">c" + action.to.id)
				continue
			}

			// Regular actions
			if(action.to == Fight.selfCell){
				// Use getCell() for current position (Fight.self.cell is cached at turn start,
				// doesn't update after inversion swaps positions)
				action.item.useItemOnCell(Board.cells[getCell()!]!)
				Benchmark.logBuff(action.item.name)
			} else {
				integer result = action.item.useItemOnCellWithResult(action.to)
				if(result < 0) {
					integer dist = getCellDistance(getCell()!, action.to.id)
					boolean los = lineOfSight(getCell()!, action.to.id, [])!
					debugW("Action failed: " + action.item.name + " from c" + getCell() + " to c" + action.to.id +
						" result=" + result + " dist=" + dist + " range=[" + action.item.minRange + "-" + action.item.maxRange +
						"] LOS=" + los + " TP=" + getTP())
					// Dump combo for debugging TP tracking issues
					debugW("Combo dump (Fight.self.tp was " + Fight.self.tp + "):")
					for (integer i = 0; i < count(this.actions); i++) {
						Action a = this.actions[i]
						debugW("  [" + i + "] " + a.item.name + " cost=" + a.item.cost + " csq.TP=" + a.consequences.currentTP)
					}
				}
				Benchmark.log(action.item.name + ">c" + action.to.id)
			}
		}

		// étape 2: je vais me planquer
		if(this.finalPosition){
			moveTowardCell(this.finalPosition!.cell.id)
			if(Fight.self.cell.id != getCell()){
				Benchmark.logMove(Fight.self.cell.id, getCell()!)
			}
		}

		// étape 2.5: execute delayed summons at farthest cell from final position
		Cell currentCell = Board.cells[getCell()!]!
		for (Action delayedAction in delayedSummons) {
			Cell? spawnCell = MapSummon.getFarthestSpawnCell(delayedAction.item, currentCell)
			if (spawnCell == null) {
				debugW("No valid spawn cell for delayed summon: " + delayedAction.item.name)
				continue
			}

			summon(delayedAction.item.id, spawnCell!.id, BulbGreedy.runTurn)
			Benchmark.log("DELAYED_SUMMON>" + delayedAction.item.name + ">c" + spawnCell!.id)
		}

		// étape 3: si il reste des TP, je prend en main une arme aléatoire
		if(getWeapon(Fight.self.id)==null) {
			Array<Item> weapons = []
			for (Item item in Fight.self.items) {
				if (item.isWeap) push(weapons, item)
			}
			if (count(weapons) > 0) {
				setWeapon(weapons[randInt(0, count(weapons) - 1)].id)
			}
		}
		// étape 4: si il reste des TP, je dis des trucs
		// todo pipotron
	}
	
	/*
	 * Format chaîne de caractères utilisée pour des tests / debugs.
	 */
	string(){
		string str= '<Combo: ['
		for(Action action in this.actions){
			str+= '\n'+action
		}
		str+= '\n'+this.finalPosition+']>'
		return str
	}
}
