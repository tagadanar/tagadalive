/*
 * Consequences - Simulated state changes from applying actions.
 *
 * OPTIMIZATION: Copy-on-Write (COW) pattern
 * Instead of deep cloning all state when chaining actions, we:
 * 1. Reference the parent Consequences
 * 2. Only clone an entity's data when we first modify it
 * 3. Reads check local data first, then walk the parent chain
 *
 * This reduces clone operations from O(E×S) to O(e×s) per action,
 * where E=all entities, S=all stats, e=modified entities, s=their stats.
 * Typical action modifies 1-2 entities, so ~10x reduction in cloning.
 */
class Consequences {
	// ════════════════════════════════════════════════════════════════════════
	// COPY-ON-WRITE DATA STRUCTURES
	// ════════════════════════════════════════════════════════════════════════

	// Parent reference for COW (null = root node)
	Consequences? _parent = null

	// Local modifications only - null means "inherited from parent"
	// Allocated lazily on first write to an entity
	Map<Entity, Map<integer, integer>> _alterations = [:]
	Map<Entity, Map<Item, Array<EffectOverTime>>> _altEffects = [:]
	Map<Entity, Map<integer, integer>> _effectTypeAlterations = [:]
	Set<Entity> _killed = <>

	// Track which entities have local data (for efficient iteration)
	Map<Entity, boolean> _localEntities = [:]

	// ════════════════════════════════════════════════════════════════════════
	// STANDARD FIELDS
	// ════════════════════════════════════════════════════════════════════════

	real? score = null
	boolean isAlteringDanger = false
	integer hashcode = 17
	Set<Entity> targets = <>
	Cell currentCell
	integer currentMP
	integer currentTP
	Item? currentWeapon           // Equipped weapon (for switch cost tracking)
	private integer _boostMP_before = 0

	// Effect value tracking for STEAL_LIFE (tracks total value of preceding effect)
	integer lastEffectTotalValue = 0
	integer _currentEffectTotal = 0

	// Conservative adjustment for self TP/MP buffs (min - avg, typically negative)
	// Used to track resources conservatively while scoring optimistically
	integer selfTPConservativeAdjustment = 0
	integer selfMPConservativeAdjustment = 0

	// Shared effect snapshot (null = local mode, set = shared mode)
	// In shared mode, effect data comes from _shared, local maps are empty
	EffectSnapshot? _shared = null

	// Pending bulbs from summon actions in this consequence chain
	Map<Cell, PendingBulb> pendingBulbs = [:]

	// Actions invalidated by inversion (targets moved, would hit self now)
	Set<Action>? invalidatedActions = null

	// Position swap tracking for inversion (COW - reference parent, clone on write)
	Set<Cell> _newObstacles = <>    // Cells blocked by swapped entities
	Set<Cell> _freedCells = <>       // Cells freed (we moved there, now walkable)

	// Inversion candidate (set after Action construction for later reference)
	InversionCandidate? invCandidate = null

	// ════════════════════════════════════════════════════════════════════════
	// EFFECT VALUE TRACKING
	// ════════════════════════════════════════════════════════════════════════

	/*
	 * Called before processing each effect to save accumulated value and reset
	 */
	void nextEffect() {
		this.lastEffectTotalValue = this._currentEffectTotal
		this._currentEffectTotal = 0
	}

	/*
	 * Called by damage/nova handlers to track their applied value
	 */
	void addEffectValue(integer value) {
		this._currentEffectTotal += value
	}

	// ════════════════════════════════════════════════════════════════════════
	// CONSTRUCTORS
	// ════════════════════════════════════════════════════════════════════════

	/*
	 * Empty constructor for MCTS root node (no previous actions)
	 */
	constructor() {
		this.currentCell = Fight.self.cell
		this.currentMP = Fight.self.mp
		this.currentTP = Fight.self.tp
		this.currentWeapon = Fight.self.getWeaponInHand()
		this.score = 0.0
	}

	/*
	 * Constructor from action only (initial pool creation)
	 */
	constructor(Action action){
		Benchmark.start("Consequences")
		this.currentCell = Fight.self.cell
		this.currentMP = Fight.self.mp
		this.currentTP = Fight.self.tp
		this.currentWeapon = Fight.self.getWeaponInHand()
		this.score = 0.0  // Must initialize before construct() modifies it
		construct(action, false)  // Don't warn during pool creation (extended cells are valid)
		Benchmark.stop("Consequences")
	}

	/*
	 * OPTIMIZED: Copy-on-write constructor
	 * Instead of deep cloning all state, reference parent and clone lazily.
	 */
	constructor(Action action, Consequences consequences){
		Benchmark.start("Consequences.fromConseq")

		// Copy scalar state
		this.currentCell = consequences.currentCell
		this.currentMP = consequences.currentMP
		this.currentTP = consequences.currentTP
		this.currentWeapon = consequences.currentWeapon
		this.hashcode = consequences.hashcode
		this.score = consequences.score != null ? consequences.score : 0.0

		// COPY-ON-WRITE: Handle different parent modes
		if (consequences._shared != null) {
			// Parent uses shared snapshot - must materialize (snapshot is immutable)
			this._parent = null
			this._alterations = clone(consequences._shared!.alterations, 2) as Map<Entity, Map<integer, integer>>
			this._altEffects = clone(consequences._shared!.altEffects, 3) as Map<Entity, Map<Item, Array<EffectOverTime>>>
			this._effectTypeAlterations = clone(consequences._shared!.effectTypeAlterations, 2) as Map<Entity, Map<integer, integer>>
			this._killed = clone(consequences._shared!.killed) as Set<Entity>
			// Mark all entities as local (since we materialized)
			for (Entity e : Map<integer, integer> _ in this._alterations) {
				this._localEntities[e] = true
			}
		} else {
			// Parent is already in COW mode - just reference it
			this._parent = consequences
			// Local maps start empty - populated on first write via COW
		}

		// pendingBulbs still need cloning (modified in-place, rare)
		this.pendingBulbs = [:]
		for (Cell c : PendingBulb bulb in consequences.pendingBulbs) {
			this.pendingBulbs[c] = bulb.clone()
		}

		// Propagate invalidated actions through chain (set once, persists)
		this.invalidatedActions = consequences.invalidatedActions

		// Propagate position swap data (reference - clone on write)
		this._newObstacles = consequences._newObstacles
		this._freedCells = consequences._freedCells

		construct(action, true)  // Warn during combo building (catches actual bugs)
		Benchmark.stop("Consequences.fromConseq")
	}

	/*
	 * Static factory: creates Consequences from pre-computed EffectSnapshot.
	 * Only applies movement costs; effects come from the shared snapshot.
	 * Used for initial action pool creation where many actions share identical effects.
	 */
	static Consequences fromSnapshot(EffectSnapshot snapshot, Action action) {
		Benchmark.start("Consequences.shared")
		Consequences c = new Consequences()
		c._shared = snapshot
		c.targets = snapshot.targets
		c.score = snapshot.effectScore
		c.isAlteringDanger = snapshot.isAlteringDanger
		c.hashcode = snapshot.hashcode

		// Apply movement cost only (effects already computed in snapshot)
		c.constructMovementOnly(action)

		// Cooldown penalty (pre-computed in snapshot)
		c.score -= snapshot.opportunityCost
		Benchmark.stop("Consequences.shared")
		return c
	}

	// ════════════════════════════════════════════════════════════════════════
	// CONSTRUCT METHODS
	// ════════════════════════════════════════════════════════════════════════

	construct(Action action, boolean warnOnUnreachable){
		// Build ignoreCells: our starting cell + cells of killed entities (can path through kills)
		// Also include freed cells from position swaps (e.g., after inversion)
		Set<Cell> ignoreCells = clone(Fight.self.cellsToIgnore) as Set<Cell>
		// Use COW-aware iteration for killed entities
		this.appendKilledCells(ignoreCells)
		this.appendFreedCells(ignoreCells)

		Map<Cell, integer> reachableCells = MapPath.getCachedReachableCells(this.currentCell, this.currentMP, ignoreCells, this._newObstacles)

		// Movement to action cell
		if(action.from != Fight.selfCell){
			// Skip reachability check if we're already at the target cell
			if(action.from != this.currentCell) {
				if(reachableCells[action.from] != null) {
					integer moveCost = reachableCells[action.from]!
					if(warnOnUnreachable && moveCost > 0 && moveCost > max(0, this.currentMP)) {
						debugW('Impossible action: move cost ' + moveCost + ' > effective MP ' + max(0, this.currentMP) + '\n' + action + '\n' + this)
					}
					this.currentMP = this.currentMP - moveCost
				} else if(warnOnUnreachable) {
					debugW('Impossible action: unreachable cell !!\n'+action+'\n'+this)
				}
			}
			this.currentCell = action.from
		}

		// TP cost
		this.currentTP -= action.item.cost

		// Weapon switch cost
		if (action.item.isWeap && action.item != this.currentWeapon) {
			this.currentTP -= 1
		}
		if (action.item.isWeap) {
			this.currentWeapon = action.item
		}

		// Track score before effects (for opportunity cost calculation)
		real scoreBefore = this.score != null ? this.score! : 0.0

		// Track MP/TP boosts before applying effects
		integer? boostMPbefore = this.getAlteration(Fight.self, Stats.MP)
		integer? boostTPbefore = this.getAlteration(Fight.self, Stats.TP)

		// Reset conservative adjustments for this action
		this.selfTPConservativeAdjustment = 0
		this.selfMPConservativeAdjustment = 0

		// Apply effects
		// Pass currentCell for self-cast AoE (combo may have moved us)
		// Use overrideTargets for simulated positions (e.g., post-inversion actions)
		if (action.overrideTargets != null) {
			this.targets = action.overrideTargets!
		} else {
			this.targets = Targets.getTargets(action, this.currentCell)
		}
		Cell aoeCenterCell = (action.to == Fight.selfCell) ? this.currentCell : action.to

		for (ItemEffect effect in action.item.effects) {
			this.nextEffect()

			if (effect.modifCaster) {
				// For AOE items, caster still gets distance-based ratio (not always 1.0)
				real ratio = 1.0
				if (action.item.isAOE) {
					ratio = 1 - (0.2 * getCellDistance(aoeCenterCell.id, this.currentCell.id))
				}
				this.updateConsequences(effect, Fight.self, Fight.self, ratio)
				continue
			}

			if (effect.type == EFFECT_SUMMON) {
				this.score += EffectHandlers.summon(effect.item, Fight.self.level, action.to)

				BulbProfile? profile = MapSummon.PROFILES[effect.item.id]
				if (profile != null) {
					BulbStats stats = profile!.computeStats(Fight.self.level)
					Entity? target = MapSummon.getTargetForCell(effect.item.id, action.to)
					Array<Item> chips = MapSummon.getOffensiveChips(profile!.bulbType)

					if (target != null && count(chips) > 0) {
						real baseDmg = MapSummon._calcKnapsackDamageForEnemy(stats, chips, target!)
						real baseDmgScore = MapSummon.computeDamageScore(baseDmg, target!)
						this.pendingBulbs[action.to] = PendingBulb(stats, target!, chips, profile!.bulbType, baseDmgScore)
					} else {
						this.pendingBulbs[action.to] = PendingBulb(stats, Fight.self, [], profile!.bulbType, 0)
					}
				}
				continue
			}

			for (Entity target in this.targets) {
				if (this.isKilled(target)) continue
				// For overrideTargets (simulated positions), use action.to as target cell
				// Normal case: use target's actual cell (or currentCell for self)
				integer targetCellId
				if (action.overrideTargets != null && target != Fight.self) {
					targetCellId = action.to.id  // Simulated position
				} else {
					targetCellId = (target == Fight.self) ? this.currentCell.id : target.cell.id
				}
				real ratioDmg = action.item.isAOE ? 1-(0.2*getCellDistance(aoeCenterCell.id, targetCellId)) : 1.0
				if (ratioDmg <= 0) {
					debugE('Bug in Consequences: ratioDmg<=0 for target ' + target + ' at cell ' + targetCellId)
					debugE(action)
					continue
				}
				this.updateConsequences(effect, Fight.self, target, ratioDmg)
			}

			if (setSize(this.targets) == 0 && this.pendingBulbs[aoeCenterCell] != null) {
				this.handlePendingBulbBuff(effect, aoeCenterCell)
			}
		}

		// Apply MP/TP boost changes (with conservative adjustment for self buffs)
		integer? boostMP = this.getAlteration(Fight.self, Stats.MP)
		if (boostMP != boostMPbefore || this.selfMPConservativeAdjustment != 0) {
			this.currentMP += (boostMP - boostMPbefore) + this.selfMPConservativeAdjustment
		}

		integer? boostTP = this.getAlteration(Fight.self, Stats.TP)
		if (boostTP != boostTPbefore || this.selfTPConservativeAdjustment != 0) {
			this.currentTP += (boostTP - boostTPbefore) + this.selfTPConservativeAdjustment
		}

		// Cooldown penalty (pass only current action's effect score, not cumulative)
		real currentActionScore = this.score! - scoreBefore
		this.score -= ScoringModifiers.getOpportunityCost(action.item, action.to, currentActionScore)
	}

	/*
	 * Movement-only construction for shared snapshot mode.
	 * Note: Cache may contain cells beyond MP, must verify distance.
	 */
	void constructMovementOnly(Action action) {
		// Build ignoreCells with freed cells from position swaps
		Set<Cell> ignoreCells = Fight.self.cellsToIgnore
		if (setSize(this._freedCells) > 0) {
			ignoreCells = clone(ignoreCells) as Set<Cell>
			this.appendFreedCells(ignoreCells)
		}
		Map<Cell, integer> reachableCells = MapPath.getCachedReachableCells(this.currentCell, this.currentMP, ignoreCells, this._newObstacles)

		if (action.from != Fight.selfCell) {
			integer? moveCost = reachableCells[action.from]
			if (moveCost != null && moveCost! <= this.currentMP) {
				this.currentMP = this.currentMP - moveCost!
			}
			this.currentCell = action.from
		}

		this.currentTP -= action.item.cost

		if (action.item.isWeap && action.item != this.currentWeapon) {
			this.currentTP -= 1
		}
		if (action.item.isWeap) {
			this.currentWeapon = action.item
		}

		// Apply MP/TP boost from snapshot (with conservative adjustment for self buffs)
		integer? boostMP = this._shared!.getAlteration(Fight.self, Stats.MP)
		integer mpDelta = (boostMP != null ? boostMP! : 0) + this._shared!.selfMPConservativeAdjustment
		if (mpDelta != 0) this.currentMP += mpDelta

		integer? boostTP = this._shared!.getAlteration(Fight.self, Stats.TP)
		integer tpDelta = (boostTP != null ? boostTP! : 0) + this._shared!.selfTPConservativeAdjustment
		if (tpDelta != 0) this.currentTP += tpDelta
	}

	// ════════════════════════════════════════════════════════════════════════
	// COPY-ON-WRITE ADD METHODS
	// ════════════════════════════════════════════════════════════════════════

	/*
	 * Add alteration with copy-on-write semantics.
	 * Only clones the entity's data on first modification.
	 */
	void add(Entity entity, integer key, EffectOverTime|integer effect){
		// COW: Materialize this entity's data if not already local
		if (!this._localEntities[entity]) {
			this._materializeEntity(entity)
		}

		boolean isOverTime = effect instanceof EffectOverTime
		integer value = isOverTime ? (effect as EffectOverTime).value : effect as integer

		if(isOverTime){
			if(!_altEffects[entity]) _altEffects[entity] = [:]
			Item item = (effect as EffectOverTime).item
			if(!_altEffects[entity]![item]) _altEffects[entity]![item] = []
			push(_altEffects[entity]![item]!, (effect as EffectOverTime))
		}

		_alterations[entity]![key] += value

		// Update danger flags and hashcode
		if(entity==Fight.self && (
			   key==Stats.HP
			|| key==Stats.ABSSHIELD
			|| key==Stats.RELSHIELD
			|| key==Stats.DEBUFF)){
				this.isAlteringDanger=true
				this.hashcode = 31 * this.hashcode + (value|0)
		} else if(!entity.isFriend && (
			   key==Stats.DEBUFF
			|| key==Stats.STR
			|| key==Stats.TP
			|| key==Stats.MP)){
				this.isAlteringDanger=true
				this.hashcode = 31 * this.hashcode + entity.id
				this.hashcode = 31 * this.hashcode + (value|0)
		}

		// Score update
		real coef = Scoring.getDynamicCoef(entity, key, this)
		real scoreDelta = value * coef
		if(!isOverTime) this.score += scoreDelta
		else this.score += scoreDelta * ScoringConfig.offensive_duration_mitigation[(effect as EffectOverTime).duration]!
	}

	/*
	 * Add kill with copy-on-write semantics.
	 */
	void addKill(Entity entity){
		this.isAlteringDanger=true
		this.hashcode = 31 * this.hashcode + entity.id

		// Add to local killed map (no need to clone - kills don't override)
		setPut(this._killed, entity)

		this.score+= ScoringConfig.KILL_VALUE * Scoring.getDynamicCoef(entity, Stats.KILL, this)

		// Inline passives
		Map<integer, real> passives = Fight.self.passives
		if(passives[EFFECT_KILL_TO_TP]) {
			integer tpGain = round(passives[EFFECT_KILL_TO_TP]!)
			if(tpGain > 0) this.add(Fight.self, Stats.TP, tpGain)
		}
		if(entity.entityType == ENTITY_CHEST) {
			this.add(Fight.self, Stats.PWR, Fight.chestPwrGained[entity.name]!)
		}
		if(Fight.isBattleRoyale) {
			integer basePwr = entity.isBulb ? 2 : 10
			integer pwrGain = basePwr + round(entity.pwr * 0.5)
			this.add(Fight.self, Stats.PWR, pwrGain)
		}
	}

	/*
	 * Add effect type alteration with COW.
	 */
	void addEffectTypeAlteration(Entity entity, integer effectType, integer value){
		// COW: Materialize if needed
		if(!_effectTypeAlterations[entity]) {
			// Check if parent has data to copy
			Map<integer, integer>? parentData = this._getParentEffectTypeMap(entity)
			if (parentData != null) {
				_effectTypeAlterations[entity] = clone(parentData) as Map<integer, integer>
			} else {
				_effectTypeAlterations[entity] = [:]
			}
			this._localEntities[entity] = true
		}
		_effectTypeAlterations[entity]![effectType] += value
	}

	// ════════════════════════════════════════════════════════════════════════
	// COPY-ON-WRITE READ METHODS
	// ════════════════════════════════════════════════════════════════════════

	/*
	 * Get alteration value, walking parent chain if needed.
	 */
	integer? getAlteration(Entity entity, integer key){
		// Check shared mode first
		if (_shared != null) return _shared!.getAlteration(entity, key)

		// Check local data
		if(_alterations[entity] != null) {
			return _alterations[entity]![key]
		}

		// Walk parent chain
		if (_parent != null) {
			return _parent!.getAlteration(entity, key)
		}

		return null
	}

	/*
	 * Check if entity is killed, walking parent chain.
	 */
	boolean isKilled(Entity entity){
		if (_shared != null) return _shared!.isKilled(entity)

		// Check local kills
		if (setContains(this._killed, entity)) return true

		// Walk parent chain
		if (this._parent != null) {
			return this._parent!.isKilled(entity)
		}

		return false
	}

	/*
	 * Get effect type alteration, walking parent chain.
	 */
	integer getEffectTypeAlteration(Entity entity, integer effectType){
		if (_shared != null) return _shared!.getEffectTypeAlteration(entity, effectType)

		// Check local data
		if(_effectTypeAlterations[entity] != null) {
			integer? local = _effectTypeAlterations[entity]![effectType]
			if (local != null) return local!
		}

		// Walk parent chain
		if (_parent != null) {
			return _parent!.getEffectTypeAlteration(entity, effectType)
		}

		return 0
	}

	/*
	 * Get all alterations (materializes full map for iteration).
	 * Note: This is called rarely (mainly for debug output).
	 */
	Map<Entity, Map<integer, integer>> getAlterations(){
		if (_shared != null) return _shared!.alterations
		return this._materializeAllAlterations()
	}

	/*
	 * Get existing effect from same item on entity.
	 * Walks parent chain for _altEffects.
	 */
	EffectOverTime? getExistingItemEffect(Entity entity, Item item) {
		if (_shared != null) {
			if (_shared!.altEffects[entity] && _shared!.altEffects[entity]![item]) {
				Array<EffectOverTime> effects = _shared!.altEffects[entity]![item]!
				return effects[count(effects) - 1]
			}
		} else {
			// Check local first
			if (_altEffects[entity] && _altEffects[entity]![item]) {
				Array<EffectOverTime> effects = _altEffects[entity]![item]!
				return effects[count(effects) - 1]
			}
			// Walk parent chain
			if (_parent != null) {
				return _parent!.getExistingItemEffect(entity, item)
			}
		}
		// Check turn-start effects
		return entity.items_effectOverTime[item] ? entity.items_effectOverTime[item]![0] : null
	}

	/*
	 * Check if entity has any altEffects (simulated effects from combo).
	 * Walks parent chain.
	 */
	boolean hasAltEffects(Entity entity) {
		if (_shared != null) {
			return _shared!.altEffects[entity] != null
		}
		if (_altEffects[entity] != null) return true
		if (_parent != null) return _parent!.hasAltEffects(entity)
		return false
	}

	/*
	 * Get materialized altEffects for an entity (for iteration).
	 * Returns null if entity has no effects.
	 * Used by DebuffEffects for Liberation.
	 */
	Map<Item, Array<EffectOverTime>>? getEntityAltEffects(Entity entity) {
		if (_shared != null) {
			return _shared!.altEffects[entity]
		}
		// Need to merge local + parent chain
		return this._materializeEntityAltEffects(entity)
	}

	/*
	 * Ensure altEffects entry exists for entity+item (for pre-allocation before iteration).
	 * Used by DebuffEffects to avoid ConcurrentModificationException.
	 */
	void ensureAltEffectsEntry(Entity entity, Item item) {
		if (!_altEffects[entity]) _altEffects[entity] = [:]
		if (!_altEffects[entity]![item]) _altEffects[entity]![item] = []
	}

	/*
	 * Materialize altEffects for a single entity from parent chain.
	 */
	private Map<Item, Array<EffectOverTime>>? _materializeEntityAltEffects(Entity entity) {
		Map<Item, Array<EffectOverTime>>? result = null

		// Get from parent chain first
		if (_parent != null) {
			result = _parent!._materializeEntityAltEffects(entity)
		}

		// Merge local data
		if (_altEffects[entity] != null) {
			if (result == null) {
				// Clone to prevent accidental mutations of parent data
				result = clone(_altEffects[entity], 2) as Map<Item, Array<EffectOverTime>>
			} else {
				// Merge - local takes precedence for same item
				for (Item item : Array<EffectOverTime> effects in _altEffects[entity]!) {
					result![item] = effects
				}
			}
		}

		return result
	}

	// ════════════════════════════════════════════════════════════════════════
	// COW HELPER METHODS
	// ════════════════════════════════════════════════════════════════════════

	/*
	 * Materialize an entity's data from parent chain (COW clone).
	 * Called on first write to an entity.
	 */
	private void _materializeEntity(Entity entity) {
		// Get alterations from parent chain
		Map<integer, integer>? parentAlts = this._getParentAlterationMap(entity)
		if (parentAlts != null) {
			_alterations[entity] = clone(parentAlts) as Map<integer, integer>
		} else {
			_alterations[entity] = [:]
		}

		// Get altEffects from parent chain
		Map<Item, Array<EffectOverTime>>? parentEffects = this._getParentAltEffectsMap(entity)
		if (parentEffects != null) {
			_altEffects[entity] = clone(parentEffects, 2) as Map<Item, Array<EffectOverTime>>
		}
		// Note: _altEffects[entity] may remain null if no effects exist

		_localEntities[entity] = true
	}

	/*
	 * Get parent's alteration map for an entity.
	 */
	private Map<integer, integer>? _getParentAlterationMap(Entity entity) {
		if (_parent != null) {
			// Check parent's local data first
			if (_parent!._alterations[entity] != null) {
				return _parent!._alterations[entity]
			}
			// Recurse up chain
			return _parent!._getParentAlterationMap(entity)
		}
		return null
	}

	/*
	 * Get parent's altEffects map for an entity.
	 */
	private Map<Item, Array<EffectOverTime>>? _getParentAltEffectsMap(Entity entity) {
		if (_parent != null) {
			if (_parent!._altEffects[entity] != null) {
				return _parent!._altEffects[entity]
			}
			return _parent!._getParentAltEffectsMap(entity)
		}
		return null
	}

	/*
	 * Get parent's effectTypeAlterations map for an entity.
	 */
	private Map<integer, integer>? _getParentEffectTypeMap(Entity entity) {
		if (_parent != null) {
			if (_parent!._effectTypeAlterations[entity] != null) {
				return _parent!._effectTypeAlterations[entity]
			}
			return _parent!._getParentEffectTypeMap(entity)
		}
		return null
	}

	/*
	 * Append killed entity cells to array (walks parent chain).
	 * Public for use by ComboBuilder.buildIgnoreCells().
	 */
	void appendKilledCells(Set<Cell> cells) {
		// Add local kills
		for (Entity e in this._killed) {
			setPut(cells, e.cell)
		}
		// Walk parent chain
		if (_parent != null) {
			_parent!.appendKilledCells(cells)
		}
	}

	/*
	 * Append freed cells from position swaps (e.g., after inversion).
	 * These cells are now walkable because we moved there.
	 */
	void appendFreedCells(Set<Cell> cells) {
		for (Cell c in this._freedCells) {
			setPut(cells, c)
		}
	}

	/*
	 * Add a new obstacle cell (COW - clones on first write).
	 * Used when an entity moves to a cell during combo simulation.
	 */
	void addNewObstacle(Cell cell) {
		if (setContains(this._newObstacles, cell)) return;
		this._newObstacles = clone(this._newObstacles) as Set<Cell>
		setPut(this._newObstacles, cell)
	}

	/*
	 * Add a freed cell (COW - clones on first write).
	 * Used when we move to a cell during combo simulation (it becomes walkable).
	 */
	void addFreedCell(Cell cell) {
		if (setContains(this._freedCells, cell)) return;
		this._freedCells = clone(this._freedCells) as Set<Cell>
		setPut(this._freedCells, cell)
	}

	/*
	 * Materialize full alterations map (for iteration/debug).
	 */
	private Map<Entity, Map<integer, integer>> _materializeAllAlterations() {
		Map<Entity, Map<integer, integer>> result = [:]

		// Collect from parent chain first (bottom-up)
		if (_parent != null) {
			result = _parent!._materializeAllAlterations()
		}

		// Apply local modifications (overwrites parent data for same entity)
		for (Entity e : Map<integer, integer> alts in _alterations) {
			result[e] = alts
		}

		return result
	}

	// ════════════════════════════════════════════════════════════════════════
	// UNIFIED INTERFACE (for duck-typed EffectHandlers)
	// ════════════════════════════════════════════════════════════════════════

	integer getHP(Entity entity) {
		integer? hpDelta = this.getAlteration(entity, Stats.HP)
		return entity.life + (hpDelta != null ? hpDelta! : 0)
	}

	integer getHPMissing(Entity entity) {
		integer? hpMaxDelta = this.getAlteration(entity, Stats.HPMAX)
		integer currentMax = entity.totalLife + (hpMaxDelta != null ? hpMaxDelta! : 0)
		return currentMax - this.getHP(entity)
	}

	void addRawEnemyDamage(real value) {
		// No-op in Consequences - only tracked in EffectSnapshot
	}

	real? getScore(){
		return this.score
	}

	// ════════════════════════════════════════════════════════════════════════
	// PENDING BULB HANDLING
	// ════════════════════════════════════════════════════════════════════════

	void handlePendingBulbBuff(ItemEffect effect, Cell cell) {
		PendingBulb bulb = this.pendingBulbs[cell]!

		integer snc = Fight.self.getCurrentSnc(this)
		integer rst = Fight.self.getCurrentRst(this)
		integer wsd = Fight.self.getCurrentWsd(this)

		boolean isOffensive = false
		integer defValue = 0
		integer defStat = 0

		// OFFENSIVE BUFFS
		if (effect.type == EFFECT_BUFF_STRENGTH) {
			bulb.stats.str += EffectCalc.scaledBuff(effect.avg, snc, 1.0)
			isOffensive = true
		} else if (effect.type == EFFECT_RAW_BUFF_STRENGTH) {
			bulb.stats.str += EffectCalc.rawBuff(effect.avg, 1.0)
			isOffensive = true
		} else if (effect.type == EFFECT_BUFF_TP) {
			bulb.stats.tp += EffectCalc.scaledBuff(effect.avg, snc, 1.0)
			isOffensive = true
		} else if (effect.type == EFFECT_RAW_BUFF_TP) {
			bulb.stats.tp += EffectCalc.rawBuff(effect.avg, 1.0)
			isOffensive = true
		} else if (effect.type == EFFECT_BUFF_MP) {
			bulb.stats.mp += EffectCalc.scaledBuff(effect.avg, snc, 1.0)
			isOffensive = true
		} else if (effect.type == EFFECT_RAW_BUFF_MP) {
			bulb.stats.mp += EffectCalc.rawBuff(effect.avg, 1.0)
			isOffensive = true
		} else if (effect.type == EFFECT_BUFF_AGILITY) {
			bulb.stats.agi += EffectCalc.scaledBuff(effect.avg, snc, 1.0)
			isOffensive = true
		} else if (effect.type == EFFECT_RAW_BUFF_AGILITY) {
			bulb.stats.agi += EffectCalc.rawBuff(effect.avg, 1.0)
			isOffensive = true
		} else if (effect.type == EFFECT_RAW_BUFF_MAGIC) {
			bulb.stats.mgc += EffectCalc.rawBuff(effect.avg, 1.0)
			isOffensive = true

		// DEFENSIVE BUFFS
		} else if (effect.type == EFFECT_BUFF_WISDOM) {
			defValue = EffectCalc.scaledBuff(effect.avg, snc, 1.0)
			bulb.stats.wsd += defValue
			defStat = Stats.WSD
		} else if (effect.type == EFFECT_RAW_BUFF_WISDOM) {
			defValue = EffectCalc.rawBuff(effect.avg, 1.0)
			bulb.stats.wsd += defValue
			defStat = Stats.WSD
		} else if (effect.type == EFFECT_BUFF_RESISTANCE) {
			defValue = EffectCalc.scaledBuff(effect.avg, snc, 1.0)
			bulb.stats.rst += defValue
			defStat = Stats.RST
		} else if (effect.type == EFFECT_RAW_BUFF_RESISTANCE) {
			defValue = EffectCalc.rawBuff(effect.avg, 1.0)
			bulb.stats.rst += defValue
			defStat = Stats.RST
		} else if (effect.type == EFFECT_BOOST_MAX_LIFE) {
			defValue = EffectCalc.boostMaxLife(effect.avg, wsd, 1.0)
			bulb.stats.life += defValue
			defStat = Stats.HPMAX
		} else if (effect.type == EFFECT_ABSOLUTE_SHIELD) {
			defValue = EffectCalc.scaledShield(effect.avg, rst, 1.0)
			defStat = Stats.ABSSHIELD
		} else if (effect.type == EFFECT_RAW_ABSOLUTE_SHIELD) {
			defValue = EffectCalc.rawShield(effect.avg)
			defStat = Stats.ABSSHIELD
		} else if (effect.type == EFFECT_RELATIVE_SHIELD) {
			defValue = EffectCalc.scaledShield(effect.avg, rst, 1.0)
			defStat = Stats.RELSHIELD
		} else if (effect.type == EFFECT_RAW_RELATIVE_SHIELD) {
			defValue = EffectCalc.rawShield(effect.avg)
			defStat = Stats.RELSHIELD
		}

		// SCORING
		if (isOffensive && count(bulb.offensiveChips) > 0 && bulb.target != Fight.self) {
			real newDmg = MapSummon._calcKnapsackDamageForEnemy(bulb.stats, bulb.offensiveChips, bulb.target)
			real newDmgScore = MapSummon.computeDamageScore(newDmg, bulb.target)
			this.score += newDmgScore - bulb.currentDmgScore
			bulb.currentDmgScore = newDmgScore
		}

		if (defValue > 0 && defStat > 0) {
			real coef = bulb.getCoef(defStat)
			this.score += defValue * coef
		}
	}

	// ════════════════════════════════════════════════════════════════════════
	// EFFECT HANDLER DISPATCH
	// ════════════════════════════════════════════════════════════════════════

	void updateConsequences(ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg) {
		if (Consequences.convertToValue[effect.type] == null) {
			debugW('unhandledEffect on effect: ' + effect)
			return;
		}
		(Consequences.convertToValue[effect.type]!)(effect, entitySource, entityTarget, ratioDmg, this)
	}

	// Effect handlers map - populated by Effect modules (see Model/Combos/Effects/)
	static Map<integer, Function<ItemEffect, Entity, Entity, real, Consequences => void>> convertToValue = [:]

	static void registerHandler(integer effectType, Function<ItemEffect, Entity, Entity, real, Consequences => void> handler) {
		convertToValue[effectType] = handler
	}

	static void registerHandlers(Map<integer, Function<ItemEffect, Entity, Entity, real, Consequences => void>> handlers) {
		for(integer effectType : Function<ItemEffect, Entity, Entity, real, Consequences => void> handler in handlers) {
			convertToValue[effectType] = handler
		}
	}

	// ════════════════════════════════════════════════════════════════════════
	// DEBUG OUTPUT
	// ════════════════════════════════════════════════════════════════════════

	string string(){
		string str = "<Consequences"
		Map<Entity, Map<integer, integer>> allAlterations = this.getAlterations()
		for(Entity entity : Map<integer, integer> alteration in allAlterations){
			str+= "\n" + entity.name + ":"
			for(string strKey in Stats.getFields()){
				integer key = Stats.getInstance()[strKey] as integer
				if(alteration[key] != null) str+= "|"+strKey+": "+round(alteration[key]!)
			}
		}
		// Collect all kills (walks parent chain)
		Set<Entity> allKilled = this._collectAllKilled()
		for(Entity entity in allKilled) str+= "\n|KILL: "+ entity
		str+="\nhashcode:"+this.hashcode+">"
		return str
	}

	/*
	 * Collect all killed entities from this node and parents.
	 */
	private Set<Entity> _collectAllKilled() {
		return setUnion(this._killed, (this._parent != null)?this._parent!._collectAllKilled():<>)
	}
}
