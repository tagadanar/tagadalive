class Consequences {
	Map<Entity, Map<integer, integer>> _alterations = [:]// [entity:[caracteristic:value]]
	Map<Entity, Map<Item, Array<EffectOverTime>>> _altEffects = [:]// [entity:[item:[EffectOverTime]]]
	Map<Entity, Entity> _killed = [:]
	real? score = null
	boolean isAlteringDanger = false
	integer hashcode = 17
	Array<Entity> targets = []
	Cell currentCell
	integer currentMP
	integer currentTP
	private integer _boostMP_before = 0


	/*
	 * Empty constructor for MCTS root node (no previous actions)
	 */
	constructor() {
		this.currentCell = Fight.self.cell
		this.currentMP = Fight.self.mp
		this.currentTP = Fight.self.tp
		this.score = 0.0
	}

	constructor(Action action){
		Benchmark.start("Consequences")
		this.currentCell = Fight.self.cell
		this.currentMP = Fight.self.mp
		this.currentTP = Fight.self.tp
		this.score = 0.0  // Must initialize before construct() modifies it
		construct(action)
		Benchmark.stop("Consequences")
	}
	
	constructor(Action action, Consequences consequences){
		Benchmark.start("Consequences.fromConseq")
		this.currentCell = consequences.currentCell
		this.currentMP = consequences.currentMP
		this.currentTP = consequences.currentTP
		this._alterations = clone(consequences._alterations, 2) as Map<Entity, Map<integer, integer>>
		this._altEffects = clone(consequences._altEffects, 3) as Map<Entity, Map<Item, Array<EffectOverTime>>>
		this._killed = clone(consequences._killed) as Map<Entity, Entity>
		this.hashcode = consequences.hashcode
		this.score = consequences.score != null ? consequences.score : 0.0  // Inherit parent score
		construct(action)
		Benchmark.stop("Consequences.fromConseq")
	}
	
	construct(Action action){
		// actualisation du placement virtuel :
		Map<Cell, integer> reachableCells = MapPath.getCachedReachableCells(this.currentCell, this.currentMP, Fight.self.cellsToIgnore)
		// déplacement jusqu'à la case de l'action
		if(action.from != Fight.selfCell){
			if(reachableCells[action.from] != null) {
				integer moveCost = reachableCells[action.from]!
				// Only warn if movement cost exceeds effective MP (treating negative as 0)
				if(moveCost > 0 && moveCost > max(0, this.currentMP)) {
					debugW('Impossible action: move cost ' + moveCost + ' > effective MP ' + max(0, this.currentMP) + '\n' + action + '\n' + this)
				}
				this.currentMP = this.currentMP - moveCost  // Keep actual tracking for boost calculations
			} else {
				debugW('Impossible action: unreachable cell !!\n'+action+'\n'+this)
			}
			// actualisation de la case actuelle
			this.currentCell = action.from
		}
		// déduction du coût TP de l'action
		this.currentTP -= action.item.cost
		// on retient les boosts mp/tp déjà appliquer à soit mm pour après
		integer? boostMPbefore = this._alterations[Fight.self] != null ? this._alterations[Fight.self]![Stats.MP] : null
		integer? boostTPbefore = this._alterations[Fight.self] != null ? this._alterations[Fight.self]![Stats.TP] : null

		// actualisation des conséquences de l'action sur le jeu
		this.targets = Targets.getTargets(action)
		for(Entity target in this.targets){
			if(this._killed[target]) continue
			// For self in AOE, use simulated position (this.currentCell) not real position (target.cell)
			integer targetCellId = (target == Fight.self) ? this.currentCell.id : target.cell.id
			real ratioDmg = action.item.isAOE ? 1-(0.2*getCellDistance(action.to.id, targetCellId)) : 1.0
			if(ratioDmg<=0){
				debugE('Bug in Consequences: ratioDmg<=0 for target ' + target + ' at cell ' + targetCellId)
				debugE(action)
				continue
			}
			for(ItemEffect effect in action.item.effects) {
				this.updateConsequences(effect, Fight.self, target, ratioDmg)
			}
		}

		// actualisation des MP en cas de self boost de mp
		integer? boostMP = this.getAlteration(Fight.self, Stats.MP)  // Use safe accessor
		// si je viens de m'ajouter des MP
		if(boostMP != null && boostMP > boostMPbefore){
			this.currentMP += boostMP - boostMPbefore // j'ajoute les mp gagnés
		}

		// actualisation des TP en cas de self boost de tp
		integer? boostTP = this.getAlteration(Fight.self, Stats.TP)
		// si je viens de m'ajouter des TP
		if(boostTP != null && boostTP > boostTPbefore){
			this.currentTP += boostTP - boostTPbefore // j'ajoute les tp gagnés
		}

		// Cooldown opportunity cost: penalize using CD items for marginal gains
		this.score -= action.item.cdDuration
	}

	void add(Entity entity, integer key, EffectOverTime|integer effect){
		if(!_alterations[entity]) _alterations[entity] = [:]
		boolean isOverTime = effect instanceof EffectOverTime
		integer value = isOverTime ? (effect as EffectOverTime).value : effect as integer
		if(isOverTime){
			if(!_altEffects[entity]) _altEffects[entity] = [:]
			if(!_altEffects[entity]![(effect as EffectOverTime).item]) _altEffects[entity]![(effect as EffectOverTime).item] = []

			push(_altEffects[entity]![(effect as EffectOverTime).item]!, (effect as EffectOverTime))
		}
		_alterations[entity]![key] += value // pour null, devrait se comporter comme si ça contenait 0
		// ça ne marche qu'avec += en leekscriptv1, pas tester en v1.1 comment ça marche...
		// j'avais des bugs sur les -=, donc il faut faire += -value si le comportement est le mm ici.

		if(entity==Fight.self && (
			   key==Stats.HP
			|| key==Stats.ABSSHIELD
			|| key==Stats.RELSHIELD
			|| key==Stats.DEBUFF)){
				this.isAlteringDanger=true
				this.hashcode = 31 * this.hashcode + (value|0)
		} else if(!entity.isFriend && (
			   key==Stats.DEBUFF
			|| key==Stats.STR
			|| key==Stats.TP
			|| key==Stats.MP)){
				this.isAlteringDanger=true
				this.hashcode = 31 * this.hashcode + entity.id
				this.hashcode = 31 * this.hashcode + (value|0)
		}

		// update du score (using dynamic coefficients for situational modifiers)
		real coef = Scoring.getDynamicCoef(entity, key, this)
		real scoreDelta = value * coef
		if(!isOverTime) this.score += scoreDelta
		else this.score += scoreDelta * ScoringConfig.offensive_duration_mitigation[(effect as EffectOverTime).duration]!
	}
	
	void addKill(Entity entity){
		this.isAlteringDanger=true
		this.hashcode = 31 * this.hashcode + entity.id
		this._killed[entity]=entity
		this.score+= ScoringConfig.KILL_VALUE * Scoring.getDynamicCoef(entity, Stats.KILL, this)
		// Inline passive for kill
		Map<integer, real> passives = Fight.self.passives
		if(passives[EFFECT_KILL_TO_TP]) {
			integer tpGain = round(passives[EFFECT_KILL_TO_TP]!)
			if(tpGain > 0) this.add(Fight.self, Stats.TP, tpGain)
		}
		// Chest power gain (all fight types): 10 + 50% pwr + type bonus (wood +10, iron +50, diamond +100)
		if(entity.entityType == ENTITY_CHEST) {
			integer chestBonus = 0
			if(entity.name == "wood_chest") chestBonus = 10
			else if(entity.name == "iron_chest") chestBonus = 50
			else if(entity.name == "diamond_chest") chestBonus = 100
			integer pwrGain = 10 + chestBonus + round(entity.pwr * 0.5)
			this.add(Fight.self, Stats.PWR, pwrGain)
		}
		// BR power gain (leek = 10 + 50% pwr, bulb = 2 + 50% pwr)
		else if(Fight.isBattleRoyale) {
			integer basePwr = entity.isBulb ? 2 : 10
			integer pwrGain = basePwr + round(entity.pwr * 0.5)
			this.add(Fight.self, Stats.PWR, pwrGain)
		}
	}
	
	Map<Entity, Map<integer, integer>> getAlterations(){
		return _alterations
	}
		
	boolean isKilled(Entity entity){
		return _killed[entity] != null
	}
	
	integer? getAlteration(Entity entity, integer key){
		if(_alterations[entity] == null) return null
		return _alterations[entity]![key]
	}
	
	real? getScore(){
		return this.score
	}
	
	void updateConsequences(ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg) {
		// fixme: ce if marche pas, j'ai tjr true mm pour EFFECT_DAMAGE :'(
		if(Consequences.convertToValue[effect.type] == null) debugW('unhandledEffect on effect: '+ effect)
		Entity target = effect.modifCaster ? entitySource : entityTarget
		ratioDmg = effect.modifCaster ? 1.0 : ratioDmg;

		(Consequences.convertToValue[effect.type]!)(effect, entitySource, target, ratioDmg, this)
	}

	// Effect handlers map - populated by Effect modules (see Model/Combos/Effects/)
	static Map<integer, Function<ItemEffect, Entity, Entity, real, Consequences => void>> convertToValue = [:]
	
	/**
	 * Register an effect handler for a specific effect type.
	 * Called by Effect modules during include to populate convertToValue map.
	 */
	static void registerHandler(integer effectType, Function<ItemEffect, Entity, Entity, real, Consequences => void> handler) {
		convertToValue[effectType] = handler
	}
	
	/**
	 * Register multiple effect handlers at once.
	 * @param handlers Map of effectType -> handler function
	 */
	static void registerHandlers(Map<integer, Function<ItemEffect, Entity, Entity, real, Consequences => void>> handlers) {
		for(integer effectType : Function<ItemEffect, Entity, Entity, real, Consequences => void> handler in handlers) {
			convertToValue[effectType] = handler
		}
	}
	
	/*
	//Non utilisée et buggué 
	computeScore(){
		var totalScore = 0;
		for(Entity  entity:Map<integer, integer> key in this._alterations){
			var value = this.getAlteration(entity, key)
			if(key == Stats.HP) 			totalScore+= entity.isFriend ? value : -value
			if(key == Stats.ABSSHIELD) 	totalScore+= entity.isFriend ? value*3 : -(value*3)
			if(key == Stats.STR) 		totalScore+= entity.isFriend ? value : -value
			
		}
		for(Entity entity:var bool in this._killed){
			var killScore = 10000
			killScore*= entity.isBulb ? 0.5 : 1
			totalScore+= entity.isFriend ? -killScore : killScore
		}
		return totalScore
	}*/
	
	string string(){
		string str = "<Consequences"
		for(Entity entity:Map<integer, integer> alteration in this._alterations){
			str+= "\n" + entity.name + ":"
			for(string strKey in Stats.getFields()){
				integer key = Stats.getInstance()[strKey] as integer
				//var key = Stats.getInstance()[strKey]
				if(alteration[key] != null) str+= "|"+strKey+": "+round(alteration[key]!)
			}
			/*
			for(var key:var value in alteration){
				if(key == Stats.HP) 			str+= "|HP: "+round(value)
				if(key == Stats.ABSSHIELD) 	str+= "|ABSSHIELD: "+round(value)
				if(key == Stats.STR) 		str+= "|STR: "+round(value)
			}
			*/
		}
		for(Entity entity:var isDead in this._killed) str+= "\n|KILL: "+ entity
		str+="\nhashcode:"+this.hashcode+">"
		return str
	}
}