class Consequences {
	Map<Entity, Map<integer, integer>> _alterations = [:]// [entity:[caracteristic:value]]
	Map<Entity, Map<Item, Array<EffectOverTime>>> _altEffects = [:]// [entity:[item:[EffectOverTime]]]
	Map<Entity, Map<integer, integer>> _effectTypeAlterations = [:]// [entity:[effectType:valueAltered]]
	Map<Entity, Entity> _killed = [:]
	real? score = null
	boolean isAlteringDanger = false
	integer hashcode = 17
	Array<Entity> targets = []
	Cell currentCell
	integer currentMP
	integer currentTP
	Item? currentWeapon           // Equipped weapon (for switch cost tracking)
	private integer _boostMP_before = 0


	/*
	 * Empty constructor for MCTS root node (no previous actions)
	 */
	constructor() {
		this.currentCell = Fight.self.cell
		this.currentMP = Fight.self.mp
		this.currentTP = Fight.self.tp
		this.currentWeapon = Fight.self.getWeaponInHand()
		this.score = 0.0
	}

	constructor(Action action){
		Benchmark.start("Consequences")
		this.currentCell = Fight.self.cell
		this.currentMP = Fight.self.mp
		this.currentTP = Fight.self.tp
		this.currentWeapon = Fight.self.getWeaponInHand()
		this.score = 0.0  // Must initialize before construct() modifies it
		construct(action, false)  // Don't warn during pool creation (extended cells are valid)
		Benchmark.stop("Consequences")
	}

	constructor(Action action, Consequences consequences){
		Benchmark.start("Consequences.fromConseq")
		this.currentCell = consequences.currentCell
		this.currentMP = consequences.currentMP
		this.currentTP = consequences.currentTP
		this.currentWeapon = consequences.currentWeapon
		this._alterations = clone(consequences._alterations, 2) as Map<Entity, Map<integer, integer>>
		this._altEffects = clone(consequences._altEffects, 3) as Map<Entity, Map<Item, Array<EffectOverTime>>>
		this._effectTypeAlterations = clone(consequences._effectTypeAlterations, 2) as Map<Entity, Map<integer, integer>>
		this._killed = clone(consequences._killed) as Map<Entity, Entity>
		this.hashcode = consequences.hashcode
		this.score = consequences.score != null ? consequences.score : 0.0  // Inherit parent score
		construct(action, true)  // Warn during combo building (catches actual bugs)
		Benchmark.stop("Consequences.fromConseq")
	}
	
	construct(Action action, boolean warnOnUnreachable){
		// actualisation du placement virtuel :
		// Build ignoreCells: our starting cell + cells of killed entities (can path through kills)
		Array<Cell> ignoreCells = clone(Fight.self.cellsToIgnore) as Array<Cell>
		for (Entity e : Entity _ in this._killed) {
			push(ignoreCells, e.cell)
		}
		Map<Cell, integer> reachableCells = MapPath.getCachedReachableCells(this.currentCell, this.currentMP, ignoreCells)
		// déplacement jusqu'à la case de l'action
		if(action.from != Fight.selfCell){
			if(reachableCells[action.from] != null) {
				integer moveCost = reachableCells[action.from]!
				// Only warn during combo building (not pool creation where extended cells are valid)
				if(warnOnUnreachable && moveCost > 0 && moveCost > max(0, this.currentMP)) {
					debugW('Impossible action: move cost ' + moveCost + ' > effective MP ' + max(0, this.currentMP) + '\n' + action + '\n' + this)
				}
				this.currentMP = this.currentMP - moveCost  // Keep actual tracking for boost calculations
			} else if(warnOnUnreachable) {
				debugW('Impossible action: unreachable cell !!\n'+action+'\n'+this)
			}
			// actualisation de la case actuelle
			this.currentCell = action.from
		}
		// déduction du coût TP de l'action
		this.currentTP -= action.item.cost
		// Weapon switch cost: +1 TP if switching to a different weapon
		if (action.item.isWeap && action.item != this.currentWeapon) {
			this.currentTP -= 1
		}
		// Update current weapon if action uses a weapon
		if (action.item.isWeap) {
			this.currentWeapon = action.item
		}
		// on retient les boosts mp/tp déjà appliquer à soit mm pour après
		integer? boostMPbefore = this._alterations[Fight.self] != null ? this._alterations[Fight.self]![Stats.MP] : null
		integer? boostTPbefore = this._alterations[Fight.self] != null ? this._alterations[Fight.self]![Stats.TP] : null

		// actualisation des conséquences de l'action sur le jeu
		this.targets = Targets.getTargets(action)
		for(Entity target in this.targets){
			if(this._killed[target]) continue
			// For self in AOE, use simulated position (this.currentCell) not real position (target.cell)
			integer targetCellId = (target == Fight.self) ? this.currentCell.id : target.cell.id
			// For self-cast AOE, center is caster's simulated position, not sentinel cell
			Cell aoeCenterCell = (action.to == Fight.selfCell) ? this.currentCell : action.to
			real ratioDmg = action.item.isAOE ? 1-(0.2*getCellDistance(aoeCenterCell.id, targetCellId)) : 1.0
			if(ratioDmg<=0){
				debugE('Bug in Consequences: ratioDmg<=0 for target ' + target + ' at cell ' + targetCellId)
				debugE(action)
				continue
			}
			for(ItemEffect effect in action.item.effects) {
				this.updateConsequences(effect, Fight.self, target, ratioDmg)
			}
		}

		// actualisation des MP en cas de self boost/debuff de mp (e.g., Liberation reducing Leather Boots)
		integer? boostMP = this.getAlteration(Fight.self, Stats.MP)
		if(boostMP != boostMPbefore){
			this.currentMP += boostMP - boostMPbefore  // null coerces to 0
		}

		// actualisation des TP en cas de self boost/debuff de tp (e.g., Liberation reducing Motivation)
		integer? boostTP = this.getAlteration(Fight.self, Stats.TP)
		if(boostTP != boostTPbefore){
			this.currentTP += boostTP - boostTPbefore  // null coerces to 0
		}

		// Cooldown opportunity cost: penalize using CD items for marginal gains
		this.score -= action.item.cdDuration as real
	}

	void add(Entity entity, integer key, EffectOverTime|integer effect){
		if(!_alterations[entity]) _alterations[entity] = [:]
		boolean isOverTime = effect instanceof EffectOverTime
		integer value = isOverTime ? (effect as EffectOverTime).value : effect as integer
		if(isOverTime){
			if(!_altEffects[entity]) _altEffects[entity] = [:]
			if(!_altEffects[entity]![(effect as EffectOverTime).item]) _altEffects[entity]![(effect as EffectOverTime).item] = []

			push(_altEffects[entity]![(effect as EffectOverTime).item]!, (effect as EffectOverTime))
		}
		_alterations[entity]![key] += value // pour null, devrait se comporter comme si ça contenait 0
		// ça ne marche qu'avec += en leekscriptv1, pas tester en v1.1 comment ça marche...
		// j'avais des bugs sur les -=, donc il faut faire += -value si le comportement est le mm ici.

		if(entity==Fight.self && (
			   key==Stats.HP
			|| key==Stats.ABSSHIELD
			|| key==Stats.RELSHIELD
			|| key==Stats.DEBUFF)){
				this.isAlteringDanger=true
				this.hashcode = 31 * this.hashcode + (value|0)
		} else if(!entity.isFriend && (
			   key==Stats.DEBUFF
			|| key==Stats.STR
			|| key==Stats.TP
			|| key==Stats.MP)){
				this.isAlteringDanger=true
				this.hashcode = 31 * this.hashcode + entity.id
				this.hashcode = 31 * this.hashcode + (value|0)
		}

		// update du score (using dynamic coefficients for situational modifiers)
		real coef = Scoring.getDynamicCoef(entity, key, this)
		real scoreDelta = value * coef
		if(!isOverTime) this.score += scoreDelta
		else this.score += scoreDelta * ScoringConfig.offensive_duration_mitigation[(effect as EffectOverTime).duration]!
	}
	
	void addKill(Entity entity){
		this.isAlteringDanger=true
		this.hashcode = 31 * this.hashcode + entity.id
		this._killed[entity]=entity
		this.score+= ScoringConfig.KILL_VALUE * Scoring.getDynamicCoef(entity, Stats.KILL, this)
		// Inline passive for kill
		Map<integer, real> passives = Fight.self.passives
		if(passives[EFFECT_KILL_TO_TP]) {
			integer tpGain = round(passives[EFFECT_KILL_TO_TP]!)
			if(tpGain > 0) this.add(Fight.self, Stats.TP, tpGain)
		}
		// Chest power gain (all fight types): wood +10, iron +50, diamond +100
		if(entity.entityType == ENTITY_CHEST) {
			this.add(Fight.self, Stats.PWR, Fight.chestPwrGained[entity.name]!)
		}
		// BR power gain (leek/chest = 10 + 50% pwr, bulb = 2 + 50% pwr)
		if(Fight.isBattleRoyale) {
			integer basePwr = entity.isBulb ? 2 : 10
			integer pwrGain = basePwr + round(entity.pwr * 0.5)
			this.add(Fight.self, Stats.PWR, pwrGain)
		}
	}
	
	Map<Entity, Map<integer, integer>> getAlterations(){
		return _alterations
	}
		
	boolean isKilled(Entity entity){
		return _killed[entity] != null
	}
	
	integer? getAlteration(Entity entity, integer key){
		if(_alterations[entity] == null) return null
		return _alterations[entity]![key]
	}

	/**
	 * Get how much of an effect type has already been altered/countered in simulation.
	 * Used by removal/reduction effects (Antidote, Liberation, Manumission) to avoid double-counting.
	 */
	integer getEffectTypeAlteration(Entity entity, integer effectType){
		if(!_effectTypeAlterations[entity]) return 0
		return _effectTypeAlterations[entity]![effectType]!  // null coerces to 0
	}

	/**
	 * Track that we altered/countered some amount of an effect type.
	 * Called after processing an effect to record what was handled.
	 */
	void addEffectTypeAlteration(Entity entity, integer effectType, integer value){
		if(!_effectTypeAlterations[entity]) _effectTypeAlterations[entity] = [:]
		_effectTypeAlterations[entity]![effectType] += value
	}

	real? getScore(){
		return this.score
	}
	
	void updateConsequences(ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg) {
		// fixme: ce if marche pas, j'ai tjr true mm pour EFFECT_DAMAGE :'(
		if(Consequences.convertToValue[effect.type] == null) debugW('unhandledEffect on effect: '+ effect)
		Entity target = effect.modifCaster ? entitySource : entityTarget
		ratioDmg = effect.modifCaster ? 1.0 : ratioDmg;

		(Consequences.convertToValue[effect.type]!)(effect, entitySource, target, ratioDmg, this)
	}

	// Effect handlers map - populated by Effect modules (see Model/Combos/Effects/)
	static Map<integer, Function<ItemEffect, Entity, Entity, real, Consequences => void>> convertToValue = [:]
	
	/**
	 * Register an effect handler for a specific effect type.
	 * Called by Effect modules during include to populate convertToValue map.
	 */
	static void registerHandler(integer effectType, Function<ItemEffect, Entity, Entity, real, Consequences => void> handler) {
		convertToValue[effectType] = handler
	}
	
	/**
	 * Register multiple effect handlers at once.
	 * @param handlers Map of effectType -> handler function
	 */
	static void registerHandlers(Map<integer, Function<ItemEffect, Entity, Entity, real, Consequences => void>> handlers) {
		for(integer effectType : Function<ItemEffect, Entity, Entity, real, Consequences => void> handler in handlers) {
			convertToValue[effectType] = handler
		}
	}
	
	/*
	//Non utilisée et buggué 
	computeScore(){
		var totalScore = 0;
		for(Entity  entity:Map<integer, integer> key in this._alterations){
			var value = this.getAlteration(entity, key)
			if(key == Stats.HP) 			totalScore+= entity.isFriend ? value : -value
			if(key == Stats.ABSSHIELD) 	totalScore+= entity.isFriend ? value*3 : -(value*3)
			if(key == Stats.STR) 		totalScore+= entity.isFriend ? value : -value
			
		}
		for(Entity entity:var bool in this._killed){
			var killScore = 10000
			killScore*= entity.isBulb ? 0.5 : 1
			totalScore+= entity.isFriend ? -killScore : killScore
		}
		return totalScore
	}*/
	
	string string(){
		string str = "<Consequences"
		for(Entity entity:Map<integer, integer> alteration in this._alterations){
			str+= "\n" + entity.name + ":"
			for(string strKey in Stats.getFields()){
				integer key = Stats.getInstance()[strKey] as integer
				//var key = Stats.getInstance()[strKey]
				if(alteration[key] != null) str+= "|"+strKey+": "+round(alteration[key]!)
			}
			/*
			for(var key:var value in alteration){
				if(key == Stats.HP) 			str+= "|HP: "+round(value)
				if(key == Stats.ABSSHIELD) 	str+= "|ABSSHIELD: "+round(value)
				if(key == Stats.STR) 		str+= "|STR: "+round(value)
			}
			*/
		}
		for(Entity entity:var isDead in this._killed) str+= "\n|KILL: "+ entity
		str+="\nhashcode:"+this.hashcode+">"
		return str
	}
}