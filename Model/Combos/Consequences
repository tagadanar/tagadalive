class Consequences {
	Map<Entity, Map<integer, integer>> _alterations = [:]// [entity:[caracteristic:value]]
	Map<Entity, Map<Item, Array<EffectOverTime>>> _altEffects = [:]// [entity:[item:[EffectOverTime]]]
	Map<Entity, Map<integer, integer>> _effectTypeAlterations = [:]// [entity:[effectType:valueAltered]]
	Map<Entity, Entity> _killed = [:]
	real? score = null
	boolean isAlteringDanger = false
	integer hashcode = 17
	Array<Entity> targets = []
	Cell currentCell
	integer currentMP
	integer currentTP
	Item? currentWeapon           // Equipped weapon (for switch cost tracking)
	private integer _boostMP_before = 0

	// Shared effect snapshot (null = local mode, set = shared mode)
	// In shared mode, effect data comes from _shared, local maps are empty
	EffectSnapshot? _shared = null


	/*
	 * Empty constructor for MCTS root node (no previous actions)
	 */
	constructor() {
		this.currentCell = Fight.self.cell
		this.currentMP = Fight.self.mp
		this.currentTP = Fight.self.tp
		this.currentWeapon = Fight.self.getWeaponInHand()
		this.score = 0.0
	}

	constructor(Action action){
		Benchmark.start("Consequences")
		this.currentCell = Fight.self.cell
		this.currentMP = Fight.self.mp
		this.currentTP = Fight.self.tp
		this.currentWeapon = Fight.self.getWeaponInHand()
		this.score = 0.0  // Must initialize before construct() modifies it
		construct(action, false)  // Don't warn during pool creation (extended cells are valid)
		Benchmark.stop("Consequences")
	}

	constructor(Action action, Consequences consequences){
		Benchmark.start("Consequences.fromConseq")
		this.currentCell = consequences.currentCell
		this.currentMP = consequences.currentMP
		this.currentTP = consequences.currentTP
		this.currentWeapon = consequences.currentWeapon
		// Materialize shared data if parent was in shared mode
		if (consequences._shared != null) {
			this._alterations = clone(consequences._shared!.alterations, 2) as Map<Entity, Map<integer, integer>>
			this._altEffects = clone(consequences._shared!.altEffects, 3) as Map<Entity, Map<Item, Array<EffectOverTime>>>
			this._effectTypeAlterations = clone(consequences._shared!.effectTypeAlterations, 2) as Map<Entity, Map<integer, integer>>
			this._killed = clone(consequences._shared!.killed) as Map<Entity, Entity>
		} else {
			this._alterations = clone(consequences._alterations, 2) as Map<Entity, Map<integer, integer>>
			this._altEffects = clone(consequences._altEffects, 3) as Map<Entity, Map<Item, Array<EffectOverTime>>>
			this._effectTypeAlterations = clone(consequences._effectTypeAlterations, 2) as Map<Entity, Map<integer, integer>>
			this._killed = clone(consequences._killed) as Map<Entity, Entity>
		}
		this.hashcode = consequences.hashcode
		this.score = consequences.score != null ? consequences.score : 0.0  // Inherit parent score
		construct(action, true)  // Warn during combo building (catches actual bugs)
		Benchmark.stop("Consequences.fromConseq")
	}

	/*
	 * Static factory: creates Consequences from pre-computed EffectSnapshot.
	 * Only applies movement costs; effects come from the shared snapshot.
	 * Used for initial action pool creation where many actions share identical effects.
	 */
	static Consequences fromSnapshot(EffectSnapshot snapshot, Action action) {
		Benchmark.start("Consequences.shared")
		Consequences c = new Consequences()
		c._shared = snapshot
		c.targets = snapshot.targets
		c.score = snapshot.effectScore
		c.isAlteringDanger = snapshot.isAlteringDanger
		c.hashcode = snapshot.hashcode

		// Apply movement cost only (effects already computed in snapshot)
		c.constructMovementOnly(action)

		// Cooldown penalty
		c.score -= snapshot.cdDuration
		Benchmark.stop("Consequences.shared")
		return c
	}
	
	construct(Action action, boolean warnOnUnreachable){
		// actualisation du placement virtuel :
		// Build ignoreCells: our starting cell + cells of killed entities (can path through kills)
		Array<Cell> ignoreCells = clone(Fight.self.cellsToIgnore) as Array<Cell>
		for (Entity e : Entity _ in this._killed) {
			push(ignoreCells, e.cell)
		}
		Map<Cell, integer> reachableCells = MapPath.getCachedReachableCells(this.currentCell, this.currentMP, ignoreCells)
		// déplacement jusqu'à la case de l'action
		if(action.from != Fight.selfCell){
			if(reachableCells[action.from] != null) {
				integer moveCost = reachableCells[action.from]!
				// Only warn during combo building (not pool creation where extended cells are valid)
				if(warnOnUnreachable && moveCost > 0 && moveCost > max(0, this.currentMP)) {
					debugW('Impossible action: move cost ' + moveCost + ' > effective MP ' + max(0, this.currentMP) + '\n' + action + '\n' + this)
				}
				this.currentMP = this.currentMP - moveCost  // Keep actual tracking for boost calculations
			} else if(warnOnUnreachable) {
				debugW('Impossible action: unreachable cell !!\n'+action+'\n'+this)
			}
			// actualisation de la case actuelle
			this.currentCell = action.from
		}
		// déduction du coût TP de l'action
		this.currentTP -= action.item.cost
		// Weapon switch cost: +1 TP if switching to a different weapon
		if (action.item.isWeap && action.item != this.currentWeapon) {
			this.currentTP -= 1
		}
		// Update current weapon if action uses a weapon
		if (action.item.isWeap) {
			this.currentWeapon = action.item
		}
		// on retient les boosts mp/tp déjà appliquer à soit mm pour après
		integer? boostMPbefore = this._alterations[Fight.self] != null ? this._alterations[Fight.self]![Stats.MP] : null
		integer? boostTPbefore = this._alterations[Fight.self] != null ? this._alterations[Fight.self]![Stats.TP] : null

		// actualisation des conséquences de l'action sur le jeu
		this.targets = Targets.getTargets(action)
		for(Entity target in this.targets){
			if(this._killed[target]) continue
			// For self in AOE, use simulated position (this.currentCell) not real position (target.cell)
			integer targetCellId = (target == Fight.self) ? this.currentCell.id : target.cell.id
			// For self-cast AOE, center is caster's simulated position, not sentinel cell
			Cell aoeCenterCell = (action.to == Fight.selfCell) ? this.currentCell : action.to
			real ratioDmg = action.item.isAOE ? 1-(0.2*getCellDistance(aoeCenterCell.id, targetCellId)) : 1.0
			if(ratioDmg<=0){
				debugE('Bug in Consequences: ratioDmg<=0 for target ' + target + ' at cell ' + targetCellId)
				debugE(action)
				continue
			}
			for(ItemEffect effect in action.item.effects) {
				this.updateConsequences(effect, Fight.self, target, ratioDmg)
			}
		}

		// actualisation des MP en cas de self boost/debuff de mp (e.g., Liberation reducing Leather Boots)
		integer? boostMP = this.getAlteration(Fight.self, Stats.MP)
		if(boostMP != boostMPbefore){
			this.currentMP += boostMP - boostMPbefore  // null coerces to 0
		}

		// actualisation des TP en cas de self boost/debuff de tp (e.g., Liberation reducing Motivation)
		integer? boostTP = this.getAlteration(Fight.self, Stats.TP)
		if(boostTP != boostTPbefore){
			this.currentTP += boostTP - boostTPbefore  // null coerces to 0
		}

		// Cooldown opportunity cost: penalize using CD items for marginal gains
		this.score -= action.item.cdDuration
	}

	/*
	 * Movement-only construction for shared snapshot mode.
	 * Applies movement cost and weapon switch cost, but no effect computation.
	 * Effects are pre-computed in the shared EffectSnapshot.
	 */
	void constructMovementOnly(Action action) {
		// Movement cost calculation (same as construct, but no kills to ignore in initial pool)
		Map<Cell, integer> reachableCells = MapPath.getCachedReachableCells(this.currentCell, this.currentMP, Fight.self.cellsToIgnore)

		if (action.from != Fight.selfCell) {
			if (reachableCells[action.from] != null) {
				integer moveCost = reachableCells[action.from]!
				this.currentMP = this.currentMP - moveCost
			}
			this.currentCell = action.from
		}

		// TP cost
		this.currentTP -= action.item.cost

		// Weapon switch cost
		if (action.item.isWeap && action.item != this.currentWeapon) {
			this.currentTP -= 1
		}

		// Update current weapon
		if (action.item.isWeap) {
			this.currentWeapon = action.item
		}

		// Handle MP/TP boosts from shared snapshot
		integer? boostMP = this._shared!.getAlteration(Fight.self, Stats.MP)
		if (boostMP != null && boostMP != 0) {
			this.currentMP += boostMP!
		}

		integer? boostTP = this._shared!.getAlteration(Fight.self, Stats.TP)
		if (boostTP != null && boostTP != 0) {
			this.currentTP += boostTP!
		}
	}

	void add(Entity entity, integer key, EffectOverTime|integer effect){
		if(!_alterations[entity]) _alterations[entity] = [:]
		boolean isOverTime = effect instanceof EffectOverTime
		integer value = isOverTime ? (effect as EffectOverTime).value : effect as integer
		if(isOverTime){
			if(!_altEffects[entity]) _altEffects[entity] = [:]
			if(!_altEffects[entity]![(effect as EffectOverTime).item]) _altEffects[entity]![(effect as EffectOverTime).item] = []

			push(_altEffects[entity]![(effect as EffectOverTime).item]!, (effect as EffectOverTime))
		}
		_alterations[entity]![key] += value // pour null, devrait se comporter comme si ça contenait 0
		// ça ne marche qu'avec += en leekscriptv1, pas tester en v1.1 comment ça marche...
		// j'avais des bugs sur les -=, donc il faut faire += -value si le comportement est le mm ici.

		if(entity==Fight.self && (
			   key==Stats.HP
			|| key==Stats.ABSSHIELD
			|| key==Stats.RELSHIELD
			|| key==Stats.DEBUFF)){
				this.isAlteringDanger=true
				this.hashcode = 31 * this.hashcode + (value|0)
		} else if(!entity.isFriend && (
			   key==Stats.DEBUFF
			|| key==Stats.STR
			|| key==Stats.TP
			|| key==Stats.MP)){
				this.isAlteringDanger=true
				this.hashcode = 31 * this.hashcode + entity.id
				this.hashcode = 31 * this.hashcode + (value|0)
		}

		// update du score (using dynamic coefficients for situational modifiers)
		real coef = Scoring.getDynamicCoef(entity, key, this)
		real scoreDelta = value * coef
		if(!isOverTime) this.score += scoreDelta
		else this.score += scoreDelta * ScoringConfig.offensive_duration_mitigation[(effect as EffectOverTime).duration]!
	}
	
	void addKill(Entity entity){
		this.isAlteringDanger=true
		this.hashcode = 31 * this.hashcode + entity.id
		this._killed[entity]=entity
		this.score+= ScoringConfig.KILL_VALUE * Scoring.getDynamicCoef(entity, Stats.KILL, this)
		// Inline passive for kill
		Map<integer, real> passives = Fight.self.passives
		if(passives[EFFECT_KILL_TO_TP]) {
			integer tpGain = round(passives[EFFECT_KILL_TO_TP]!)
			if(tpGain > 0) this.add(Fight.self, Stats.TP, tpGain)
		}
		// Chest power gain (all fight types): wood +10, iron +50, diamond +100
		if(entity.entityType == ENTITY_CHEST) {
			this.add(Fight.self, Stats.PWR, Fight.chestPwrGained[entity.name])
		}
		// BR power gain (leek/chest = 10 + 50% pwr, bulb = 2 + 50% pwr)
		if(Fight.isBattleRoyale) {
			integer basePwr = entity.isBulb ? 2 : 10
			integer pwrGain = basePwr + round(entity.pwr * 0.5)
			this.add(Fight.self, Stats.PWR, pwrGain)
		}
	}
	
	Map<Entity, Map<integer, integer>> getAlterations(){
		if (_shared != null) return _shared!.alterations
		return _alterations
	}

	boolean isKilled(Entity entity){
		if (_shared != null) return _shared!.isKilled(entity)
		return _killed[entity] != null
	}

	integer? getAlteration(Entity entity, integer key){
		if (_shared != null) return _shared!.getAlteration(entity, key)
		if(_alterations[entity] == null) return null
		return _alterations[entity]![key]
	}

	/*
	 * Unified interface: Get current HP considering alterations.
	 * Used by EffectHandlers for duck-typed context.
	 */
	integer getHP(Entity entity) {
		integer? hpDelta = this.getAlteration(entity, Stats.HP)
		return entity.life + (hpDelta != null ? hpDelta! : 0)
	}

	/*
	 * Unified interface: Get current HP missing considering alterations.
	 * Used by EffectHandlers for duck-typed context.
	 */
	integer getHPMissing(Entity entity) {
		integer? hpMaxDelta = this.getAlteration(entity, Stats.HPMAX)
		integer currentMax = entity.totalLife + (hpMaxDelta != null ? hpMaxDelta! : 0)
		return currentMax - this.getHP(entity)
	}

	/*
	 * Unified interface: Get existing effect from same item on entity.
	 * Used by EffectHandlers for non-stackable de-dupe.
	 * Checks combo effects first (most recent), then turn-start effects.
	 */
	EffectOverTime? getExistingItemEffect(Entity entity, Item item) {
		// Check combo effects first
		if (_shared != null) {
			if (_shared!.altEffects[entity] && _shared!.altEffects[entity]![item]) {
				Array<EffectOverTime> effects = _shared!.altEffects[entity]![item]!
				return effects[count(effects) - 1]
			}
		} else {
			if (_altEffects[entity] && _altEffects[entity]![item]) {
				Array<EffectOverTime> effects = _altEffects[entity]![item]!
				return effects[count(effects) - 1]
			}
		}
		// Then check turn-start effects
		return entity.items_effectOverTime[item] ? entity.items_effectOverTime[item]![0] : null
	}

	/**
	 * Get how much of an effect type has already been altered/countered in simulation.
	 * Used by removal/reduction effects (Antidote, Liberation, Manumission) to avoid double-counting.
	 */
	integer getEffectTypeAlteration(Entity entity, integer effectType){
		if (_shared != null) return _shared!.getEffectTypeAlteration(entity, effectType)
		if(!_effectTypeAlterations[entity]) return 0
		return _effectTypeAlterations[entity]![effectType]  // null coerces to 0
	}

	/**
	 * Track that we altered/countered some amount of an effect type.
	 * Called after processing an effect to record what was handled.
	 */
	void addEffectTypeAlteration(Entity entity, integer effectType, integer value){
		if(!_effectTypeAlterations[entity]) _effectTypeAlterations[entity] = [:]
		_effectTypeAlterations[entity]![effectType] += value
	}

	real? getScore(){
		return this.score
	}
	
	void updateConsequences(ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg) {
		// fixme: ce if marche pas, j'ai tjr true mm pour EFFECT_DAMAGE :'(
		if(Consequences.convertToValue[effect.type] == null) debugW('unhandledEffect on effect: '+ effect)
		Entity target = effect.modifCaster ? entitySource : entityTarget
		ratioDmg = effect.modifCaster ? 1.0 : ratioDmg;

		(Consequences.convertToValue[effect.type]!)(effect, entitySource, target, ratioDmg, this)
	}

	// Effect handlers map - populated by Effect modules (see Model/Combos/Effects/)
	static Map<integer, Function<ItemEffect, Entity, Entity, real, Consequences => void>> convertToValue = [:]
	
	/**
	 * Register an effect handler for a specific effect type.
	 * Called by Effect modules during include to populate convertToValue map.
	 */
	static void registerHandler(integer effectType, Function<ItemEffect, Entity, Entity, real, Consequences => void> handler) {
		convertToValue[effectType] = handler
	}
	
	/**
	 * Register multiple effect handlers at once.
	 * @param handlers Map of effectType -> handler function
	 */
	static void registerHandlers(Map<integer, Function<ItemEffect, Entity, Entity, real, Consequences => void>> handlers) {
		for(integer effectType : Function<ItemEffect, Entity, Entity, real, Consequences => void> handler in handlers) {
			convertToValue[effectType] = handler
		}
	}
	
	/*
	//Non utilisée et buggué 
	computeScore(){
		var totalScore = 0;
		for(Entity  entity:Map<integer, integer> key in this._alterations){
			var value = this.getAlteration(entity, key)
			if(key == Stats.HP) 			totalScore+= entity.isFriend ? value : -value
			if(key == Stats.ABSSHIELD) 	totalScore+= entity.isFriend ? value*3 : -(value*3)
			if(key == Stats.STR) 		totalScore+= entity.isFriend ? value : -value
			
		}
		for(Entity entity:var bool in this._killed){
			var killScore = 10000
			killScore*= entity.isBulb ? 0.5 : 1
			totalScore+= entity.isFriend ? -killScore : killScore
		}
		return totalScore
	}*/
	
	string string(){
		string str = "<Consequences"
		for(Entity entity:Map<integer, integer> alteration in this._alterations){
			str+= "\n" + entity.name + ":"
			for(string strKey in Stats.getFields()){
				integer key = Stats.getInstance()[strKey] as integer
				//var key = Stats.getInstance()[strKey]
				if(alteration[key] != null) str+= "|"+strKey+": "+round(alteration[key]!)
			}
			/*
			for(var key:var value in alteration){
				if(key == Stats.HP) 			str+= "|HP: "+round(value)
				if(key == Stats.ABSSHIELD) 	str+= "|ABSSHIELD: "+round(value)
				if(key == Stats.STR) 		str+= "|STR: "+round(value)
			}
			*/
		}
		for(Entity entity:var isDead in this._killed) str+= "\n|KILL: "+ entity
		str+="\nhashcode:"+this.hashcode+">"
		return str
	}
}