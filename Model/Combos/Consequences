class Consequences {
	Map<Entity, Map<integer, integer>> _alterations = [:]// [entity:[caracteristic:value]]
	Map<Entity, Map<Item, Array<EffectOverTime>>> _altEffects = [:]// [entity:[item:[EffectOverTime]]]
	Map<Entity, Entity> _killed = [:]
	real? score = null
	boolean isAlteringDanger = false
	integer hashcode = 17
	Array<Entity> targets = []
	Cell currentCell
	integer currentMP
	private integer _boostMP_before = 0


	/*
	 * Empty constructor for MCTS root node (no previous actions)
	 */
	constructor() {
		this.currentCell = Fight.self.cell
		this.currentMP = Fight.self.mp
		this.score = 0.0
	}

	constructor(Action action){
		Benchmark.start("Consequences")
		this.currentCell = Fight.self.cell
		this.currentMP = Fight.self.mp
		this.score = 0.0  // Must initialize before construct() modifies it
		construct(action)
		Benchmark.stop("Consequences")
	}
	
	constructor(Action action, Consequences consequences){
		Benchmark.start("Consequences.fromConseq")
		this.currentCell = consequences.currentCell
		this.currentMP = consequences.currentMP
		this._alterations = clone(consequences._alterations, 2) as Map<Entity, Map<integer, integer>>
		this._altEffects = clone(consequences._altEffects, 3) as Map<Entity, Map<Item, Array<EffectOverTime>>>
		this._killed = clone(consequences._killed) as Map<Entity, Entity>
		this.hashcode = consequences.hashcode
		this.score = consequences.score != null ? consequences.score : 0.0  // Inherit parent score
		construct(action)
		Benchmark.stop("Consequences.fromConseq")
	}
	
	construct(Action action){
		// actualisation du placement virtuel :
		Map<Cell, integer> reachableCells = MapPath.getCachedReachableCells(this.currentCell, this.currentMP, Fight.self.cellsToIgnore)
		// déplacement jusqu'à la case de l'action
		if(action.from != Fight.selfCell){
			if(reachableCells[action.from] != null) this.currentMP = this.currentMP - reachableCells[action.from]
			else debugW('Impossible action: unreachable cell !!\n'+action+'\n'+this)
			if(this.currentMP < 0) debugW('Impossible action: negative MP !!\n'+action+'\n'+this)
			// actualisation de la case actuelle
			this.currentCell = action.from
		}
		// on retient les boosts mp déjà appliquer à soit mm pour après
		integer? boostMPbefore = this._alterations[Fight.self] != null ? this._alterations[Fight.self]![Stats.MP] : null

		// actualisation des conséquences de l'action sur le jeu
		this.targets = Targets.getTargets(action)
		for(Entity target in this.targets){
			if(this._killed[target]) continue
			// For self in AOE, use simulated position (this.currentCell) not real position (target.cell)
			integer targetCellId = (target == Fight.self) ? this.currentCell.id : target.cell.id
			real ratioDmg = action.item.isAOE ? 1-(0.2*getCellDistance(action.to.id, targetCellId)) : 1.0
			if(ratioDmg<=0){
				debugE('Bug in Consequences: ratioDmg<=0 for target ' + target + ' at cell ' + targetCellId)
				debugE(action)
				continue
			}
			for(ItemEffect effect in action.item.effects) {
				this.updateConsequences(effect, Fight.self, target, ratioDmg)
			}
		}

		// actualisation des MP en cas de self boost de mp
		integer? boostMP = this.getAlteration(Fight.self, Stats.MP)  // Use safe accessor
		// si je viens de m'ajouter des MP
		if(boostMP != null && boostMP > boostMPbefore){
			this.currentMP += boostMP - boostMPbefore // j'ajoute les mp gagnés
		}

		// Cooldown opportunity cost: penalize using CD items for marginal gains
		this.score -= action.item.cdDuration
	}

	void add(Entity entity, integer key, EffectOverTime|integer effect){
		if(!_alterations[entity]) _alterations[entity] = [:]
		boolean isOverTime = effect instanceof EffectOverTime
		integer value = isOverTime ? (effect as EffectOverTime).value : effect as integer
		if(isOverTime){
			if(!_altEffects[entity]) _altEffects[entity] = [:]
			if(!_altEffects[entity]![(effect as EffectOverTime).item]) _altEffects[entity]![(effect as EffectOverTime).item] = []

			push(_altEffects[entity]![(effect as EffectOverTime).item]!, (effect as EffectOverTime))
		}
		_alterations[entity]![key] += value // pour null, devrait se comporter comme si ça contenait 0
		// ça ne marche qu'avec += en leekscriptv1, pas tester en v1.1 comment ça marche...
		// j'avais des bugs sur les -=, donc il faut faire += -value si le comportement est le mm ici.

		if(entity==Fight.self && (
			   key==Stats.HP
			|| key==Stats.ABSSHIELD
			|| key==Stats.RELSHIELD
			|| key==Stats.DEBUFF)){
				this.isAlteringDanger=true
				this.hashcode = 31 * this.hashcode + (value|0)
		} else if(!entity.isFriend && (
			   key==Stats.DEBUFF
			|| key==Stats.STR
			|| key==Stats.TP
			|| key==Stats.MP)){
				this.isAlteringDanger=true
				this.hashcode = 31 * this.hashcode + entity.id
				this.hashcode = 31 * this.hashcode + (value|0)
		}

		// update du score (using dynamic coefficients for situational modifiers)
		real coef = Scoring.getDynamicCoef(entity, key, this)
		real scoreDelta = value * coef
		if(!isOverTime) this.score += scoreDelta
		else this.score += scoreDelta * ScoringConfig.offensive_duration_mitigation[(effect as EffectOverTime).duration]!
	}
	
	void addKill(Entity entity){
		this.isAlteringDanger=true
		this.hashcode = 31 * this.hashcode + entity.id
		this._killed[entity]=entity
		this.score+= ScoringConfig.KILL_VALUE * Scoring.getDynamicCoef(entity, Stats.KILL, this)
		// Inline passive for kill
		Map<integer, real> passives = Fight.self.passives
		if(passives[EFFECT_KILL_TO_TP]) {
			integer tpGain = round(passives[EFFECT_KILL_TO_TP]!)
			if(tpGain > 0) this.add(Fight.self, Stats.TP, tpGain)
		}
		// Chest power gain (all fight types): 10 + 50% pwr + type bonus (wood +10, iron +50, diamond +100)
		if(entity.entityType == ENTITY_CHEST) {
			integer chestBonus = 0
			if(entity.name == "wood_chest") chestBonus = 10
			else if(entity.name == "iron_chest") chestBonus = 50
			else if(entity.name == "diamond_chest") chestBonus = 100
			integer pwrGain = 10 + chestBonus + round(entity.pwr * 0.5)
			this.add(Fight.self, Stats.PWR, pwrGain)
		}
		// BR power gain (leek = 10 + 50% pwr, bulb = 2 + 50% pwr)
		else if(Fight.isBattleRoyale) {
			integer basePwr = entity.isBulb ? 2 : 10
			integer pwrGain = basePwr + round(entity.pwr * 0.5)
			this.add(Fight.self, Stats.PWR, pwrGain)
		}
	}
	
	Map<Entity, Map<integer, integer>> getAlterations(){
		return _alterations
	}
		
	boolean isKilled(Entity entity){
		return _killed[entity] != null
	}
	
	integer? getAlteration(Entity entity, integer key){
		if(_alterations[entity] == null) return null
		return _alterations[entity]![key]
	}
	
	real? getScore(){
		return this.score
	}
	
	void updateConsequences(ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg) {
		// fixme: ce if marche pas, j'ai tjr true mm pour EFFECT_DAMAGE :'(
		if(Consequences.convertToValue[effect.type] == null) debugW('unhandledEffect on effect: '+ effect)
		Entity target = effect.modifCaster ? entitySource : entityTarget
		ratioDmg = effect.modifCaster ? 1.0 : ratioDmg;

		(Consequences.convertToValue[effect.type]!)(effect, entitySource, target, ratioDmg, this)
	}

	// TODO reste à faire l'agi/les crit, et avgmin/avgmax ?
	// TODO EROSION sur la durée ?
	static Map<integer, Function<ItemEffect, Entity, Entity, real, Consequences => void>> convertToValue = [
		EFFECT_DAMAGE: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			integer targetsCount = effect.multiplyByTarget ? count(conseq.targets) : 1
			real beforeShield = effect.avg *targetsCount *ratioDmg *(1+(entitySource.getCurrentStr(conseq)/100))
				*(1+(entitySource.getCurrentPwr(conseq)/100)) // TODO power in consequences !!!!
			real value = (beforeShield *(1-(entityTarget.getCurrentRel(conseq)/100)))
				- entityTarget.getCurrentAbs(conseq)
			value = value < 0 ? 0.0 : value // on ne fait pas de dmg négatif
			conseq.add(entityTarget, Stats.HP, -round(value))

			// Inline passives for damage taken (target's passives)
			Map<integer, real> passives = entityTarget.passives
			if(passives[EFFECT_DAMAGE_TO_STRENGTH]) {
				integer strGain = round(value * passives[EFFECT_DAMAGE_TO_STRENGTH]!)
				if(strGain > 0) conseq.add(entityTarget, Stats.STR, strGain)
			}
			if(passives[EFFECT_DAMAGE_TO_ABSOLUTE_SHIELD]) {
				integer shieldGain = round(value * passives[EFFECT_DAMAGE_TO_ABSOLUTE_SHIELD]!)
				if(shieldGain > 0) conseq.add(entityTarget, Stats.ABSSHIELD, shieldGain)
			}

			if(entityTarget.getCurrentHP(conseq) <= 0)
				conseq.addKill(entityTarget)
			// TODO if killed leek, add all bulb in kill, if tower add win score ?

			// érosion !
			real erosion = value / Stats.DMG_EROSION_DIVISOR
			conseq.add(entityTarget, Stats.HPMAX, -round(erosion))
			// Inline passive for nova/erosion
			if(passives[EFFECT_NOVA_DAMAGE_TO_MAGIC]) {
				integer magicGain = round(erosion * passives[EFFECT_NOVA_DAMAGE_TO_MAGIC]!)
				if(magicGain > 0) conseq.add(entityTarget, Stats.MGC, magicGain)
			}

			// vol de vie
			integer lifeSteal = round(value * (entitySource.getCurrentWsd(conseq)/1000))
			integer lifeMissing = entitySource.getCurrentHPMissing(conseq)
			lifeSteal = lifeSteal>lifeMissing ? lifeMissing : lifeSteal
			if(lifeSteal>0) conseq.add(entitySource, Stats.HP, lifeSteal)

			// dmg return
			var dmgReturn = beforeShield * (entityTarget.getCurrentDmgReturn(conseq)/100)
			if(dmgReturn>0){
				conseq.add(entitySource, Stats.HP, -round(dmgReturn))
				
				// érosion !
				conseq.add(entitySource, Stats.HPMAX, round(-dmgReturn/Stats.DMG_EROSION_DIVISOR))
				
				if(dmgReturn>=entitySource.getCurrentHP(conseq)) 
					conseq.addKill(entitySource) 
			}
		},
		EFFECT_POISON: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			// pas de tests sur stackable car tous les poisons sont stackable actuellement
			// devrait être au niveau au dessus si d'autres items que covid ont notReplaceable, en attendant, ici on économise des opérations.
			if(effect.notReplaceable){
				if(entityTarget.getCurrentItemEffect(effect.item, conseq)) return;
			}

			// FIXME: dans mon autre IA, je gère deux notions, les dmgNextTurn, qui pemettent de définir un kill
			// en solo, et les dmg*duration, qui doivent être minoré plus ça dure
			// TODO handle kill condition selon si la cible peut s'antidote/libé ?

			integer value = round(effect.avg *(1+(entitySource.getCurrentMgc(conseq)/100)) *ratioDmg
				*(1+(entitySource.getCurrentPwr(conseq)/100)) *effect.duration) // TODO power in consequences !!!!
			EffectOverTime eot = EffectOverTime(effect.item, -value, effect.duration)
			conseq.add(entityTarget, Stats.HPTIME, eot)

			// Inline passive for poison taken (target's passives)
			Map<integer, real> passives = entityTarget.passives
			if(passives[EFFECT_POISON_TO_SCIENCE]) {
				integer sciGain = round(effect.avg * passives[EFFECT_POISON_TO_SCIENCE]!)
				if(sciGain > 0) conseq.add(entityTarget, Stats.SNC, sciGain)
			}

			// érosion ! only 1 turn (often antidoted/liberated)
			real erosion = value / effect.duration / Stats.PSN_EROSION_DIVISOR
			conseq.add(entityTarget, Stats.HPMAX, -round(erosion))
			// Inline passive for nova/erosion
			if(passives[EFFECT_NOVA_DAMAGE_TO_MAGIC]) {
				integer magicGain = round(erosion * passives[EFFECT_NOVA_DAMAGE_TO_MAGIC]!)
				if(magicGain > 0) conseq.add(entityTarget, Stats.MGC, magicGain)
			}
		},
		EFFECT_LIFE_DAMAGE: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			real beforeShield = entitySource.life * (effect.avg/100) * (1 + entitySource.getCurrentPwr(conseq)/100)
			integer value = round((beforeShield * (1-(entityTarget.getCurrentRel(conseq)/100)))
				- entityTarget.getCurrentAbs(conseq))
			value = value < 0 ? 0 : value // on ne fait pas de dmg négatif
			conseq.add(entityTarget, Stats.HP, -value)

			if(entityTarget.getCurrentHP(conseq) <= 0)
				conseq.addKill(entityTarget)
			// TODO if killed leek, add all bulb in kill, if tower add win score ?

			// érosion !
			real erosion = value / Stats.DMG_EROSION_DIVISOR
			conseq.add(entityTarget, Stats.HPMAX, -round(erosion))
			// Inline passive for nova/erosion (target's passives)
			Map<integer, real> passives = entityTarget.passives
			if(passives[EFFECT_NOVA_DAMAGE_TO_MAGIC]) {
				integer magicGain = round(erosion * passives[EFFECT_NOVA_DAMAGE_TO_MAGIC]!)
				if(magicGain > 0) conseq.add(entityTarget, Stats.MGC, magicGain)
			}

			if(entityTarget != entitySource){
				// dmg return
				integer dmgReturn = round(beforeShield * (entityTarget.getCurrentDmgReturn(conseq)/100))
				if(dmgReturn>0){
					conseq.add(entitySource, Stats.HP, -dmgReturn)
					// érosion !
					conseq.add(entitySource, Stats.HPMAX, round(-dmgReturn/Stats.DMG_EROSION_DIVISOR))
					
					if(dmgReturn>=entitySource.getCurrentHP(conseq))
						conseq.addKill(entitySource) 
				}
			}
		},
		EFFECT_NOVA_DAMAGE: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			integer value = round(effect.avg * (1 + entitySource.getCurrentSnc(conseq)/100) * (1 + entitySource.getCurrentPwr(conseq)/100) * ratioDmg)
			value = min(value, entityTarget.getCurrentHPMissing(conseq))
			conseq.add(entityTarget, Stats.HPMAX, -value)
			// Inline passive for nova (target's passives)
			Map<integer, real> passives = entityTarget.passives
			if(passives[EFFECT_NOVA_DAMAGE_TO_MAGIC]) {
				integer magicGain = round(value * passives[EFFECT_NOVA_DAMAGE_TO_MAGIC]!)
				if(magicGain > 0) conseq.add(entityTarget, Stats.MGC, magicGain)
			}
		},
		EFFECT_HEAL: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			if(effect.duration>1){ // HPTIME
				if(!effect.stackable){
					EffectOverTime? itemEffect = entityTarget.getCurrentItemEffect(effect.item, conseq)
					if(itemEffect){
						EffectOverTime eot = EffectOverTime(effect.item, -itemEffect!.value, itemEffect!.duration)
						conseq.add(entityTarget, Stats.HPTIME, eot)
					}
				}
				integer value = round(effect.avg*(1+(entitySource.getCurrentWsd(conseq)/100)) *ratioDmg)
				EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration)
				conseq.add(entityTarget, Stats.HPTIME, eot)
			} else { // HP
				integer value = round(effect.avg*(1+(entitySource.getCurrentWsd(conseq)/100)) *ratioDmg)
				value = min(value, entityTarget.getCurrentHPMissing(conseq))
				conseq.add(entityTarget, Stats.HP, value)
			}
		},
		EFFECT_BOOST_MAX_LIFE: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			integer value = round(effect.avg *(1+(entitySource.getCurrentWsd(conseq)/100)) *ratioDmg)
			conseq.add(entityTarget, Stats.HPMAX, value)
			conseq.add(entityTarget, Stats.HP, value)
		},
		EFFECT_NOVA_VITALITY: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			integer value = round(effect.avg *(1+(entitySource.getCurrentSnc(conseq)/100)) *ratioDmg)
			conseq.add(entityTarget, Stats.HPMAX, value)
		},
		EFFECT_ABSOLUTE_SHIELD: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			if(!effect.stackable){
				EffectOverTime? itemEffect = entityTarget.getCurrentItemEffect(effect.item, conseq)
				if(itemEffect){
					EffectOverTime eot = EffectOverTime(effect.item, -itemEffect!.value, itemEffect!.duration)
					conseq.add(entityTarget, Stats.ABSSHIELD, eot)
				}
			}
			integer value = round(effect.avg*(1+(entitySource.getCurrentRst(conseq)/100)) *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration)
			conseq.add(entityTarget, Stats.ABSSHIELD, eot)
		},
		EFFECT_RELATIVE_SHIELD: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			if(!effect.stackable){
				EffectOverTime? itemEffect = entityTarget.getCurrentItemEffect(effect.item, conseq)
				if(itemEffect){
					EffectOverTime eot = EffectOverTime(effect.item, -itemEffect!.value, itemEffect!.duration)
					conseq.add(entityTarget, Stats.RELSHIELD, eot)
				}
			}
			integer value = round(effect.avg*(1+(entitySource.getCurrentRst(conseq)/100)) *ratioDmg) // *effect.duration
			EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration)
			conseq.add(entityTarget, Stats.RELSHIELD, value)
		},
		EFFECT_ABSOLUTE_VULNERABILITY: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			// pas de check stackable car always stackable actuellement
			integer value = round(effect.avg *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, -value, effect.duration)
			conseq.add(entityTarget, Stats.ABSSHIELD, eot)
		},
		EFFECT_VULNERABILITY: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			// pas de check stackable car always stackable actuellement
			integer value = round(effect.avg *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, -value, effect.duration)
			conseq.add(entityTarget, Stats.RELSHIELD, eot)
		},
		EFFECT_STEAL_ABSOLUTE_SHIELD: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			// pas de check stackable car always stackable actuellement
			integer value = round(effect.avg *ratioDmg) // *effect.duration
			EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration)
			conseq.add(entityTarget, Stats.ABSSHIELD, eot)
		},
		EFFECT_DAMAGE_RETURN: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			if(!effect.stackable){
				EffectOverTime? itemEffect = entityTarget.getCurrentItemEffect(effect.item, conseq)
				if(itemEffect){
					EffectOverTime eot = EffectOverTime(effect.item, -itemEffect!.value, itemEffect!.duration)
					conseq.add(entityTarget, Stats.DMGRETURN, eot)
				}
			}
			integer value = round(effect.avg *(1+(entitySource.getCurrentAgi(conseq)/100)) *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration)
			conseq.add(entityTarget, Stats.DMGRETURN, eot)
		},
		EFFECT_RAW_BUFF_STRENGTH: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			if(!effect.stackable){
				EffectOverTime? itemEffect = entityTarget.getCurrentItemEffect(effect.item, conseq)
				if(itemEffect){
					EffectOverTime eot = EffectOverTime(effect.item, -itemEffect!.value, itemEffect!.duration)
					conseq.add(entityTarget, Stats.STR, eot)
				}
			}
			integer value = round(effect.avg *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration)
			conseq.add(entityTarget, Stats.STR, eot)
		},
		EFFECT_RAW_BUFF_MAGIC: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			if(!effect.stackable){
				EffectOverTime? itemEffect = entityTarget.getCurrentItemEffect(effect.item, conseq)
				if(itemEffect){
					EffectOverTime eot = EffectOverTime(effect.item, -itemEffect!.value, itemEffect!.duration)
					conseq.add(entityTarget, Stats.MGC, eot)
				}
			}
			integer value = round(effect.avg *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration)
			conseq.add(entityTarget, Stats.MGC, eot)
		},
		EFFECT_RAW_BUFF_AGILITY: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			if(!effect.stackable){
				EffectOverTime? itemEffect = entityTarget.getCurrentItemEffect(effect.item, conseq)
				if(itemEffect){
					EffectOverTime eot = EffectOverTime(effect.item, -itemEffect!.value, itemEffect!.duration)
					conseq.add(entityTarget, Stats.AGI, eot)
				}
			}
			integer value = round(effect.avg *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration)
			conseq.add(entityTarget, Stats.AGI, eot)
		},
		EFFECT_RAW_BUFF_WISDOM: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			if(!effect.stackable){
				EffectOverTime? itemEffect = entityTarget.getCurrentItemEffect(effect.item, conseq)
				if(itemEffect){
					EffectOverTime eot = EffectOverTime(effect.item, -itemEffect!.value, itemEffect!.duration)
					conseq.add(entityTarget, Stats.WSD, eot)
				}
			}
			integer value = round(effect.avg *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration)
			conseq.add(entityTarget, Stats.WSD, eot)
		},
		EFFECT_RAW_BUFF_RESISTANCE: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			if(!effect.stackable){
				EffectOverTime? itemEffect = entityTarget.getCurrentItemEffect(effect.item, conseq)
				if(itemEffect){
					EffectOverTime eot = EffectOverTime(effect.item, -itemEffect!.value, itemEffect!.duration)
					conseq.add(entityTarget, Stats.RST, eot)
				}
			}
			integer value = round(effect.avg *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration)
			conseq.add(entityTarget, Stats.RST, eot)
		},
		EFFECT_RAW_BUFF_TP: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			if(!effect.stackable){
				EffectOverTime? itemEffect = entityTarget.getCurrentItemEffect(effect.item, conseq)
				if(itemEffect){
					EffectOverTime eot = EffectOverTime(effect.item, -itemEffect!.value, itemEffect!.duration)
					conseq.add(entityTarget, Stats.TP, eot)
				}
			}
			integer value = round(effect.avg *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration)
			conseq.add(entityTarget, Stats.TP, eot)
		},
		EFFECT_RAW_BUFF_MP: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			if(!effect.stackable){
				EffectOverTime? itemEffect = entityTarget.getCurrentItemEffect(effect.item, conseq)
				if(itemEffect){
					// entityEffects[0].value : if not stackable, only 1 effect in array, so [0]
					EffectOverTime eot = EffectOverTime(effect.item, -itemEffect!.value, itemEffect!.duration)
					conseq.add(entityTarget, Stats.MP, eot)
				}
			}
			integer value = round(effect.avg *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration)
			conseq.add(entityTarget, Stats.MP, eot)
		},
		EFFECT_BUFF_STRENGTH: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			if(!effect.stackable){
				EffectOverTime? itemEffect = entityTarget.getCurrentItemEffect(effect.item, conseq)
				if(itemEffect){
					EffectOverTime eot = EffectOverTime(effect.item, -itemEffect!.value, itemEffect!.duration)
					conseq.add(entityTarget, Stats.STR, eot)
				}
			}
			integer value = round(effect.avg *(1+(entitySource.getCurrentSnc(conseq)/100)) *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration)
			conseq.add(entityTarget, Stats.STR, eot)
		},
		EFFECT_BUFF_AGILITY: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			if(!effect.stackable){
				EffectOverTime? itemEffect = entityTarget.getCurrentItemEffect(effect.item, conseq)
				if(itemEffect){
					EffectOverTime eot = EffectOverTime(effect.item, -itemEffect!.value, itemEffect!.duration)
					conseq.add(entityTarget, Stats.AGI, eot)
				}
			}
			integer value = round(effect.avg *(1+(entitySource.getCurrentSnc(conseq)/100)) *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration)
			conseq.add(entityTarget, Stats.AGI, eot)
		},
		EFFECT_BUFF_WISDOM: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			if(!effect.stackable){
				EffectOverTime? itemEffect = entityTarget.getCurrentItemEffect(effect.item, conseq)
				if(itemEffect){
					EffectOverTime eot = EffectOverTime(effect.item, -itemEffect!.value, itemEffect!.duration)
					conseq.add(entityTarget, Stats.WSD, eot)
				}
			}
			integer value = round(effect.avg *(1+(entitySource.getCurrentSnc(conseq)/100)) *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration)
			conseq.add(entityTarget, Stats.WSD, eot)
		},
		EFFECT_BUFF_RESISTANCE: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			if(!effect.stackable){
				EffectOverTime? itemEffect = entityTarget.getCurrentItemEffect(effect.item, conseq)
				if(itemEffect){
					EffectOverTime eot = EffectOverTime(effect.item, -itemEffect!.value, itemEffect!.duration)
					conseq.add(entityTarget, Stats.RST, eot)
				}
			}
			integer value = round(effect.avg *(1+(entitySource.getCurrentSnc(conseq)/100)) *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration)
			conseq.add(entityTarget, Stats.RST, eot)
		},
		EFFECT_BUFF_TP: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			if(!effect.stackable){
				EffectOverTime? itemEffect = entityTarget.getCurrentItemEffect(effect.item, conseq)
				if(itemEffect){
					EffectOverTime eot = EffectOverTime(effect.item, -itemEffect!.value, itemEffect!.duration)
					conseq.add(entityTarget, Stats.TP, eot)
				}
			}
			integer value = round(effect.avg *(1+(entitySource.getCurrentSnc(conseq)/100)) *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration)
			conseq.add(entityTarget, Stats.TP, eot)
		},
		EFFECT_BUFF_MP: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			if(!effect.stackable){
				EffectOverTime? itemEffect = entityTarget.getCurrentItemEffect(effect.item, conseq)
				if(itemEffect){
					EffectOverTime eot = EffectOverTime(effect.item, -itemEffect!.value, itemEffect!.duration)
					conseq.add(entityTarget, Stats.MP, eot)
				}
			}
			integer value = round(effect.avg *(1+(entitySource.getCurrentSnc(conseq)/100)) *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration)
			conseq.add(entityTarget, Stats.MP, eot)
		},
		EFFECT_SHACKLE_STRENGTH: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			// pas de tests sur stackable car toutes les entraves sont stackable actuellement
			integer value = round(effect.avg *(1+(entitySource.getCurrentMgc(conseq)/100)) *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, -value, effect.duration)
			conseq.add(entityTarget, Stats.STR, eot)
		},
		EFFECT_SHACKLE_MAGIC: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			// pas de tests sur stackable car toutes les entraves sont stackable actuellement
			integer value = round(effect.avg *(1+(entitySource.getCurrentMgc(conseq)/100)) *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, -value, effect.duration)
			conseq.add(entityTarget, Stats.MGC, eot)
		},
		EFFECT_SHACKLE_AGILITY: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			// pas de tests sur stackable car toutes les entraves sont stackable actuellement
			integer value = round(effect.avg *(1+(entitySource.getCurrentMgc(conseq)/100)) *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, -value, effect.duration)
			conseq.add(entityTarget, Stats.AGI, eot)
		},
		EFFECT_SHACKLE_WISDOM: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			// pas de tests sur stackable car toutes les entraves sont stackable actuellement
			integer value = round(effect.avg *(1+(entitySource.getCurrentMgc(conseq)/100)) *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, -value, effect.duration)
			conseq.add(entityTarget, Stats.WSD, eot)
		},
		EFFECT_SHACKLE_TP: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			// pas de tests sur stackable car toutes les entraves sont stackable actuellement
			integer value = round(effect.avg *(1+(entitySource.getCurrentMgc(conseq)/100)) *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, -value, effect.duration)
			conseq.add(entityTarget, Stats.TP, eot)
		},
		EFFECT_SHACKLE_MP: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			// pas de tests sur stackable car toutes les entraves sont stackable actuellement
			integer value = round(effect.avg *(1+(entitySource.getCurrentMgc(conseq)/100)) *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, -value, effect.duration)
			conseq.add(entityTarget, Stats.MP, eot)
		},
		EFFECT_DEBUFF: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			for(EntityEffect entityEffect in entityTarget.effects){
				// Skip irreducible effects - Liberation can't reduce them
				if(entityEffect.modifiers & EFFECT_MODIFIER_IRREDUCTIBLE) continue
				// ici le CONVERTER sert à set la value en négatif si c'est un malus, genre un poison fait
				// des dmg en HPTIME, il en redonne pas.
				// parce que je boucle sur entityEffect et EffectOverTime
				// dans EffectOverTime j'ai une valeur +/- en fonction de Stats
				// dans entityEffect j'ai la valeur de l'effet, tjr positive
				// maybe mettre en négatif directement dans entityEffect ?
				// c'est pas terrible de faire la conversion ici je trouve...
				
				// FIXME pour tous les effets !stackable je renvoie le dernier effet
				// cette façon de faire ne marche pas pour récup le dernier effet
				// je devrais faire -100% puis + le reste après 60% de reduc
				
				integer value = round(entityEffect.value * (effect.avg/100) *TargetType.CONVERTER[entityEffect.type])
				EffectOverTime eot = EffectOverTime(effect.item, -value, entityEffect.turns)
				integer? stat = Stats.entityEffectType_to_stats[entityEffect.type]
				if(stat==null) debugE("LIBERATION effect to stat unhandled :"+entityEffect)
				conseq.add(entityTarget, stat!, eot)
			}
		},
		EFFECT_ANTIDOTE: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			for(EntityEffect entityEffect in entityTarget.effects){
				if(entityEffect.type == EFFECT_POISON){
					EffectOverTime eot = EffectOverTime(effect.item, entityEffect.value, entityEffect.turns)
					conseq.add(entityTarget, Stats.HPTIME, eot)
				}
			}
		},
		EFFECT_KILL: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			// je met un commentaire parce que une seule ligne ça fait vide lol
			// je pourrais mettre aussi une conseq full life dmg pour scorer les dégats comme pour un dmg normal.
			// et si un jour on peut kill les leeks/tower faut check les winconditions & kill les bulbs du leek
			conseq.addKill(entityTarget)
		},
		EFFECT_AFTEREFFECT: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			integer value = round(effect.avg *(1+(entitySource.getCurrentMgc(conseq)/100)) *ratioDmg)
			EffectOverTime eot = EffectOverTime(effect.item, -value, effect.duration)
			conseq.add(entityTarget, Stats.HP, -value)
			conseq.add(entityTarget, Stats.HPTIME, eot)

			// érosion ! only 1 turn (often antidoted/liberated)
			real erosion = value / Stats.DMG_EROSION_DIVISOR
			conseq.add(entityTarget, Stats.HPMAX, -round(erosion))
			// Inline passive for nova/erosion (target's passives)
			Map<integer, real> passives = entityTarget.passives
			if(passives[EFFECT_NOVA_DAMAGE_TO_MAGIC]) {
				integer magicGain = round(erosion * passives[EFFECT_NOVA_DAMAGE_TO_MAGIC]!)
				if(magicGain > 0) conseq.add(entityTarget, Stats.MGC, magicGain)
			}
		},
		EFFECT_PROPAGATION: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			// handled in Position as this is a placement issue.
		},
		EFFECT_REMOVE_SHACKLES: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {},
		EFFECT_TELEPORT: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {},
		EFFECT_INVERT: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {},
		EFFECT_PUSH: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {},
		EFFECT_ATTRACT: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {},
		EFFECT_SUMMON: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {},
		EFFECT_RESURRECT: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {},
		
		// Flat per-attack buffs (entityTarget is caster due to modifCaster)
		EFFECT_RAW_ABSOLUTE_SHIELD: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			EffectOverTime eot = EffectOverTime(effect.item, round(effect.avg), effect.duration)
			conseq.add(entityTarget, Stats.ABSSHIELD, eot)
		},
		EFFECT_RAW_RELATIVE_SHIELD: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			EffectOverTime eot = EffectOverTime(effect.item, round(effect.avg), effect.duration)
			conseq.add(entityTarget, Stats.RELSHIELD, eot)
		},
		EFFECT_RAW_BUFF_POWER: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			EffectOverTime eot = EffectOverTime(effect.item, round(effect.avg), effect.duration)
			conseq.add(entityTarget, Stats.PWR, eot)
		},
		EFFECT_RAW_BUFF_SCIENCE: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {},
		
		// Movement effects (not scored - would need position simulation)
		EFFECT_REPEL: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {},

		// Other target-based effects
		EFFECT_TOTAL_DEBUFF: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			// Similar to DEBUFF but removes ALL buffs, not just a percentage
			// TODO: implement full debuff logic
		},
		EFFECT_STEAL_LIFE: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			// Damage that heals caster - like EFFECT_DAMAGE + heal
			// TODO: implement life steal logic
		},
		
		// passif
		EFFECT_POISON_TO_SCIENCE: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {},
		EFFECT_MOVED_TO_MP: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {},
		EFFECT_NOVA_DAMAGE_TO_MAGIC: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {},
		EFFECT_DAMAGE_TO_ABSOLUTE_SHIELD: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {},
		EFFECT_DAMAGE_TO_STRENGTH: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {},
		EFFECT_ALLY_KILLED_TO_AGILITY: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {},
		EFFECT_KILL_TO_TP: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {},
		EFFECT_CRITICAL_TO_HEAL: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {},

		// raw heal - instant heal without wisdom scaling
		EFFECT_RAW_HEAL: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			integer value = round(effect.avg * ratioDmg)
			value = min(value, entityTarget.getCurrentHPMissing(conseq))
			conseq.add(entityTarget, Stats.HP, value)
		},

		// add state - applies special states (stunned, etc.)
		// TODO: proper state tracking - for now just log it
		EFFECT_ADD_STATE: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
			// States have various effects (stunned = skip turn, burning = DoT, etc.)
			// For now we don't track states in consequences - would need state->effect mapping
		},
	]
	
	/*
	//Non utilisée et buggué 
	computeScore(){
		var totalScore = 0;
		for(Entity  entity:Map<integer, integer> key in this._alterations){
			var value = this.getAlteration(entity, key)
			if(key == Stats.HP) 			totalScore+= entity.isFriend ? value : -value
			if(key == Stats.ABSSHIELD) 	totalScore+= entity.isFriend ? value*3 : -(value*3)
			if(key == Stats.STR) 		totalScore+= entity.isFriend ? value : -value
			
		}
		for(Entity entity:var bool in this._killed){
			var killScore = 10000
			killScore*= entity.isBulb ? 0.5 : 1
			totalScore+= entity.isFriend ? -killScore : killScore
		}
		return totalScore
	}*/
	
	string string(){
		string str = "<Consequences"
		for(Entity entity:Map<integer, integer> alteration in this._alterations){
			str+= "\n" + entity.name + ":"
			for(string strKey in Stats.getFields()){
				integer key = Stats.getInstance()[strKey] as integer
				//var key = Stats.getInstance()[strKey]
				if(alteration[key] != null) str+= "|"+strKey+": "+round(alteration[key]!)
			}
			/*
			for(var key:var value in alteration){
				if(key == Stats.HP) 			str+= "|HP: "+round(value)
				if(key == Stats.ABSSHIELD) 	str+= "|ABSSHIELD: "+round(value)
				if(key == Stats.STR) 		str+= "|STR: "+round(value)
			}
			*/
		}
		for(Entity entity:var isDead in this._killed) str+= "\n|KILL: "+ entity
		str+="\nhashcode:"+this.hashcode+">"
		return str
	}
}