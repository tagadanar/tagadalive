class Damages {
	/*
	 * Calcule le danger sur une cellule en prenant en compte:
	 * - Les dommages des ennemis (EFFECT_DAMAGE → dmg, EFFECT_POISON → psnDmg)
	 * - Les heals des alliés (réduisent dmg/psnDmg selon le type d'effet)
	 * - L'ordre de jeu (turn order) pour un calcul séquentiel correct
	 *
	 * @param cell Cellule sur laquelle le danger va être calculé
	 * @param consequences Consequences qui contient les altérations de la série d'action précédente
	 * @return un objet Danger avec dmg (HP) et psnDmg (HPTIME) séparés
	 */
	static Danger computeDanger(Cell cell, Consequences? consequences) {
		real dmg = 0.0      // HP damage (instant)
		real psnDmg = 0.0   // HPTIME damage (poison over time)
		string str = ""

		// Track HP state for heal capping
		real currentLife = Fight.self.getCurrentHP(consequences)
		real maxLife = Fight.self.getCurrentMaxHP(consequences)

		// Track shield state (existing + ally contributions)
		real absShield = Fight.self.getCurrentAbs(consequences)
		real relShield = Fight.self.getCurrentRel(consequences)

		// Pre-compute shields expiring when each caster plays (turns == 1)
		Map<integer, real> expiringAbs = [:]
		Map<integer, real> expiringRel = [:]
		for (EntityEffect ef in Fight.self.effects) {
			if (ef.turns != 1) continue
			integer cId = ef.caster.id
			if (ef.type == EFFECT_ABSOLUTE_SHIELD || ef.type == EFFECT_RAW_ABSOLUTE_SHIELD) {
				if (expiringAbs[cId] == null) expiringAbs[cId] = 0.0
				expiringAbs[cId] = expiringAbs[cId]! + ef.value
			} else if (ef.type == EFFECT_RELATIVE_SHIELD || ef.type == EFFECT_RAW_RELATIVE_SHIELD) {
				if (expiringRel[cId] == null) expiringRel[cId] = 0.0
				expiringRel[cId] = expiringRel[cId]! + ef.value
			}
		}
		real libeFactor = 1.0

		// Process entities in turn order (after self, wrapping around)
		for (Entity e in Fight.getEntitiesAfterSelfInOrder()) {
			if (consequences && consequences!.isKilled(e)) continue

			// Subtract shields expiring when this entity plays (scaled by liberation)
			real? expAbs = expiringAbs[e.id]
			if (expAbs != null) absShield -= expAbs! * libeFactor
			real? expRel = expiringRel[e.id]
			if (expRel != null) relShield -= expRel! * libeFactor

			if (!e.isFriend) {
				// === ENEMY: Add damage ===
				// Check if enemy can reach this cell (from danger map)
				if (MapDanger._map_entity_item_danger[e] == null) continue

				integer tpLeft = e.getCurrentTP(consequences)
				boolean jumpCharged = false
				integer jumpCost = (e.jumpItem != null) ? e.jumpItem!.cost : 0
				boolean teleportCharged = false
				integer teleportCost = (e.teleportItem != null) ? e.teleportItem!.cost : 0
				real critFactor = e.isOTK ? CRITICAL_FACTOR : 1.0
				real effectiveRel = e.isOTK ? relShield - 25 : relShield

				// Simulate enemy liberation stripping our shields
				if (relShield > ScoringConfig.LIBE_RELSHIELD_TRIGGER && e.liberationCD <= 1) {
					Map<Cell, real>? libeMap = MapDanger._map_enemy_liberation[e]
					if (libeMap != null && libeMap![cell] != null) {
						for (Item item in e.items) {
							if (item.id == CHIP_LIBERATION) {
								if (item.cost <= tpLeft) {
									tpLeft -= item.cost
									absShield *= ScoringConfig.LIBE_DEBUFF_FACTOR
									relShield *= ScoringConfig.LIBE_DEBUFF_FACTOR
									libeFactor *= ScoringConfig.LIBE_DEBUFF_FACTOR
								}
								break
							}
						}
					}
				}

				// MP shackle: cache outside item loop
				boolean applyShackle = false
				integer shackledMP = 0
				if (consequences && e.nextManumission > 1) {
					shackledMP = max(0, e.getCurrentMP(consequences!))
					applyShackle = shackledMP < e.mp
				}

				for (Item item in e.offensiveItems) {
					Map<Cell, real>? itemMap = MapDanger._map_entity_item_danger[e]![item]
					if (itemMap == null) continue  // Item not processed (early exit in MapDanger)

					real? ratioDmg = itemMap![cell]
					if (ratioDmg == null || ratioDmg <= 0) continue

					// Determine if this cell requires jump (not walk-reachable)
					boolean needsJump = false
					Map<Cell, integer>? mpMap = MapDanger._map_entity_item_mp[e]![item]
					Map<Cell, integer>? jumpMap = MapDanger._map_entity_item_jump[e]![item]
					if (mpMap![cell] == null && jumpMap != null && jumpMap![cell] != null) {
						needsJump = true
					}

					// Determine if this cell requires teleport (not walk or jump reachable)
					boolean needsTeleport = false
					Map<Cell, integer>? teleportMap = MapDanger._map_entity_item_teleport[e] != null ? MapDanger._map_entity_item_teleport[e]![item] : null
					if (mpMap![cell] == null && (jumpMap == null || jumpMap![cell] == null) && teleportMap != null && teleportMap![cell] != null) {
						needsTeleport = true
					}

					// MP shackle filtering: skip direct hits enemy can no longer reach
					if (applyShackle) {
							// Check if direct hit cell is reachable under shackle (walk or jump)
							boolean directReachable = false
							if (needsTeleport) {
								directReachable = teleportMap![cell]! <= shackledMP
							} else if (needsJump) {
								directReachable = jumpMap![cell]! <= shackledMP
							} else {
								integer? minMp = mpMap![cell]
								if (minMp != null && minMp! <= shackledMP) {
									directReachable = true
								} else if (e.jumpCD <= 1 && jumpMap != null && jumpMap![cell] != null && jumpMap![cell]! <= shackledMP) {
									// Walk unreachable but jump reachable under shackle
									directReachable = true
									needsJump = true
									ratioDmg = 1.0
								} else if (teleportMap != null && teleportMap![cell] != null && teleportMap![cell]! <= shackledMP) {
									// Walk+jump unreachable but teleport reachable under shackle
									directReachable = true
									needsTeleport = true
									ratioDmg = 1.0
								}
							}
							if (!directReachable) {
								// Direct hit unreachable — check AOE fallback
								if (item.isAOE) {
									real bestAoe = 0
									Set<Cell> areaCells = cell.getAreaCells(item.area)
									for (Cell src in areaCells) {
										if (src == cell) continue
										// Check walk sources
										integer? srcMp = mpMap![src]
										if (srcMp != null && srcMp! <= shackledMP) {
											integer dist = abs(cell.x - src.x) + abs(cell.y - src.y)
											real ratio = 1 - ScoringConfig.AOE_DECAY_RATE * dist
											if (ratio > bestAoe) {
												bestAoe = ratio
												needsJump = false
												if (dist == 1) break
											}
										}
										// Check jump sources (no break — walk source at same dist is cheaper)
										if (e.jumpCD <= 1 && jumpMap != null) {
											integer? srcJMp = jumpMap![src]
											if (srcJMp != null && srcJMp! <= shackledMP) {
												integer dist = abs(cell.x - src.x) + abs(cell.y - src.y)
												real ratio = 1 - ScoringConfig.AOE_DECAY_RATE * dist
												if (ratio > bestAoe) {
													bestAoe = ratio
													needsJump = true
													needsTeleport = false
												}
											}
										}
										// Check teleport sources
										if (teleportMap != null) {
											integer? srcTMp = teleportMap![src]
											if (srcTMp != null && srcTMp! <= shackledMP) {
												integer dist = abs(cell.x - src.x) + abs(cell.y - src.y)
												real ratio = 1 - ScoringConfig.AOE_DECAY_RATE * dist
												if (ratio > bestAoe) {
													bestAoe = ratio
													needsTeleport = true
													needsJump = false
												}
											}
										}
									}
									if (bestAoe > 0) ratioDmg = bestAoe
									else continue
								} else {
									continue
								}
							}
					}

					// Charge jump TP (once per enemy) if this item needs jump
					if (needsJump && !jumpCharged) {
						if (jumpCost <= tpLeft) {
							tpLeft -= jumpCost
							jumpCharged = true
						} else {
							continue  // Can't afford jump — skip this item
						}
					}

					// Charge teleport TP (once per enemy) if this item needs teleport
					if (needsTeleport && !teleportCharged) {
						if (teleportCost <= tpLeft) {
							tpLeft -= teleportCost
							teleportCharged = true
						} else {
							continue  // Can't afford teleport — skip this item
						}
					}

					// Calculate damage components separately (using current shield state)
					real itemDmg = 0.0
					real itemPsn = 0.0
					for (ItemEffect ef in item.effects) {
						if (ef.type == EFFECT_DAMAGE) {
							real tmp = ef.avgmax * (1 + e.getCurrentStr(consequences) / 100) * (1 + e.pwr / 100)
							tmp = tmp * ratioDmg! * critFactor * (1 - effectiveRel / 100) - absShield
							if (tmp > 0) itemDmg += tmp
						}
						else if (ef.type == EFFECT_LIFE_DAMAGE) {
							// Life damage: sourceLife * (avg%/100) * (1+pwr/100), then shields
							real tmp = e.getCurrentHP(consequences) * (ef.avgmax / 100) * (1 + e.pwr / 100)
							tmp = tmp * ratioDmg! * critFactor * (1 - effectiveRel / 100) - absShield
							if (tmp > 0) itemDmg += tmp
						}
						else if (ef.type == EFFECT_POISON) {
							real duration = Scoring.durationMitigation(ef.duration)
							// If self can antidote, treat poison as 1-turn (can cure next turn)
							if (Fight.antidoteReady) duration = Scoring.durationMitigation(1)
							itemPsn += ef.avgmax * (1 + e.getCurrentMgc(consequences) / 100) * (1 + e.pwr / 100) * critFactor * ratioDmg! * duration
						}
					}

					if (itemDmg > 0 || itemPsn > 0) {
						integer uses = 0
						while (item.cost <= tpLeft && uses < item.maxUse) {
							str += " " + item.name
							dmg += itemDmg
							psnDmg += itemPsn
							tpLeft -= item.cost
							uses++
							if (item.haveCD) break
						}
					}
				}
			} else {
				// === ALLY: Subtract healing and add shields ===
				// If instant damage is already lethal, entity is dead — allies can't help
				if (dmg >= currentLife) continue
				// Check if ally can support this cell (from ally support map)
				if (MapSupport._map_ally_item_heal[e] == null) continue

				Array<Item>? supportItems = MapSupport._ally_support_items[e]
				if (supportItems == null) continue

				integer tpLeft = e.getCurrentTP(consequences)

				for (Item item in supportItems!) {
					Map<Cell, real>? itemMap = MapSupport._map_ally_item_heal[e]![item]
					if (itemMap == null) continue

					real? ratio = itemMap![cell]
					if (ratio == null || ratio <= 0) continue

					// Calculate support for each effect type
					for (ItemEffect ef in item.effects) {
						if (ef.type == EFFECT_HEAL) {
							// Skip non-stackable HoT already on self
							if (ef.duration > 1 && Items.isEffectAlreadyOnSelf(item, ef)) continue

							real healVal = ef.avgmax * (1 + e.getCurrentWsd(consequences) / 100) * ratio!

							if (ef.duration > 1) {
								// Heal over time → reduces psnDmg
								integer uses = 0
								while (item.cost <= tpLeft && uses < item.maxUse) {
									real effectiveHeal = min(healVal, psnDmg)
									if (effectiveHeal > 0) {
										str += " " + item.name
										psnDmg -= effectiveHeal
									}
									tpLeft -= item.cost
									uses++
									if (item.haveCD) break
								}
							} else {
								// Instant heal → reduces dmg (capped by missing HP + accumulated damage)
								integer uses = 0
								while (item.cost <= tpLeft && uses < item.maxUse) {
									real missingHP = maxLife - currentLife + dmg
									real effectiveHeal = min(healVal, missingHP)
									if (effectiveHeal > 0) {
										str += " " + item.name
										dmg -= effectiveHeal
									}
									tpLeft -= item.cost
									uses++
									if (item.haveCD) break
								}
							}
						}
						else if (ef.type == EFFECT_BOOST_MAX_LIFE) {
							// Max life boost → reduces dmg (uncapped) and increases maxLife
							real boostVal = ef.avgmax * (1 + e.getCurrentWsd(consequences) / 100) * ratio!
							integer uses = 0
							while (item.cost <= tpLeft && uses < item.maxUse) {
								str += " " + item.name
								dmg -= boostVal
								maxLife += boostVal  // Track increased max life
								tpLeft -= item.cost
								uses++
								if (item.haveCD) break
							}
						}
						// === SHIELD EFFECTS ===
						else if (ef.type == EFFECT_ABSOLUTE_SHIELD) {
							// Skip non-stackable shield already on self
							if (ef.duration > 1 && Items.isEffectAlreadyOnSelf(item, ef)) continue

							real shieldVal = ef.avgmax * (1 + e.getCurrentRst(consequences) / 100) * ratio!
							integer uses = 0
							while (item.cost <= tpLeft && uses < item.maxUse) {
								str += " " + item.name
								absShield += shieldVal  // Increases shield for subsequent enemy attacks
								tpLeft -= item.cost
								uses++
								if (item.haveCD) break
							}
						}
						else if (ef.type == EFFECT_RELATIVE_SHIELD) {
							// Skip non-stackable shield already on self
							if (ef.duration > 1 && Items.isEffectAlreadyOnSelf(item, ef)) continue

							real shieldVal = ef.avgmax * (1 + e.getCurrentRst(consequences) / 100) * ratio!
							integer uses = 0
							while (item.cost <= tpLeft && uses < item.maxUse) {
								str += " " + item.name
								relShield += shieldVal  // Increases shield for subsequent enemy attacks
								tpLeft -= item.cost
								uses++
								if (item.haveCD) break
							}
						}
						// === ANTIDOTE EFFECT ===
						else if (ef.type == EFFECT_ANTIDOTE) {
							// Ally can antidote this cell - negate all accumulated psnDmg
							// (poison from enemies who played before this ally)
							integer uses = 0
							while (item.cost <= tpLeft && uses < item.maxUse) {
								str += " " + item.name
								psnDmg = 0  // Antidote removes ALL poison
								tpLeft -= item.cost
								uses++
								if (item.haveCD) break
							}
						}
					}
				}
			}
		}

		// Floor at 0 (can't have negative danger)
		if (dmg < 0) dmg = 0
		if (psnDmg < 0) psnDmg = 0

		return Danger(cell, dmg, psnDmg, str, consequences)
	}

	/*
	 * Legacy method for backwards compatibility.
	 * Returns total damage (dmg + psnDmg) from an enemy item.
	 * @deprecated Use computeDanger for separated values.
	 */
	static real getDamage(Entity eSource, Entity eTarget, Item item, real ratioDmg, Consequences? conseq) {
		real dmg = 0.0
		real psn = 0.0

		for (ItemEffect e in item.effects) {
			if (e.type == EFFECT_DAMAGE) {
				real tmp = e.avgmax * (1 + eSource.getCurrentStr(conseq) / 100) * (1 + eSource.pwr / 100)
				tmp = tmp * ratioDmg * (1 - eTarget.getCurrentRel(conseq) / 100) - eTarget.getCurrentAbs(conseq)
				if (tmp > 0) dmg += tmp
			}
			else if (e.type == EFFECT_LIFE_DAMAGE) {
				// Life damage: sourceLife * (avg%/100) * (1+pwr/100), then shields
				real tmp = eSource.getCurrentHP(conseq) * (e.avgmax / 100) * (1 + eSource.pwr / 100)
				tmp = tmp * ratioDmg * (1 - eTarget.getCurrentRel(conseq) / 100) - eTarget.getCurrentAbs(conseq)
				if (tmp > 0) dmg += tmp
			}
			else if (e.type == EFFECT_POISON) {
				real duration = Scoring.durationMitigation(e.duration)
				// If self can antidote, treat poison as 1-turn
				if (Fight.antidoteReady) duration = Scoring.durationMitigation(1)
				psn += e.avgmax * (1 + eSource.getCurrentMgc(conseq) / 100) * (1 + eSource.pwr / 100) * ratioDmg * duration
			}
		}

		return dmg + psn
	}
}
