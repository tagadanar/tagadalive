class Damages {
	/*
	 * Calcule le danger sur une cellule en prenant en compte:
	 * - Les dommages des ennemis (EFFECT_DAMAGE → dmg, EFFECT_POISON → psnDmg)
	 * - Les heals des alliés (réduisent dmg/psnDmg selon le type d'effet)
	 * - L'ordre de jeu (turn order) pour un calcul séquentiel correct
	 *
	 * @param cell Cellule sur laquelle le danger va être calculé
	 * @param consequences Consequences qui contient les altérations de la série d'action précédente
	 * @return un objet Danger avec dmg (HP) et psnDmg (HPTIME) séparés
	 */
	static Danger computeDanger(Cell cell, Consequences? consequences) {
		real dmg = 0.0      // HP damage (instant)
		real psnDmg = 0.0   // HPTIME damage (poison over time)
		string str = ""

		// Track HP state for heal capping
		real currentLife = Fight.self.getCurrentHP(consequences)
		real maxLife = Fight.self.getCurrentMaxHP(consequences)

		// Track shield state (existing + ally contributions)
		real absShield = Fight.self.getCurrentAbs(consequences)
		real relShield = Fight.self.getCurrentRel(consequences)

		// Process entities in turn order (after self, wrapping around)
		for (Entity e in Fight.getEntitiesAfterSelfInOrder()) {
			if (consequences && consequences!.isKilled(e)) continue

			if (!e.isFriend) {
				// === ENEMY: Add damage ===
				// Check if enemy can reach this cell (from danger map)
				if (MapDanger._map_entity_item_danger[e] == null) continue

				integer tpLeft = e.getCurrentTP(consequences)

				for (Item item in e.offensiveItems) {
					Map<Cell, real>? itemMap = MapDanger._map_entity_item_danger[e]![item]
					if (itemMap == null) continue  // Item not processed (early exit in MapDanger)

					real? ratioDmg = itemMap![cell]
					if (ratioDmg == null || ratioDmg <= 0) continue

					// Calculate damage components separately (using current shield state)
					real itemDmg = 0.0
					real itemPsn = 0.0
					for (ItemEffect ef in item.effects) {
						if (ef.type == EFFECT_DAMAGE) {
							real tmp = ef.avgmax * (1 + e.getCurrentStr(consequences) / 100) * (1 + e.pwr / 100)
							tmp = tmp * ratioDmg! * (1 - relShield / 100) - absShield
							if (tmp > 0) itemDmg += tmp
						}
						else if (ef.type == EFFECT_POISON) {
							real duration = ScoringConfig.defensive_duration_mitigation[ef.duration]!
							// TODO if(_CAN_ANTIDOTE) duration = 1;
							itemPsn += ef.avgmax * (1 + e.getCurrentMgc(consequences) / 100) * (1 + e.pwr / 100) * ratioDmg! * duration
						}
					}

					if (itemDmg > 0 || itemPsn > 0) {
						integer uses = 0
						while (item.cost <= tpLeft && uses < item.maxUse) {
							str += " " + item.name
							dmg += itemDmg
							psnDmg += itemPsn
							tpLeft -= item.cost
							uses++
							if (item.haveCD) break
						}
					}
				}
			} else {
				// === ALLY: Subtract healing and add shields ===
				// Check if ally can support this cell (from ally support map)
				if (MapAllySupport._map_ally_item_heal[e] == null) continue

				Array<Item>? supportItems = MapAllySupport._ally_support_items[e]
				if (supportItems == null) continue

				integer tpLeft = e.getCurrentTP(consequences)

				for (Item item in supportItems!) {
					Map<Cell, real>? itemMap = MapAllySupport._map_ally_item_heal[e]![item]
					if (itemMap == null) continue

					real? ratio = itemMap![cell]
					if (ratio == null || ratio <= 0) continue

					// Calculate support for each effect type
					for (ItemEffect ef in item.effects) {
						if (ef.type == EFFECT_HEAL) {
							// Skip non-stackable HoT already on self
							if (ef.duration > 1 && Items.isEffectAlreadyOnSelf(item, ef)) continue

							real healVal = ef.avgmax * (1 + e.getCurrentWsd(consequences) / 100) * ratio!

							if (ef.duration > 1) {
								// Heal over time → reduces psnDmg
								integer uses = 0
								while (item.cost <= tpLeft && uses < item.maxUse) {
									real effectiveHeal = min(healVal, psnDmg)
									if (effectiveHeal > 0) {
										str += " " + item.name
										psnDmg -= effectiveHeal
									}
									tpLeft -= item.cost
									uses++
									if (item.haveCD) break
								}
							} else {
								// Instant heal → reduces dmg (capped by missing HP + accumulated damage)
								integer uses = 0
								while (item.cost <= tpLeft && uses < item.maxUse) {
									real missingHP = maxLife - currentLife + dmg
									real effectiveHeal = min(healVal, missingHP)
									if (effectiveHeal > 0) {
										str += " " + item.name
										dmg -= effectiveHeal
									}
									tpLeft -= item.cost
									uses++
									if (item.haveCD) break
								}
							}
						}
						else if (ef.type == EFFECT_RAW_HEAL) {
							// Raw heal → reduces dmg (capped by missing HP)
							real healVal = ef.avgmax * ratio!
							integer uses = 0
							while (item.cost <= tpLeft && uses < item.maxUse) {
								real missingHP = maxLife - currentLife + dmg
								real effectiveHeal = min(healVal, missingHP)
								if (effectiveHeal > 0) {
									str += " " + item.name
									dmg -= effectiveHeal
								}
								tpLeft -= item.cost
								uses++
								if (item.haveCD) break
							}
						}
						else if (ef.type == EFFECT_BOOST_MAX_LIFE) {
							// Max life boost → reduces dmg (uncapped) and increases maxLife
							real boostVal = ef.avgmax * (1 + e.getCurrentWsd(consequences) / 100) * ratio!
							integer uses = 0
							while (item.cost <= tpLeft && uses < item.maxUse) {
								str += " " + item.name
								dmg -= boostVal
								maxLife += boostVal  // Track increased max life
								tpLeft -= item.cost
								uses++
								if (item.haveCD) break
							}
						}
						// === SHIELD EFFECTS ===
						else if (ef.type == EFFECT_ABSOLUTE_SHIELD) {
							// Skip non-stackable shield already on self
							if (ef.duration > 1 && Items.isEffectAlreadyOnSelf(item, ef)) continue

							real shieldVal = ef.avgmax * (1 + e.getCurrentRst(consequences) / 100) * ratio!
							integer uses = 0
							while (item.cost <= tpLeft && uses < item.maxUse) {
								str += " " + item.name
								absShield += shieldVal  // Increases shield for subsequent enemy attacks
								tpLeft -= item.cost
								uses++
								if (item.haveCD) break
							}
						}
						else if (ef.type == EFFECT_RELATIVE_SHIELD) {
							// Skip non-stackable shield already on self
							if (ef.duration > 1 && Items.isEffectAlreadyOnSelf(item, ef)) continue

							real shieldVal = ef.avgmax * (1 + e.getCurrentRst(consequences) / 100) * ratio!
							integer uses = 0
							while (item.cost <= tpLeft && uses < item.maxUse) {
								str += " " + item.name
								relShield += shieldVal  // Increases shield for subsequent enemy attacks
								tpLeft -= item.cost
								uses++
								if (item.haveCD) break
							}
						}
					}
				}
			}
		}

		// Floor at 0 (can't have negative danger)
		if (dmg < 0) dmg = 0
		if (psnDmg < 0) psnDmg = 0

		return Danger(cell, dmg, psnDmg, str, consequences)
	}

	/*
	 * Legacy method for backwards compatibility.
	 * Returns total damage (dmg + psnDmg) from an enemy item.
	 * @deprecated Use computeDanger for separated values.
	 */
	static real getDamage(Entity eSource, Entity eTarget, Item item, real ratioDmg, Consequences? conseq) {
		real dmg = 0.0
		real psn = 0.0

		for (ItemEffect e in item.effects) {
			if (e.type == EFFECT_DAMAGE) {
				real tmp = e.avgmax * (1 + eSource.getCurrentStr(conseq) / 100) * (1 + eSource.pwr / 100)
				tmp = tmp * ratioDmg * (1 - eTarget.getCurrentRel(conseq) / 100) - eTarget.getCurrentAbs(conseq)
				if (tmp > 0) dmg += tmp
			}
			else if (e.type == EFFECT_POISON) {
				real duration = ScoringConfig.defensive_duration_mitigation[e.duration]!
				psn += e.avgmax * (1 + eSource.getCurrentMgc(conseq) / 100) * (1 + eSource.pwr / 100) * ratioDmg * duration
			}
		}

		return dmg + psn
	}
}
