/**
 * DebuffEffects - Handlers for debuff-related effects
 *
 * Uses EffectCalc for calculations, sharing formulas with SnapshotEffects.
 * Key difference: uses simulated stats via entity.getCurrentX(conseq).
 *
 * Handles: EFFECT_SHACKLE_* (all shackles), EFFECT_DEBUFF (Liberation),
 *          EFFECT_ANTIDOTE, EFFECT_TOTAL_DEBUFF
 */

// DEBUG: dedup liberation consequence trace (once per ally per turn)
global integer _libCTurn = -1
global Map<integer, boolean> _libCDone = [:]

// Register all debuff effect handlers
Consequences.registerHandlers([
	// ============================================
	// SHACKLES (all stackable currently)
	// ============================================

	EFFECT_SHACKLE_STRENGTH: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
		integer value = EffectCalc.shackle(effect.avg, entitySource.getCurrentMgc(conseq), ratioDmg)
		EffectOverTime eot = EffectOverTime(effect.item, -value, effect.duration, effect.type)
		conseq.add(entityTarget, Stats.STR, eot)
	},

	EFFECT_SHACKLE_MAGIC: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
		integer value = EffectCalc.shackle(effect.avg, entitySource.getCurrentMgc(conseq), ratioDmg)
		EffectOverTime eot = EffectOverTime(effect.item, -value, effect.duration, effect.type)
		conseq.add(entityTarget, Stats.MGC, eot)
	},

	EFFECT_SHACKLE_AGILITY: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
		integer value = EffectCalc.shackle(effect.avg, entitySource.getCurrentMgc(conseq), ratioDmg)
		EffectOverTime eot = EffectOverTime(effect.item, -value, effect.duration, effect.type)
		conseq.add(entityTarget, Stats.AGI, eot)
	},

	EFFECT_SHACKLE_WISDOM: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
		integer value = EffectCalc.shackle(effect.avg, entitySource.getCurrentMgc(conseq), ratioDmg)
		EffectOverTime eot = EffectOverTime(effect.item, -value, effect.duration, effect.type)
		conseq.add(entityTarget, Stats.WSD, eot)
	},

	EFFECT_SHACKLE_TP: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
		if (entityTarget.getCurrentTP(conseq) <= 0) return;
		integer value = EffectCalc.shackle(effect.avg, entitySource.getCurrentMgc(conseq), ratioDmg)
		EffectOverTime eot = EffectOverTime(effect.item, -value, effect.duration, effect.type)
		conseq.add(entityTarget, Stats.TP, eot)
	},

	EFFECT_SHACKLE_MP: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
		if (entityTarget.getCurrentMP(conseq) <= 0) return;
		integer value = EffectCalc.shackle(effect.avg, entitySource.getCurrentMgc(conseq), ratioDmg)
		EffectOverTime eot = EffectOverTime(effect.item, -value, effect.duration, effect.type)
		conseq.add(entityTarget, Stats.MP, eot)
		// Lock bonus: enemy leek pinned to 0 MP without manumission
		if (!entityTarget.isBulb && entityTarget.nextManumission > 1
			&& entityTarget.getCurrentMP(conseq) <= 0) {
			conseq.score += Scoring.W_LOCK_BONUS
		}
	},

	// ============================================
	// DEBUFF / LIBERATION
	// ============================================

	EFFECT_DEBUFF: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
		// Liberation reduces all effects on target by a percentage
		// Checks what's already been altered to handle combos like Antidote→Liberation or Liberation→Liberation
		real scoreBefore = conseq.score

		// First, process simulated effects (buffs/debuffs added earlier in this combo)
		// Must iterate BEFORE adding counter-effects to avoid reducing our own counters
		string simSuspicious = ""
		if (conseq.hasAltEffects(entityTarget)) {
			// Pre-create entry for this item to avoid ConcurrentModificationException when adding counter-effects
			conseq.ensureAltEffectsEntry(entityTarget, effect.item)
			// Get materialized effects for iteration (COW-aware)
			Map<Item, Array<EffectOverTime>>? entityEffects = conseq.getEntityAltEffects(entityTarget)
			if (entityEffects != null) {
				for (Item item : Array<EffectOverTime> effects in entityEffects!) {
					for (EffectOverTime simEffect in effects) {
						integer absValue = abs(simEffect.value)
						integer reduction = round(absValue * (effect.avg/100.0))
						if (reduction <= 0) continue

						integer? stat = Stats.entityEffectType_to_stats[simEffect.effectType]
						if (stat == null) continue

						// Counter-effect has opposite sign of original
						integer counterValue = simEffect.value > 0 ? -reduction : reduction
						EffectOverTime eot = EffectOverTime(effect.item, counterValue, simEffect.duration, simEffect.effectType)
						if (entityTarget.isFriend && counterValue > 0) simSuspicious += " sim!" + simEffect.effectType + "v" + counterValue
						conseq.add(entityTarget, stat!, eot)
					}
				}
			}
		}

		// Then process real effects (from start of turn)
		string suspicious = ""
		for (EntityEffect entityEffect in entityTarget.effects) {
			// Skip irreducible effects - Liberation can't reduce them
			if (entityEffect.modifiers & EFFECT_MODIFIER_IRREDUCTIBLE) continue

			// Check how much of this effect type has already been altered
			integer alreadyAltered = conseq.getEffectTypeAlteration(entityTarget, entityEffect.type)
			integer remaining = entityEffect.value - alreadyAltered
			if (remaining <= 0) continue  // Already fully countered by previous action

			// CONVERTER converts value to negative if it's a malus (e.g., poison deals damage in HPTIME)
			// EntityEffect always has positive value, EffectOverTime has +/- based on Stats
			// FIXME: for !stackable effects, should do -100% then + remaining after reduction
			integer reduction = round(remaining * (effect.avg/100.0))
			integer value = reduction * TargetType.CONVERTER[entityEffect.type]
			EffectOverTime eot = EffectOverTime(effect.item, -value, entityEffect.turns, entityEffect.type)
			integer? stat = Stats.entityEffectType_to_stats[entityEffect.type]
			integer conv = TargetType.CONVERTER[entityEffect.type]
			if (entityTarget.isFriend && (conv != 1 || stat == null)) {
				suspicious += " !" + entityEffect.type + "v" + entityEffect.value + "c" + conv + "s" + stat + "t" + entityEffect.turns
			}
			if (stat == null) debugE("LIBERATION effect to stat unhandled: " + entityEffect)
			conseq.add(entityTarget, stat!, eot)
			conseq.addEffectTypeAlteration(entityTarget, entityEffect.type, reduction)
		}

		// DEBUG: log once per ally per turn when consequence score is positive (bug condition)
		if (entityTarget.isFriend) {
			real delta = conseq.score - scoreBefore
			integer curTurn = getTurn()
			if (curTurn != _libCTurn) { _libCTurn = curTurn; _libCDone = [:] }
			if (delta > 0 && !_libCDone[entityTarget.id]) {
				_libCDone[entityTarget.id] = true
				debugE("LIB_C " + entityTarget.name + " n=" + count(entityTarget.effects) + " score=" + round(delta) + suspicious + simSuspicious)
			}
		}
	},

	EFFECT_ANTIDOTE: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
		// Removes poison effects - score comes from HPTIME (negated poison damage), not from DEATH_VALUE
		// (DEATH_VALUE in Items.computeSupportValue only guarantees antidote is included in support item set)
		// If target has no poison, this produces zero score - which is correct (preemptive antidote = no value)
		for (EntityEffect entityEffect in entityTarget.effects) {
			if (entityEffect.type == EFFECT_POISON) {
				integer alreadyAltered = conseq.getEffectTypeAlteration(entityTarget, EFFECT_POISON)
				integer remaining = entityEffect.value - alreadyAltered
				if (remaining <= 0) continue  // Already fully countered by previous action

				EffectOverTime eot = EffectOverTime(effect.item, remaining, entityEffect.turns, entityEffect.type)
				conseq.add(entityTarget, Stats.HPTIME, eot)
				conseq.addEffectTypeAlteration(entityTarget, EFFECT_POISON, remaining)
			}
		}
	},

	EFFECT_TOTAL_DEBUFF: (ItemEffect effect, Entity entitySource, Entity entityTarget, real ratioDmg, Consequences conseq) => void {
		// Similar to DEBUFF but removes ALL buffs, not just a percentage
		// TODO: implement full debuff logic
	}
])
