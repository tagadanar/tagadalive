/**
 * EffectHandlers - Single source of truth for effect logic.
 *
 * These static methods contain all effect computation logic, used by both:
 * - Consequences handlers (combo building with simulated stats)
 * - SnapshotEffects handlers (initial pool with base stats)
 *
 * The context parameter is duck-typed: works with both Consequences and EffectSnapshot
 * since both implement the unified interface (add, addKill, isKilled, getHP, getHPMissing,
 * getExistingItemEffect, targets).
 *
 * Stats are passed explicitly to avoid branching inside handlers.
 * Non-stackable de-dupe is centralized here via dedupeIfNeeded().
 */
class EffectHandlers {

	/*
	 * Helper: Handle non-stackable effect de-duplication.
	 * If effect is non-stackable and target already has this effect, adds counter-effect.
	 * Returns true if de-dupe was applied.
	 */
	static boolean dedupeIfNeeded(ItemEffect effect, Entity target, integer stat, ctx) {
		if (effect.stackable) return false
		EffectOverTime? existing = ctx.getExistingItemEffect(target, effect.item)
		if (existing != null) {
			EffectOverTime counter = EffectOverTime(effect.item, -existing!.value, existing!.duration, effect.type)
			ctx.add(target, stat, counter)
			return true
		}
		return false
	}

	/*
	 * Check if target will die from accumulated poison (guaranteed kill).
	 * Called after damage or poison application to award KILL_VALUE
	 * when the kill is certain (no antidote available).
	 */
	static void checkPoisonKill(Entity target, ctx) {
		if (target.isFriend || ctx.isKilled(target)) return;
		if (target.nextAntidote >= 1 && ctx.getHP(target) - target.psnTurn - ctx.getPsnPerTurn(target) <= 0) {
			ctx.addKill(target)
		}
	}

	// ════════════════════════════════════════════════════════════════════════
	// DAMAGE EFFECTS
	// ════════════════════════════════════════════════════════════════════════

	static void damage(ItemEffect effect, Entity source, Entity target, real ratio, integer srcStr, integer srcPwr, integer srcWsd, integer tgtRel, integer tgtAbs, integer tgtDmgRet, ctx) {
		integer targetsCount = effect.multiplyByTarget ? setSize(ctx.targets) : 1
		real beforeShield = EffectCalc.rawDamage(effect.avg, srcStr, srcPwr, ratio, targetsCount)
		real value = EffectCalc.applyShields(beforeShield, tgtRel, tgtAbs)
		integer damageDealt = round(value)

		// Track effect value for STEAL_LIFE chaining
		ctx.addEffectValue(damageDealt)

		// Track raw damage to enemies for Liberation combo detection
		if (!target.isFriend) {
			ctx.addRawEnemyDamage(beforeShield)
		}

		ctx.add(target, Stats.HP, -damageDealt)

		// Inline passives for damage taken (target's passives)
		Map<integer, real> passives = target.passives
		if (passives[EFFECT_DAMAGE_TO_STRENGTH]) {
			integer strGain = round(value * passives[EFFECT_DAMAGE_TO_STRENGTH]!)
			if (strGain > 0) ctx.add(target, Stats.STR, strGain)
		}
		if (passives[EFFECT_DAMAGE_TO_ABSOLUTE_SHIELD]) {
			integer shieldGain = round(value * passives[EFFECT_DAMAGE_TO_ABSOLUTE_SHIELD]!)
			if (shieldGain > 0) ctx.add(target, Stats.ABSSHIELD, shieldGain)
		}

		if (ctx.getHP(target) <= 0) {
			ctx.addKill(target)
		} else {
			EffectHandlers.checkPoisonKill(target, ctx)
		}

		// Erosion
		ctx.add(target, Stats.HPMAX, -EffectCalc.erosion(value))
		// Inline passive for nova/erosion
		if (passives[EFFECT_NOVA_DAMAGE_TO_MAGIC]) {
			integer magicGain = round(EffectCalc.erosion(value) * passives[EFFECT_NOVA_DAMAGE_TO_MAGIC]!)
			if (magicGain > 0) ctx.add(target, Stats.MGC, magicGain)
		}

		// Life steal
		integer lifeSteal = EffectCalc.lifeSteal(value, srcWsd, ctx.getHPMissing(source))
		if (lifeSteal > 0) ctx.add(source, Stats.HP, lifeSteal)

		// Damage return
		real dmgReturn = EffectCalc.damageReturn(beforeShield, tgtDmgRet)
		if (dmgReturn > 0) {
			ctx.add(source, Stats.HP, -round(dmgReturn))
			ctx.add(source, Stats.HPMAX, -EffectCalc.erosion(dmgReturn))
			if (dmgReturn >= ctx.getHP(source)) {
				ctx.addKill(source)
			}
		}
	}

	static void poison(ItemEffect effect, Entity source, Entity target, real ratio, integer srcMgc, integer srcPwr, boolean hasEffect, ctx) {
		// Check notReplaceable (e.g., COVID) - skip if target already has this effect
		if (effect.notReplaceable && hasEffect) return;

		// Cap duration by enemy antidote availability (min 1: force antidote use + cooldown)
		integer duration = effect.duration
		if (!target.isFriend && target.nextAntidote < duration) {
			duration = max(1, target.nextAntidote)
		}
		if (duration <= 0) return;

		integer value = EffectCalc.poisonDamage(effect.avg, srcMgc, srcPwr, ratio, duration)
		EffectOverTime eot = EffectOverTime(effect.item, -value, duration, effect.type)
		ctx.add(target, Stats.HPTIME, eot)

		// Track per-turn poison for overkill detection
		integer perTurn = round(effect.avg * (1 + srcMgc / 100.0) * ratio * (1 + srcPwr / 100.0))
		ctx.addPsnPerTurn(target, perTurn)
		EffectHandlers.checkPoisonKill(target, ctx)

		// Inline passive for poison taken (target's passives)
		Map<integer, real> passives = target.passives
		if (passives[EFFECT_POISON_TO_SCIENCE]) {
			integer sciGain = round(effect.avg * passives[EFFECT_POISON_TO_SCIENCE]!)
			if (sciGain > 0) ctx.add(target, Stats.SNC, sciGain)
		}

		// Erosion (only 1 turn - often antidoted/liberated)
		integer erosion = EffectCalc.poisonErosion(value, duration)
		ctx.add(target, Stats.HPMAX, -erosion)
		// Inline passive for nova/erosion
		if (passives[EFFECT_NOVA_DAMAGE_TO_MAGIC]) {
			integer magicGain = round(erosion * passives[EFFECT_NOVA_DAMAGE_TO_MAGIC]!)
			if (magicGain > 0) ctx.add(target, Stats.MGC, magicGain)
		}
	}

	static void lifeDamage(ItemEffect effect, Entity source, Entity target, real ratio, integer srcLife, integer srcPwr, integer tgtRel, integer tgtAbs, integer tgtDmgRet, ctx) {
		real beforeShield = EffectCalc.lifeDamageRaw(srcLife, effect.avg, srcPwr)
		real value = EffectCalc.applyShields(beforeShield, tgtRel, tgtAbs)

		// Track raw damage to enemies for Liberation combo detection
		if (!target.isFriend) {
			ctx.addRawEnemyDamage(beforeShield)
		}

		ctx.add(target, Stats.HP, -round(value))

		if (ctx.getHP(target) <= 0) {
			ctx.addKill(target)
		} else {
			EffectHandlers.checkPoisonKill(target, ctx)
		}

		// Erosion
		ctx.add(target, Stats.HPMAX, -EffectCalc.erosion(value))
		// Inline passive for nova/erosion (target's passives)
		Map<integer, real> passives = target.passives
		if (passives[EFFECT_NOVA_DAMAGE_TO_MAGIC]) {
			integer magicGain = round(EffectCalc.erosion(value) * passives[EFFECT_NOVA_DAMAGE_TO_MAGIC]!)
			if (magicGain > 0) ctx.add(target, Stats.MGC, magicGain)
		}

		if (target != source) {
			// Damage return
			real dmgReturn = EffectCalc.damageReturn(beforeShield, tgtDmgRet)
			if (dmgReturn > 0) {
				ctx.add(source, Stats.HP, -round(dmgReturn))
				ctx.add(source, Stats.HPMAX, -EffectCalc.erosion(dmgReturn))
				if (dmgReturn >= ctx.getHP(source)) {
					ctx.addKill(source)
				}
			}
		}
	}

	static void novaDamage(ItemEffect effect, Entity source, Entity target, real ratio, integer srcSnc, integer srcPwr, integer tgtHPMiss, ctx) {
		integer value = EffectCalc.novaDamage(effect.avg, srcSnc, srcPwr, ratio, tgtHPMiss)

		// Track effect value for STEAL_LIFE chaining
		ctx.addEffectValue(value)

		ctx.add(target, Stats.HPMAX, -value)

		// Inline passive for nova (target's passives)
		Map<integer, real> passives = target.passives
		if (passives[EFFECT_NOVA_DAMAGE_TO_MAGIC]) {
			integer magicGain = round(value * passives[EFFECT_NOVA_DAMAGE_TO_MAGIC]!)
			if (magicGain > 0) ctx.add(target, Stats.MGC, magicGain)
		}
	}

	static void aftereffect(ItemEffect effect, Entity source, Entity target, real ratio, integer srcMgc, ctx) {
		integer value = EffectCalc.aftereffectDamage(effect.avg, srcMgc, ratio)
		EffectOverTime eot = EffectOverTime(effect.item, -value, effect.duration, effect.type)
		ctx.add(target, Stats.HP, -value)
		ctx.add(target, Stats.HPTIME, eot)

		// Erosion
		ctx.add(target, Stats.HPMAX, -EffectCalc.erosion(value))
		// Inline passive for nova/erosion (target's passives)
		Map<integer, real> passives = target.passives
		if (passives[EFFECT_NOVA_DAMAGE_TO_MAGIC]) {
			integer magicGain = round(EffectCalc.erosion(value) * passives[EFFECT_NOVA_DAMAGE_TO_MAGIC]!)
			if (magicGain > 0) ctx.add(target, Stats.MGC, magicGain)
		}
	}

	// ════════════════════════════════════════════════════════════════════════
	// HEAL EFFECTS
	// ════════════════════════════════════════════════════════════════════════

	static void heal(ItemEffect effect, Entity source, Entity target, real ratio, integer srcWsd, integer tgtHPMiss, ctx) {
		integer targetsCount = effect.multiplyByTarget ? setSize(ctx.targets) : 1
		if (effect.duration > 1) {
			// Heal over time - de-dupe if non-stackable
			EffectHandlers.dedupeIfNeeded(effect, target, Stats.HPTIME, ctx)
			integer value = EffectCalc.healValue(effect.avg, srcWsd, ratio) * targetsCount
			EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration, effect.type)
			ctx.add(target, Stats.HPTIME, eot)
		} else {
			// Instant heal - no de-dupe needed
			integer value = EffectCalc.healCapped(effect.avg, srcWsd, ratio, tgtHPMiss) * targetsCount
			if (value > 0) ctx.add(target, Stats.HP, value)
		}
	}

	static void boostMaxLife(ItemEffect effect, Entity source, Entity target, real ratio, integer srcWsd, ctx) {
		integer value = EffectCalc.boostMaxLife(effect.avg, srcWsd, ratio)
		ctx.add(target, Stats.HPMAX, value)
		ctx.add(target, Stats.HP, value)
	}

	static void novaVitality(ItemEffect effect, Entity source, Entity target, real ratio, integer srcSnc, ctx) {
		integer value = EffectCalc.novaVitality(effect.avg, srcSnc, ratio)
		ctx.add(target, Stats.HPMAX, value)
	}

	static void rawHeal(ItemEffect effect, Entity source, Entity target, real ratio, integer tgtHPMiss, ctx) {
		integer value = EffectCalc.rawHealCapped(effect.avg, ratio, tgtHPMiss)
		if (value > 0) ctx.add(target, Stats.HP, value)
	}

	// ════════════════════════════════════════════════════════════════════════
	// SHIELD EFFECTS
	// ════════════════════════════════════════════════════════════════════════

	static void absoluteShield(ItemEffect effect, Entity source, Entity target, real ratio, integer srcRst, ctx) {
		EffectHandlers.dedupeIfNeeded(effect, target, Stats.ABSSHIELD, ctx)
		integer value = EffectCalc.scaledShield(effect.avg, srcRst, ratio)
		EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration, effect.type)
		ctx.add(target, Stats.ABSSHIELD, eot)
	}

	static void relativeShield(ItemEffect effect, Entity source, Entity target, real ratio, integer srcRst, ctx) {
		EffectHandlers.dedupeIfNeeded(effect, target, Stats.RELSHIELD, ctx)
		integer value = EffectCalc.scaledShield(effect.avg, srcRst, ratio)
		EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration, effect.type)
		ctx.add(target, Stats.RELSHIELD, eot)
	}

	static void absoluteVulnerability(ItemEffect effect, Entity source, Entity target, real ratio, ctx) {
		integer value = EffectCalc.vulnerability(effect.avg, ratio)
		EffectOverTime eot = EffectOverTime(effect.item, -value, effect.duration, effect.type)
		ctx.add(target, Stats.ABSSHIELD, eot)
	}

	static void vulnerability(ItemEffect effect, Entity source, Entity target, real ratio, ctx) {
		integer value = EffectCalc.vulnerability(effect.avg, ratio)
		EffectOverTime eot = EffectOverTime(effect.item, -value, effect.duration, effect.type)
		ctx.add(target, Stats.RELSHIELD, eot)
	}

	static void stealAbsoluteShield(ItemEffect effect, Entity source, Entity target, real ratio, ctx) {
		integer value = EffectCalc.vulnerability(effect.avg, ratio)
		EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration, effect.type)
		ctx.add(target, Stats.ABSSHIELD, eot)
	}

	static void rawAbsoluteShield(ItemEffect effect, Entity source, Entity target, real ratio, ctx) {
		EffectOverTime eot = EffectOverTime(effect.item, EffectCalc.rawShield(effect.avg), effect.duration, effect.type)
		ctx.add(target, Stats.ABSSHIELD, eot)
	}

	static void rawRelativeShield(ItemEffect effect, Entity source, Entity target, real ratio, ctx) {
		EffectOverTime eot = EffectOverTime(effect.item, EffectCalc.rawShield(effect.avg), effect.duration, effect.type)
		ctx.add(target, Stats.RELSHIELD, eot)
	}

	static void damageReturn(ItemEffect effect, Entity source, Entity target, real ratio, integer srcAgi, ctx) {
		EffectHandlers.dedupeIfNeeded(effect, target, Stats.DMGRETURN, ctx)
		integer value = EffectCalc.scaledDamageReturn(effect.avg, srcAgi, ratio)
		EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration, effect.type)
		ctx.add(target, Stats.DMGRETURN, eot)
	}

	// ════════════════════════════════════════════════════════════════════════
	// BUFF EFFECTS
	// ════════════════════════════════════════════════════════════════════════

	// --- RAW BUFFS (no science scaling) ---

	static void rawBuffStrength(ItemEffect effect, Entity source, Entity target, real ratio, ctx) {
		EffectHandlers.dedupeIfNeeded(effect, target, Stats.STR, ctx)
		integer value = EffectCalc.rawBuff(effect.avg, ratio)
		EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration, effect.type)
		ctx.add(target, Stats.STR, eot)
	}

	static void rawBuffMagic(ItemEffect effect, Entity source, Entity target, real ratio, ctx) {
		EffectHandlers.dedupeIfNeeded(effect, target, Stats.MGC, ctx)
		integer value = EffectCalc.rawBuff(effect.avg, ratio)
		EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration, effect.type)
		ctx.add(target, Stats.MGC, eot)
	}

	static void rawBuffAgility(ItemEffect effect, Entity source, Entity target, real ratio, ctx) {
		EffectHandlers.dedupeIfNeeded(effect, target, Stats.AGI, ctx)
		integer value = EffectCalc.rawBuff(effect.avg, ratio)
		EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration, effect.type)
		ctx.add(target, Stats.AGI, eot)
	}

	static void rawBuffWisdom(ItemEffect effect, Entity source, Entity target, real ratio, ctx) {
		EffectHandlers.dedupeIfNeeded(effect, target, Stats.WSD, ctx)
		integer value = EffectCalc.rawBuff(effect.avg, ratio)
		EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration, effect.type)
		ctx.add(target, Stats.WSD, eot)
	}

	static void rawBuffResistance(ItemEffect effect, Entity source, Entity target, real ratio, ctx) {
		EffectHandlers.dedupeIfNeeded(effect, target, Stats.RST, ctx)
		integer value = EffectCalc.rawBuff(effect.avg, ratio)
		EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration, effect.type)
		ctx.add(target, Stats.RST, eot)
	}

	static void rawBuffTP(ItemEffect effect, Entity source, Entity target, real ratio, ctx) {
		EffectHandlers.dedupeIfNeeded(effect, target, Stats.TP, ctx)
		integer targetsCount = effect.multiplyByTarget ? setSize(ctx.targets) : 1
		integer value = EffectCalc.rawBuff(effect.avg, ratio) * targetsCount
		EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration, effect.type)
		ctx.add(target, Stats.TP, eot)
		// Track conservative adjustment for self (min - avg, typically negative)
		if (target == Fight.self) {
			integer minValue = EffectCalc.rawBuff(effect.min, ratio) * targetsCount
			ctx.selfTPConservativeAdjustment += (minValue - value)
		}
	}

	static void rawBuffMP(ItemEffect effect, Entity source, Entity target, real ratio, ctx) {
		EffectHandlers.dedupeIfNeeded(effect, target, Stats.MP, ctx)
		integer targetsCount = effect.multiplyByTarget ? setSize(ctx.targets) : 1
		integer value = EffectCalc.rawBuff(effect.avg, ratio) * targetsCount
		EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration, effect.type)
		ctx.add(target, Stats.MP, eot)
		// Track conservative adjustment for self (min - avg, typically negative)
		if (target == Fight.self) {
			integer minValue = EffectCalc.rawBuff(effect.min, ratio) * targetsCount
			ctx.selfMPConservativeAdjustment += (minValue - value)
		}
	}

	static void rawBuffPower(ItemEffect effect, Entity source, Entity target, real ratio, ctx) {
		// Power buffs are always stackable (no de-dupe)
		EffectOverTime eot = EffectOverTime(effect.item, EffectCalc.rawShield(effect.avg), effect.duration, effect.type)
		ctx.add(target, Stats.PWR, eot)
	}

	// --- SCALED BUFFS (scaled by caster's science) ---

	static void buffStrength(ItemEffect effect, Entity source, Entity target, real ratio, integer srcSnc, ctx) {
		EffectHandlers.dedupeIfNeeded(effect, target, Stats.STR, ctx)
		integer value = EffectCalc.scaledBuff(effect.avg, srcSnc, ratio)
		EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration, effect.type)
		ctx.add(target, Stats.STR, eot)
	}

	static void buffAgility(ItemEffect effect, Entity source, Entity target, real ratio, integer srcSnc, ctx) {
		EffectHandlers.dedupeIfNeeded(effect, target, Stats.AGI, ctx)
		integer value = EffectCalc.scaledBuff(effect.avg, srcSnc, ratio)
		EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration, effect.type)
		ctx.add(target, Stats.AGI, eot)
	}

	static void buffWisdom(ItemEffect effect, Entity source, Entity target, real ratio, integer srcSnc, ctx) {
		EffectHandlers.dedupeIfNeeded(effect, target, Stats.WSD, ctx)
		integer value = EffectCalc.scaledBuff(effect.avg, srcSnc, ratio)
		EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration, effect.type)
		ctx.add(target, Stats.WSD, eot)
	}

	static void buffResistance(ItemEffect effect, Entity source, Entity target, real ratio, integer srcSnc, ctx) {
		EffectHandlers.dedupeIfNeeded(effect, target, Stats.RST, ctx)
		integer value = EffectCalc.scaledBuff(effect.avg, srcSnc, ratio)
		EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration, effect.type)
		ctx.add(target, Stats.RST, eot)
	}

	static void buffTP(ItemEffect effect, Entity source, Entity target, real ratio, integer srcSnc, ctx) {
		EffectHandlers.dedupeIfNeeded(effect, target, Stats.TP, ctx)
		integer value = EffectCalc.scaledBuff(effect.avg, srcSnc, ratio)
		EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration, effect.type)
		ctx.add(target, Stats.TP, eot)
		// Track conservative adjustment for self (min - avg, typically negative)
		if (target == Fight.self) {
			integer minValue = EffectCalc.scaledBuff(effect.min, srcSnc, ratio)
			ctx.selfTPConservativeAdjustment += (minValue - value)
		}
	}

	static void buffMP(ItemEffect effect, Entity source, Entity target, real ratio, integer srcSnc, ctx) {
		EffectHandlers.dedupeIfNeeded(effect, target, Stats.MP, ctx)
		integer value = EffectCalc.scaledBuff(effect.avg, srcSnc, ratio)
		EffectOverTime eot = EffectOverTime(effect.item, value, effect.duration, effect.type)
		ctx.add(target, Stats.MP, eot)
		// Track conservative adjustment for self (min - avg, typically negative)
		if (target == Fight.self) {
			integer minValue = EffectCalc.scaledBuff(effect.min, srcSnc, ratio)
			ctx.selfMPConservativeAdjustment += (minValue - value)
		}
	}

	// ════════════════════════════════════════════════════════════════════════
	// SUMMON EFFECTS
	// ════════════════════════════════════════════════════════════════════════

	/*
	 * Calculate summon score based on bulb type, expected damage, and game state.
	 * Returns the score value (caller adds to ctx.score or ctx.effectScore).
	 *
	 * @param item          The summon chip item
	 * @param summonerLevel The summoner's level (for bulb stats)
	 * @param targetCell    Optional: the cell where bulb will be summoned (for damage lookup)
	 */
	static real summon(Item item, integer summonerLevel, Cell? targetCell) {
		integer bulbType = ScoringConfig.getBulbTypeFromChip(item.id)

		// Base value for having a bulb (intrinsic strategic value)
		real? baseValueMaybe = ScoringConfig.SUMMON_VALUES[bulbType]
		real baseValue = baseValueMaybe != null ? baseValueMaybe! : ScoringConfig.SUMMON_VALUE_DEFAULT

		// Computed score from simulation (includes: dmg*coef + kill bonus + distFactor)
		real computedScore = 0
		if (targetCell != null) {
			computedScore = MapSummon.getComputedScore(item.id, targetCell!)
		}

		// Total value = base strategic value + combat score
		real totalValue = baseValue + computedScore

		// Factor: remaining turns (bulbs are more valuable early in fight)
		real turnsRemaining = ScoringConfig.MAX_FIGHT_TURNS - getTurn()
		real turnFactor = min(1.0, turnsRemaining / 30.0)

		// Factor: duplicate bulbs
		real duplicateFactor
		boolean isStrBulb = bulbType == Entity.BULB_FIRE || bulbType == Entity.BULB_ICED || bulbType == Entity.BULB_LIGHTNING || bulbType == Entity.BULB_ROCKY
		if (bulbType == Entity.BULB_HEALER) {
			integer existingCount = BattleState.countHealer
			if (existingCount == 0) duplicateFactor = 3.0
			else if (existingCount == 1) duplicateFactor = 2.0
			else if (existingCount == 2) duplicateFactor = 1.5
			else if (existingCount == 3) duplicateFactor = 1.0
			else if (existingCount == 4) duplicateFactor = 0.5
			else duplicateFactor = -0.1
		} else if (bulbType == Entity.BULB_SAVANT) {
			integer existingCount = BattleState.countSavant
			if (existingCount == 0) duplicateFactor = 3.0
			else if (existingCount == 1) duplicateFactor = 2.0
			else if (existingCount == 2) duplicateFactor = 1.5
			else if (existingCount == 3) duplicateFactor = 1.0
			else if (existingCount == 4) duplicateFactor = 0.5
			else duplicateFactor = -0.1
		} else if (bulbType == Entity.BULB_WIZARD) {
			integer existingCount = BattleState.countWizard
			if (existingCount == 0) duplicateFactor = 3.0
			else if (existingCount == 1) duplicateFactor = 2.0
			else if (existingCount == 2) duplicateFactor = 1.5
			else if (existingCount == 3) duplicateFactor = 1.0
			else if (existingCount == 4) duplicateFactor = 0.5
			else duplicateFactor = -0.1
		} else if (bulbType == Entity.BULB_METALLIC) {
			integer existingCount = BattleState.countMetal
			if (existingCount == 0) duplicateFactor = 3.0
			else if (existingCount == 1) duplicateFactor = 1.5
			else if (existingCount == 2) duplicateFactor = 0.5
			else duplicateFactor = -0.1
			// Shields are useless if no enemy has significant strength (physical damage)
			if (!BattleState.enemyHasStr) duplicateFactor *= 0.1
			// Shields more valuable if enemy has science (buffs allies, longer fights)
			if (BattleState.enemyHasSnc) duplicateFactor *= 1.5
			// Metallic much more valuable vs OTK enemies
			if (BattleState.enemyHasOTK) duplicateFactor *= 2.0
		} else if (isStrBulb) {
			integer existingCount = BattleState.countStrBulbs
			if (existingCount == 0) duplicateFactor = 3.0
			else if (existingCount == 1) duplicateFactor = 2.0
			else if (existingCount == 2) duplicateFactor = 1.0
			else if (existingCount == 3) duplicateFactor = 0.5
			else duplicateFactor = 0.1
		} else {
			integer existingCount = BattleState.getBulbCount(bulbType)
			if (existingCount == 0) duplicateFactor = 3.0
			else if (existingCount == 1) duplicateFactor = 1.5
			else if (existingCount == 2) duplicateFactor = 0.5
			else duplicateFactor = 0.1
		}

		// Bulbs more valuable when no ally leeks (solo summon army)
		if (BattleState.allyLeekCount <= 1) duplicateFactor *= 2.0

		return totalValue * turnFactor * duplicateFactor
	}
}
