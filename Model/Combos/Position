/*
 * Position extends Danger with additional tactical scoring components.
 * Used for end-of-turn positioning decisions.
 * Score breakdown allows debugging and ML tuning of weights.
 *
 * ┌─────────────────────────────────────────────────────────────────────────┐
 * │ POSITION SCORING ARCHITECTURE (3-file split):                          │
 * │  • AI/ScoringConfig: Weight constants and thresholds                   │
 * │  • Model/Combos/Position (this file): Position class with components   │
 * │  • Controlers/Maps/MapPosition: Search algorithm for best position     │
 * └─────────────────────────────────────────────────────────────────────────┘
 */
class Position extends Danger {
	// Score components (for debugging/tuning)
	real proximityScore = 0.0     // penalty for nearby enemies
	real gravityScore = 0.0       // attraction/repulsion to gravity targets
	real tacticalScore = 0.0      // lock, CAC range, COVID, etc.

	// Movement info
	integer pathDistance = 0      // path distance to primary target

	/*
	 * Basic constructor - creates Position from Danger calculation
	 * Additional scores are added via addScore methods
	 */
	constructor(Cell cell, real dmg, real psnDmg, string str, Consequences? consequences) {
		super(cell, dmg, psnDmg, str, consequences)
	}

	/*
	 * Copy constructor from Danger - promotes a Danger to Position
	 */
	constructor(Danger danger) {
		super(danger.cell, danger.dmg, danger.psnDmg, danger.combo, null)
		this.score = danger.score
	}

	/*
	 * Add proximity penalty for nearby enemies
	 */
	void addProximityScore(real penalty) {
		this.proximityScore = penalty
		this.score += penalty
	}

	/*
	 * Add gravity score for distance to important targets
	 */
	void addGravityScore(real gravScore) {
		this.gravityScore = gravScore
		this.score += gravScore
	}

	/*
	 * Add tactical bonuses (lock, CAC, COVID, etc.)
	 */
	void addTacticalScore(real tactical) {
		this.tacticalScore = tactical
		this.score += tactical
	}

	/*
	 * Apply life-based danger scaling (more cautious when low HP)
	 * Should be called after base danger score is set
	 * Uses total damage (dmg + psnDmg) for threshold calculations
	 */
	void applyLifeScaling(real lifePercent) {
		real totalDmg = this.dmg + this.psnDmg
		if (totalDmg <= 0) return;

		var currentLife = Fight.self.life * lifePercent

		// Ignore small damage (scratches < 10% of current life)
		// Cancel the score penalty but keep dmg visible for debugging
		if (totalDmg < currentLife * ScoringConfig.IGNORE_DANGER_RATIO) {
			this.score += totalDmg  // cancel the -totalDmg penalty
			return
		}

		var originalDangerScore = -totalDmg
		var scaledDangerScore = originalDangerScore

		// Low HP scaling (below 60%)
		if (lifePercent < 0.6) {
			scaledDangerScore *= ScoringConfig.W_DANGER_LOW_HP
		}

		// Critical danger scaling (danger > half of remaining life)
		if (totalDmg > currentLife / 2) {
			scaledDangerScore *= ScoringConfig.W_DANGER_CRITICAL
		}

		// Apply the difference (since base score already has -totalDmg)
		var adjustment = scaledDangerScore - originalDangerScore
		this.score += adjustment
	}

	/*
	 * Get total score breakdown as string for debugging
	 */
	string getScoreBreakdown() {
		return "danger=" + round(this.dmg) + "+" + round(this.psnDmg) +
			   " prox=" + round(this.proximityScore) +
			   " grav=" + round(this.gravityScore) +
			   " tact=" + round(this.tacticalScore) +
			   " => " + round(this.score)
	}

	/*
	 * Format string for tests/debug
	 */
	string string() {
		return '<Position ' + this.cell + ':dmg=' + round(this.dmg) + ':psn=' + round(this.psnDmg) + ':score=' + round(this.score) + '>'
	}
}
