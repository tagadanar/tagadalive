/*
 * Position extends Danger with additional tactical scoring components.
 * Used for end-of-turn positioning decisions.
 * Score breakdown allows debugging and ML tuning of weights.
 *
 * ┌─────────────────────────────────────────────────────────────────────────┐
 * │ POSITION SCORING ARCHITECTURE (3-file split):                          │
 * │  • AI/ScoringConfig: Weight constants and thresholds                   │
 * │  • Model/Combos/Position (this file): Position class with components   │
 * │  • Controlers/Maps/MapPosition: Search algorithm for best position     │
 * └─────────────────────────────────────────────────────────────────────────┘
 */
class Position extends Danger {
	// Score components (for debugging/tuning)
	real proximityScore = 0.0     // penalty for nearby enemies
	real gravityScore = 0.0       // attraction/repulsion to gravity targets
	real tacticalScore = 0.0      // lock, CAC range, COVID, etc.

	// Movement info
	integer pathDistance = 0      // path distance to primary target

	/*
	 * Basic constructor - creates Position from Danger calculation
	 * Additional scores are added via addScore methods
	 */
	constructor(Cell cell, real dmg, real psnDmg, string str, Consequences? consequences) {
		super(cell, dmg, psnDmg, str, consequences)
	}

	/*
	 * Copy constructor from Danger - promotes a Danger to Position
	 */
	constructor(Danger danger) {
		super(danger.cell, danger.dmg, danger.psnDmg, danger.combo, null)
		this.score = danger.score
	}

	/*
	 * Add proximity penalty for nearby enemies
	 */
	void addProximityScore(real penalty) {
		this.proximityScore = penalty
		this.score += penalty
	}

	/*
	 * Add gravity score for distance to important targets
	 */
	void addGravityScore(real gravScore) {
		this.gravityScore = gravScore
		this.score += gravScore
	}

	/*
	 * Add tactical bonuses (lock, CAC, COVID, etc.)
	 */
	void addTacticalScore(real tactical) {
		this.tacticalScore = tactical
		this.score += tactical
	}

	/*
	 * Apply coef-based danger scaling using the scoring system.
	 * Scales dmg by self HP dynamic coef and psnDmg by self HPTIME dynamic coef.
	 * Should be called after base danger score is set.
	 */
	void applyLifeScaling(Consequences? consequences) {
		real totalDmg = this.dmg + this.psnDmg
		if (totalDmg <= 0) return;

		real currentLife = Fight.self.getCurrentHP(consequences)

		// Ignore small damage (scratches) - bulbs tolerate more (80%) than leeks (10%)
		// Cancel the score penalty but keep dmg visible for debugging
		if (totalDmg < currentLife * ScoringConfig.getIgnoreDangerRatio(Fight.self)) {
			this.score += totalDmg  // cancel the -totalDmg penalty
			return
		}

		// Weighted danger: each component scaled by its dynamic coef
		real hpCoef = Scoring.getDynamicCoef(Fight.self, Stats.HP, consequences)
		real hptimeCoef = Scoring.getDynamicCoef(Fight.self, Stats.HPTIME, consequences)

		// Low danger: halve coefs when damage is small relative to current HP
		if (totalDmg < currentLife * ScoringConfig.CRITICAL_DANGER_RATIO) {
			hpCoef *= 0.5
			hptimeCoef *= 0.5
		}

		real scaledDangerScore = -(this.dmg * hpCoef + this.psnDmg * hptimeCoef)

		// Apply the difference (since base score already has -totalDmg)
		var adjustment = scaledDangerScore - (-totalDmg)
		this.score += adjustment
	}

	/*
	 * Get total score breakdown as string for debugging
	 */
	string getScoreBreakdown() {
		return "danger=" + round(this.dmg) + "+" + round(this.psnDmg) +
			   " prox=" + round(this.proximityScore) +
			   " grav=" + round(this.gravityScore) +
			   " tact=" + round(this.tacticalScore) +
			   " => " + round(this.score)
	}

	/*
	 * Format string for tests/debug
	 */
	string string() {
		return '<Position ' + this.cell + ':dmg=' + round(this.dmg) + ':psn=' + round(this.psnDmg) + ':score=' + round(this.score) + '>'
	}
}
