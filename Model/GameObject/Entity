/*
 * L'objet Entity contient la synthèse des informations d'une entité allié ou adversaire.
 * Il y a un objet Entity instancié pour chacune des entités présente sur le champ de bataille.
 */
class Entity {
	// === Bulb Type Constants ===
	// Extended type values for bulbs (not provided by LeekScript)
	// Values chosen to not conflict with ENTITY_LEEK (0), ENTITY_BULB (1),
	// ENTITY_TURRET (2), ENTITY_CHEST (3), ENTITY_MOB (4)
	static integer BULB_HEALER = 101
	static integer BULB_WIZARD = 102
	static integer BULB_FIRE = 103
	static integer BULB_ICED = 104
	static integer BULB_LIGHTNING = 105
	static integer BULB_METALLIC = 106
	static integer BULB_ROCKY = 107
	static integer BULB_PUNY = 108

	integer id
	string name
	Cell cell
	// stats
	integer level
	integer totalLife
	integer life
	integer pwr
	integer str
	integer mgc
	integer wsd
	integer rst
	integer agi
	integer snc
	integer tp
	integer mp
	integer relShield
	integer absShield
	integer dmgReturn
	// déplacement
	Map<Cell, integer> reachableCells
	Map<Cell, integer> extendedReachableCells  // reachable with MP buffs (self only)
	integer maxMPBuff = 0                       // max MP gain from self-cast buffs (self only)
	// inventaire organisé en fonction des cibles
	Array<Item> items
	Array<Item> offensiveItems // will have a value on enemy leeks only
	Map<Entity, Array<Item>> offensiveItemsByTargets = [:] // will have a value on ally leeks only
	// play order
	integer turnOrder
	Array<Entity> entitiesWhoPlayBefore
	Array<Cell> cellsToIgnore = []
	// booleans
	boolean isFriend
	boolean isBulb
	boolean isStatic = false     // ADD_STATE value 11 - no STATE_STATIC constant in leekwars api
	boolean isInvincible = false // ADD_STATE value STATE_INVINCIBLE (3)
	integer entityType  // ENTITY_LEEK, ENTITY_BULB, ENTITY_TURRET, ENTITY_CHEST, ENTITY_MOB
	integer extendedType  // Cached: for bulbs, specific type (101-108); otherwise same as entityType
	// gestions des effets
	Array<EntityEffect> effects = []
	Map<Item, Array<EffectOverTime>> items_effectOverTime = [:]
	integer psnTurn = 0
	integer psnTotal = 0
	integer psnlife
	integer altStr = 0
	integer altMgc = 0
	integer altAgi = 0
	integer altTP = 0
	integer altMP = 0
	// todo add more alt ?
	Array<EntityEffect> launchedEffects
	// passive effects from weapons (auras) - effect.type -> conversion rate
	Map<integer, real> passives = [:]

	constructor(integer id){
		this.id = id
		this.name = getName(id)!
		this.cell = Board.getCell(getCell(id))!
		this.level = getLevel(id)!
		this.totalLife = getTotalLife(id)!
		this.life = getLife(id)!
		this.pwr = getPower(id)!
		this.str = getStrength(id)!
		this.mgc = getMagic(id)!
		this.wsd = getWisdom(id)!
		this.rst = getResistance(id)!
		this.agi = getAgility(id)!
		this.snc = getScience(id)!
		this.tp = getTP(id)!
		this.mp = getMP(id)!
		this.relShield = getRelativeShield(id)!
		this.absShield = getAbsoluteShield(id)!
		this.dmgReturn = getDamageReturn(id)!
		this.items = Items.getItems(id)
		// Load passive effects from entity
		for(Array e in getPassiveEffects(this.id)!) {
			integer type = e[0] as integer
			real value = e[1] as real
			// Percentage-based passives (convert damage/poison/erosion/cells to stat)
			if(type == EFFECT_DAMAGE_TO_STRENGTH
				|| type == EFFECT_DAMAGE_TO_ABSOLUTE_SHIELD
				|| type == EFFECT_NOVA_DAMAGE_TO_MAGIC
				|| type == EFFECT_POISON_TO_SCIENCE
				|| type == EFFECT_CRITICAL_TO_HEAL
				|| type == EFFECT_MOVED_TO_MP) {
				value = value / 100
			}
			// Absolute passives (KILL_TO_TP, ALLY_KILLED_TO_AGILITY) stored as-is
			this.passives[type] = value
		}
		this.turnOrder = getEntityTurnOrder(id)!
		this.isFriend = isAlly(id)
		this.isBulb = isSummon(id)!
		this.entityType = getType(id)!
		// Cache extended type (bulb-specific type detection done once here)
		if (this.isBulb) {
			string n = this.name
			if (n == "metallic_bulb") this.extendedType = BULB_METALLIC
			else if (n == "healer_bulb") this.extendedType = BULB_HEALER
			else if (n == "lightning_bulb") this.extendedType = BULB_LIGHTNING
			else if (n == "wizard_bulb") this.extendedType = BULB_WIZARD
			else if (n == "fire_bulb") this.extendedType = BULB_FIRE
			else if (n == "iced_bulb") this.extendedType = BULB_ICED
			else if (n == "rocky_bulb") this.extendedType = BULB_ROCKY
			else if (n == "puny_bulb") this.extendedType = BULB_PUNY
			else this.extendedType = ENTITY_BULB
		} else {
			this.extendedType = this.entityType
		}
		/*
		this.launchedEffects = []
		for(var e in getLaunchedEffects(id)){
			push(this.launchedEffects, 
		}
		*/
		
		for(Array<boolean|integer> e in getEffects(id)!){
			EntityEffect effect = EntityEffect(e)
			// ADD_STATE: set flags, don't add to effects (can't be liberated)
			if(effect.type == EFFECT_ADD_STATE){
				if(effect.value == STATE_INVINCIBLE) this.isInvincible = true
				else if(effect.value == 11) this.isStatic = true // no STATE_STATIC constant in leekwars api
				continue
			}
			push(effects, effect)
			if(!this.items_effectOverTime[effect.item]) this.items_effectOverTime[effect.item] = []
			push(this.items_effectOverTime[effect.item]!, EffectOverTime(effect))
			// piste d'optimisation en ayant une meilleure structure pour les effets ici ?
			// les eval en dessous pourrait être déléguer à un tab pour éviter les ifelseif?
			// et ptete ajouter d'autres alt pour les autres stats ?
			if(effect.type == EFFECT_POISON){
				this.psnTurn+= effect.value
				this.psnTotal+= effect.value * effect.turns
			}else if(effect.type == EFFECT_HEAL){
				this.psnTurn+= -effect.value
				this.psnTotal+= -effect.value * effect.turns
			}else if(effect.type == EFFECT_SHACKLE_STRENGTH){
				this.altStr += -effect.value;
			//	}else if(effect.type == EFFECT_SHACKLE_MAGIC){
			//		this.altMgc -= value;
			}else if(effect.type == EFFECT_SHACKLE_TP){
				this.altTP += -effect.value;
			}else if(effect.type == EFFECT_SHACKLE_MP){
				this.altMP += -effect.value;
			}else if(effect.type == EFFECT_BUFF_STRENGTH || effect.type == EFFECT_RAW_BUFF_STRENGTH){
				this.altStr += effect.value;
			}else if(effect.type == EFFECT_BUFF_TP || effect.type == EFFECT_RAW_BUFF_TP){
				this.altTP += effect.value;
			}else if(effect.type == EFFECT_BUFF_MP || effect.type == EFFECT_RAW_BUFF_MP){
				this.altMP += effect.value;
			}else if(effect.type == EFFECT_BUFF_AGILITY || effect.type == EFFECT_RAW_BUFF_AGILITY){
				this.altAgi += effect.value;
			}
		}
		this.psnlife= this.life-this.psnTurn
	}

	/*
	 * Initialise certaines informations de l'objet Entity
	 * Certaines peuvent être dépendantes d'autres classes.
	 */
	void init(){
		this.entitiesWhoPlayBefore = Fight.getEntitiesWhoPlayBefore(this)
		for(Entity entity in this.entitiesWhoPlayBefore) {
			push(this.cellsToIgnore, entity.cell)
		}
		this.reachableCells = MapPath.getCachedReachableCells(
			this.cell,
			this.mp,
			this.cellsToIgnore
		)

		// Compute extended reach for self only (used by MapAction, MapPosition)
		if (this == Fight.self) {
			this.maxMPBuff = this.computeMaxMPBuff()
			if (this.maxMPBuff > 0) {
				this.extendedReachableCells = MapPath.getCachedReachableCells(
					this.cell,
					this.mp + this.maxMPBuff,
					this.cellsToIgnore
				)
			} else {
				this.extendedReachableCells = this.reachableCells
			}
		}
	}

	/*
	 * Calculate total potential MP buff from all self-cast items.
	 * Scans this entity's items for MP buff effects and sums all gains.
	 * MP buffs stack (Leather Boots + Motivation + Wings = total gain).
	 */
	integer computeMaxMPBuff() {
		integer totalGain = 0
		integer tpBudget = this.tp
		real sncMultiplier = 1 + this.snc / 100.0

		for (Item item in this.items) {
			// Skip if not self-castable (minRange > 0 means can't target self)
			if (item.minRange > 0) continue
			// Skip if on cooldown
			if (item.haveCD && getCooldown(item.id) > 0) continue
			// Skip if can't afford (track TP budget across items)
			if (item.cost > tpBudget) continue

			for (ItemEffect effect in item.effects) {
				integer gain = 0
				if (effect.type == EFFECT_RAW_BUFF_MP) {
					gain = round(effect.avg)
				} else if (effect.type == EFFECT_BUFF_MP) {
					// Science-scaled buff
					gain = round(effect.avg * sncMultiplier)
				}
				if (gain > 0) {
					totalGain += gain
					tpBudget -= item.cost  // Deduct TP for this item
					break  // Move to next item (don't double-count effects from same item)
				}
			}
		}

		return totalGain
	}

	/*
	 * Retourne l'objet Item correspondant à l'arme dans les mains de l'entité
	 * @return une Item
	 */
	Item? getWeaponInHand(){
		return Items.getItem(getWeapon(this.id))
	}
	
	// n'est used que pour check les !stackable item, d'où le count(-1) et [0], maybe rename pour préciser ?
	EffectOverTime? getCurrentItemEffect(Item item, Consequences? consequences){
		if(consequences && consequences!._altEffects[this] && consequences!._altEffects[this]![item]){
			return consequences!._altEffects[this]![item]![count(consequences!._altEffects[this]![item]!)-1]
		}
		return this.items_effectOverTime[item] ? this.items_effectOverTime[item]![0] : null
	}
	
	integer getCurrentMaxHP(Consequences? consequences){
		return consequences ? this.totalLife+consequences!.getAlteration(this, Stats.HPMAX) : this.totalLife 
	}
	integer getCurrentHP(Consequences? consequences){
		return consequences ? this.life+consequences!.getAlteration(this, Stats.HP) : this.life 
	}
	integer getCurrentHPMissing(Consequences? consequences){
		return this.getCurrentMaxHP(consequences) - this.getCurrentHP(consequences) 
	}
	integer getCurrentTP(Consequences? consequences){
		return consequences ? this.tp+consequences!.getAlteration(this, Stats.TP) : this.tp 
	}
	integer getCurrentMP(Consequences? consequences){
		return consequences ? this.mp+consequences!.getAlteration(this, Stats.MP) : this.mp 
	}
	integer getCurrentStr(Consequences? consequences){
		return consequences ? this.str+consequences!.getAlteration(this, Stats.STR) : this.str 
	}
	integer getCurrentMgc(Consequences? consequences){
		return consequences ? this.mgc+consequences!.getAlteration(this, Stats.MGC) : this.mgc 
	}
	integer getCurrentPwr(Consequences? consequences){
		return consequences ? this.pwr+consequences!.getAlteration(this, Stats.PWR) : this.pwr 
	}
	integer getCurrentWsd(Consequences? consequences){
		return consequences ? this.wsd+consequences!.getAlteration(this, Stats.WSD) : this.wsd 
	}
	integer getCurrentRst(Consequences? consequences){
		return consequences ? this.rst+consequences!.getAlteration(this, Stats.RST) : this.rst 
	}
	integer getCurrentAgi(Consequences? consequences){
		return consequences ? this.agi+consequences!.getAlteration(this, Stats.AGI) : this.agi 
	}
	integer getCurrentSnc(Consequences? consequences){
		return consequences ? this.snc+consequences!.getAlteration(this, Stats.SNC) : this.snc 
	}
	integer getCurrentAbs(Consequences? consequences){
		return consequences ? this.absShield+consequences!.getAlteration(this, Stats.ABSSHIELD) : this.absShield 
	}
	integer getCurrentRel(Consequences? consequences){
		return consequences ? this.relShield+consequences!.getAlteration(this, Stats.RELSHIELD) : this.relShield
	}
	integer getCurrentDmgReturn(Consequences? consequences){
		return consequences ? this.dmgReturn+consequences!.getAlteration(this, Stats.DMGRETURN) : this.dmgReturn
	}
	
	/*
	 * Actualise les informations de l'entité
	 * FIXME: UNUSED FUNCTION
	 */
	void refresh() {
		// TODO make a real full refresh based on consequences? might be used for bulb?
		// OR delete this shit ? full refresh by instantiating the entity again, and replacing it in Fight ?
		this.mp = getMP(this.id)!
		this.cell = Board.getCell(getCell(this.id))!
		this.reachableCells = MapPath.getCachedReachableCells(
			this.cell,
			this.mp,
			this.cellsToIgnore
		)
	}

	/*
	 * Format chaîne de caracteres utilisée pour des tests / debugs.
	 */
	string string() {
		return "<Entity "+this.name+">"
	}
}

// TODO

	//scoreLibe: scoreLibe
	//nbBulbs: count(bulbs)//todo check si ça vaut le coup de garder cette info..
	//bulbs: @bulbs
	//antidoteCD: inArray(getChips(leek), CHIP_ANTIDOTE) ? getCooldown(CHIP_ANTIDOTE) : 5
	//liberationCD: inArray(getChips(leek), CHIP_LIBERATION) ? getCooldown(CHIP_LIBERATION) : 6
	//canJump: inArray(getChips(leek), CHIP_JUMP) && getCooldown(CHIP_JUMP, leek)<=1
