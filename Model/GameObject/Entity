/*
 * L'objet Entity contient la synthèse des informations d'une entité allié ou adversaire.
 * Il y a un objet Entity instancié pour chacune des entités présente sur le champ de bataille.
 */
class Entity {
	// === Bulb Type Constants ===
	// Extended type values for bulbs (not provided by LeekScript)
	// Values chosen to not conflict with ENTITY_LEEK (0), ENTITY_BULB (1),
	// ENTITY_TURRET (2), ENTITY_CHEST (3), ENTITY_MOB (4)
	static integer BULB_HEALER = 101
	static integer BULB_WIZARD = 102
	static integer BULB_FIRE = 103
	static integer BULB_ICED = 104
	static integer BULB_LIGHTNING = 105
	static integer BULB_METALLIC = 106
	static integer BULB_ROCKY = 107
	static integer BULB_PUNY = 108
	static integer BULB_TACTICIAN = 109
	static integer BULB_SAVANT = 110

	// Bulb type to register key mapping
	static Map<integer, string> BULB_KEYS = [
		BULB_HEALER: "healer",
		BULB_WIZARD: "wizard",
		BULB_FIRE: "fire",
		BULB_ICED: "iced",
		BULB_LIGHTNING: "lightning",
		BULB_METALLIC: "metallic",
		BULB_ROCKY: "rocky",
		BULB_PUNY: "puny",
		BULB_TACTICIAN: "tactician",
		BULB_SAVANT: "savant"
	]

	/*
	 * Get register key for a bulb type (e.g., "bo_fire" for BULB_FIRE)
	 */
	static string getBulbRegisterKey(integer bulbType) {
		string? key = BULB_KEYS[bulbType]
		return "bo_" + (key != null ? key! : "unknown")
	}

	integer id
	string name
	Cell cell
	// stats
	integer level
	integer totalLife
	integer life
	integer pwr
	integer str
	integer mgc
	integer wsd
	integer rst
	integer agi
	integer snc
	integer tp
	integer mp
	integer relShield
	integer absShield
	integer dmgReturn
	// déplacement
	Map<Cell, integer> reachableCells
	Map<Cell, integer> reachableCellsJump     // reachable via walk + CHIP_JUMP (superset when jumpCD <= 1)
	Map<Cell, integer>? reachableCellsTeleport = null  // walk+jump+teleport reachability (1v1 OTK enemies only)
	Map<Cell, integer> extendedReachableCells  // reachable with MP buffs (self only)
	Map<Cell, integer> jumpExtendedReachableCells  // reachable with MP buffs + CHIP_JUMP (self only)
	Map<Cell, integer> maxExtendedReachableCells // full movement envelope: walk+buffs+jump+teleport (self only)
	integer maxMPBuff = 0                       // max MP gain from self-cast buffs (self only)
	// inventaire organisé en fonction des cibles
	Array<Item> items
	Array<Item> offensiveItems // will have a value on enemy leeks only
	Map<Entity, Array<Item>> offensiveItemsByTargets = [:] // will have a value on ally leeks only
	// play order
	integer turnOrder
	Array<Entity> entitiesWhoPlayBefore
	Set<Cell> cellsToIgnore = <>
	// booleans
	boolean isFriend
	boolean isBulb
	boolean isStatic = false     // ADD_STATE value 11 - no STATE_STATIC constant in leekwars api
	boolean isInvincible = false // ADD_STATE value STATE_INVINCIBLE (3)
	boolean isCrystal = false    // Fennel King boss: crystal that must NOT be damaged
	boolean isGraal = false      // Fennel King boss: graal that must NOT be moved
	boolean isFennelKing = false // Fennel King boss: main boss (boosted TP/MP shackle coefs)
	boolean isEvilPumpkin = false // PotiMalef boss: pumpkin (boosted relshield coefs)
	boolean hasCovid = false     // Has COVID effect active (propagates to nearby entities)
	integer antidoteCD = 5       // CHIP_ANTIDOTE cooldown (5 = no antidote chip, 0-4 = current cd)
	integer nextAntidote = 5     // Turns until enemy team can antidote this entity (0-5, set by MapDanger)
	integer liberationCD = 6     // CHIP_LIBERATION cooldown (6 = no liberation chip, 0-5 = current cd)
	integer nextLiberation = 6   // Turns until enemy team can liberate this entity (0-6, set by MapDanger)
	integer manumissionCD = 6    // CHIP_MANUMISSION cooldown (6 = no manumission chip, 0-5 = current cd)
	integer nextManumission = 6  // Turns until entity can self-manumission (0-6, set by MapDanger)
	integer jumpCD = 4           // CHIP_JUMP cooldown (4 = no jump chip, 0-3 = current cd)
	Item? jumpItem = null        // CHIP_JUMP item reference (for minRange/maxRange access)
	integer teleportCD = 11      // CHIP_TELEPORTATION cooldown (11 = no chip, 0-10 = current cd)
	Item? teleportItem = null    // CHIP_TELEPORTATION item reference
	boolean canDie = false       // Set by BattleState: danger >= life * CANDIE_THRESHOLD
	boolean isOTK = false        // Entity has OTK potential (high STR + AGI + SNC)
	boolean willBeDead = false   // Poison will kill before anyone can antidote (set by MapDanger)
	integer entityType  // ENTITY_LEEK, ENTITY_BULB, ENTITY_TURRET, ENTITY_CHEST, ENTITY_MOB
	integer extendedType  // Cached: for bulbs, specific type (101-108); otherwise same as entityType
	// gestions des effets
	Array<EntityEffect> effects = []
	Map<Item, Array<EffectOverTime>> items_effectOverTime = [:]
	integer psnTurn = 0
	integer psnTotal = 0
	integer psnlife
	integer altStr = 0
	integer altMgc = 0
	integer altAgi = 0
	integer altTP = 0
	integer altMP = 0
	// todo add more alt ?
	Array<EntityEffect> launchedEffects
	// passive effects from weapons (auras) - effect.type -> conversion rate
	Map<integer, real> passives = [:]

	constructor(integer id){
		this.id = id
		this.name = getName(id)!
		this.cell = Board.getCell(getCell(id))!
		this.level = getLevel(id)!
		this.totalLife = getTotalLife(id)!
		this.life = getLife(id)!
		this.pwr = getPower(id)!
		this.str = getStrength(id)!
		this.mgc = getMagic(id)!
		this.wsd = getWisdom(id)!
		this.rst = getResistance(id)!
		this.agi = getAgility(id)!
		this.snc = getScience(id)!
		this.tp = getTP(id)!
		this.mp = getMP(id)!
		this.relShield = getRelativeShield(id)!
		this.absShield = getAbsoluteShield(id)!
		this.dmgReturn = getDamageReturn(id)!
		this.items = Items.getItems(id)
		// PotiMalef: hold summon+teleport chips for blocking resurrection cell
		if (BossPotiMalef.shouldHoldChips() && id == getEntity()) {
			Array<Item> filtered = []
			for (Item item in this.items) {
				if ((item.isSummon && item.id != CHIP_RESURRECTION) || item.id == CHIP_TELEPORTATION) continue
				push(filtered, item)
			}
			this.items = filtered
		}
		// Check for support chip cooldowns (antidote, liberation)
		for (Item item in this.items) {
			if (item.id == CHIP_ANTIDOTE) {
				this.antidoteCD = getCooldown(item.id, this.id)!
			} else if (item.id == CHIP_LIBERATION) {
				this.liberationCD = getCooldown(item.id, this.id)!
			} else if (item.id == CHIP_MANUMISSION) {
				this.manumissionCD = getCooldown(item.id, this.id)!
			} else if (item.id == CHIP_JUMP) {
				this.jumpCD = getCooldown(item.id, this.id)!
				this.jumpItem = item
			} else if (item.id == CHIP_TELEPORTATION) {
				this.teleportCD = getCooldown(item.id, this.id)!
				this.teleportItem = item
				MapPath._teleportMaxRange = item.maxRange
			}
		}
		// Load passive effects from entity
		for(Array e in getPassiveEffects(this.id)!) {
			integer type = e[0] as integer
			real value = e[1] as real
			// Percentage-based passives (convert damage/poison/erosion/cells to stat)
			if(type == EFFECT_DAMAGE_TO_STRENGTH
				|| type == EFFECT_DAMAGE_TO_ABSOLUTE_SHIELD
				|| type == EFFECT_NOVA_DAMAGE_TO_MAGIC
				|| type == EFFECT_POISON_TO_SCIENCE
				|| type == EFFECT_CRITICAL_TO_HEAL
				|| type == EFFECT_MOVED_TO_MP) {
				value = value / 100
			}
			// Absolute passives (KILL_TO_TP, ALLY_KILLED_TO_AGILITY) stored as-is
			this.passives[type] = value
		}
		this.turnOrder = getEntityTurnOrder(id)!
		this.isFriend = isAlly(id)
		this.isBulb = isSummon(id)!
		// Fennel King boss: detect crystals by name (must NOT be damaged)
		this.isCrystal = this.name == "blue_crystal" || this.name == "green_crystal" || this.name == "red_crystal" || this.name == "yellow_crystal"
		// Fennel King boss: detect graal (must NOT be moved)
		this.isGraal = this.name == "graal"
		// Fennel King boss: detect main boss (boosted TP/MP shackle coefs)
		this.isFennelKing = this.name == "fennel_king"
		this.isEvilPumpkin = this.name == "evil_pumpkin"
		this.entityType = getType(id)!
		// Cache extended type (bulb-specific type detection done once here)
		if (this.isBulb) {
			string n = this.name
			if (n == "metallic_bulb") this.extendedType = BULB_METALLIC
			else if (n == "healer_bulb") this.extendedType = BULB_HEALER
			else if (n == "lightning_bulb") this.extendedType = BULB_LIGHTNING
			else if (n == "wizard_bulb") this.extendedType = BULB_WIZARD
			else if (n == "fire_bulb") this.extendedType = BULB_FIRE
			else if (n == "iced_bulb") this.extendedType = BULB_ICED
			else if (n == "rocky_bulb") this.extendedType = BULB_ROCKY
			else if (n == "puny_bulb") this.extendedType = BULB_PUNY
			else if (n == "tactician_bulb") this.extendedType = BULB_TACTICIAN
			else if (n == "savant_bulb") this.extendedType = BULB_SAVANT
			else this.extendedType = ENTITY_BULB
		} else {
			this.extendedType = this.entityType
		}
		/*
		this.launchedEffects = []
		for(var e in getLaunchedEffects(id)){
			push(this.launchedEffects,
		}
		*/

		this.psnlife = this.life  // Adjusted after loadEffects() in Fight.refresh()
		this.isOTK = this.str >= 400 && this.agi >= 400 && this.snc >= 400
	}

	/*
	 * Updates entity position from game state.
	 * Used by Fight.updateForSummon() to update existing entities without recreating them.
	 */
	void updatePosition() {
		this.cell = Board.getCell(getCell(this.id))!
	}

	/*
	 * Refreshes entity state from game for bulb turn synchronization.
	 * Called by Fight.updateForSummon() on existing entities to ensure they have
	 * up-to-date HP/stats/effects after the main leek's actions.
	 * Does NOT touch precomputed AI data (offensiveItems, reachableCells, etc.).
	 */
	void refreshState() {
		// Refresh HP (may have changed from damage/heals/erosion)
		this.life = getLife(this.id)!
		this.totalLife = getTotalLife(this.id)!

		// Refresh all stats (could be buffed/shackled)
		this.pwr = getPower(this.id)!
		this.str = getStrength(this.id)!
		this.mgc = getMagic(this.id)!
		this.wsd = getWisdom(this.id)!
		this.rst = getResistance(this.id)!
		this.agi = getAgility(this.id)!
		this.snc = getScience(this.id)!
		this.tp = getTP(this.id)!
		this.mp = getMP(this.id)!

		// Refresh shields and damage return
		this.relShield = getRelativeShield(this.id)!
		this.absShield = getAbsoluteShield(this.id)!
		this.dmgReturn = getDamageReturn(this.id)!

		// Clear and reload effects
		this.effects = []
		this.items_effectOverTime = [:]
		this.psnTurn = 0
		this.psnTotal = 0
		this.altStr = 0
		this.altMgc = 0
		this.altAgi = 0
		this.altTP = 0
		this.altMP = 0
		this.isStatic = false
		this.isInvincible = false
		this.hasCovid = false
		this.antidoteCD = 5
		this.liberationCD = 6
		this.manumissionCD = 6
		this.jumpCD = 4
		this.jumpItem = null
		this.teleportCD = 11
		this.teleportItem = null
		for (Item item in this.items) {
			if (item.id == CHIP_ANTIDOTE) {
				this.antidoteCD = getCooldown(item.id, this.id)!
			} else if (item.id == CHIP_LIBERATION) {
				this.liberationCD = getCooldown(item.id, this.id)!
			} else if (item.id == CHIP_MANUMISSION) {
				this.manumissionCD = getCooldown(item.id, this.id)!
			} else if (item.id == CHIP_JUMP) {
				this.jumpCD = getCooldown(item.id, this.id)!
				this.jumpItem = item
			} else if (item.id == CHIP_TELEPORTATION) {
				this.teleportCD = getCooldown(item.id, this.id)!
				this.teleportItem = item
			}
		}
		this.loadEffects()
		this.psnlife = this.life - this.psnTurn
	}

	/*
	 * Loads effects from game state into entity fields.
	 * Called by constructor and refreshState().
	 * Assumes effect-related fields are already initialized/cleared.
	 */
	void loadEffects() {
		for(Array<boolean|integer> e in getEffects(this.id)!) {
			EntityEffect effect = EntityEffect(e)
			// RAW_BUFF_POWER: skip, no item associated - use entity.pwr stat instead
			if (effect.type == EFFECT_RAW_BUFF_POWER) continue
			// ADD_STATE: set flags, don't add to effects (can't be liberated)
			if(effect.type == EFFECT_ADD_STATE) {
				if(effect.value == STATE_INVINCIBLE) this.isInvincible = true
				else if(effect.value == 11) this.isStatic = true // no STATE_STATIC constant in leekwars api
				continue
			}
			push(effects, effect)
			if(!this.items_effectOverTime[effect.item]) this.items_effectOverTime[effect.item] = []
			push(this.items_effectOverTime[effect.item]!, EffectOverTime(effect))
			// COVID detection (propagates to nearby entities)
			if (effect.item.id == CHIP_COVID) this.hasCovid = true
			// piste d'optimisation en ayant une meilleure structure pour les effets ici ?
			// les eval en dessous pourrait être déléguer à un tab pour éviter les ifelseif?
			// et ptete ajouter d'autres alt pour les autres stats ?
			if(effect.type == EFFECT_POISON) {
				this.psnTurn += effect.value
				this.psnTotal += effect.value * effect.turns
			} else if(effect.type == EFFECT_HEAL) {
				this.psnTurn += -effect.value
				this.psnTotal += -effect.value * effect.turns
			} else if(effect.type == EFFECT_SHACKLE_STRENGTH) {
				this.altStr += -effect.value
			//	} else if(effect.type == EFFECT_SHACKLE_MAGIC) {
			//		this.altMgc -= value
			} else if(effect.type == EFFECT_SHACKLE_TP) {
				this.altTP += -effect.value
			} else if(effect.type == EFFECT_SHACKLE_MP) {
				this.altMP += -effect.value
			} else if(effect.type == EFFECT_BUFF_STRENGTH || effect.type == EFFECT_RAW_BUFF_STRENGTH) {
				this.altStr += effect.value
			} else if(effect.type == EFFECT_BUFF_TP || effect.type == EFFECT_RAW_BUFF_TP) {
				this.altTP += effect.value
			} else if(effect.type == EFFECT_BUFF_MP || effect.type == EFFECT_RAW_BUFF_MP) {
				this.altMP += effect.value
			} else if(effect.type == EFFECT_BUFF_AGILITY || effect.type == EFFECT_RAW_BUFF_AGILITY) {
				this.altAgi += effect.value
			}
		}
	}

	/*
	 * Initialise certaines informations de l'objet Entity
	 * Certaines peuvent être dépendantes d'autres classes.
	 */
	void init(){
		this.entitiesWhoPlayBefore = Fight.getEntitiesWhoPlayBefore(this)
		for(Entity entity in this.entitiesWhoPlayBefore) {
			setPut(this.cellsToIgnore, entity.cell)
		}
		this.reachableCells = MapPath.getCachedReachableCells(
			this.cell,
			this.mp,
			this.cellsToIgnore
		)

		// Compute jump-extended reach (walk + CHIP_JUMP teleport)
		if (this.jumpCD <= 1 && this.jumpItem != null) {
			this.reachableCellsJump = MapPath.getJumpReachableCells(
				this.reachableCells, this.mp, this.cellsToIgnore, <>
			)
		} else {
			this.reachableCellsJump = this.reachableCells
		}

		// Compute teleport reachability for enemy OTK entities in solo fights
		if (!this.isFriend && this.isOTK && this.teleportCD <= 1 && this.teleportItem != null) {
			if (getFightType() == FIGHT_TYPE_SOLO) {
				boolean canJump = this.jumpCD <= 1 && this.jumpItem != null
				if (canJump) {
					this.reachableCellsTeleport = MapPath.getJumpTeleportReachableCells(
						this.reachableCells, this.mp, this.cellsToIgnore, <>,
						this.teleportItem!.maxRange)
				} else {
					this.reachableCellsTeleport = MapPath.getTeleportReachableCells(
						this.reachableCells, this.mp, this.cellsToIgnore, <>,
						this.teleportItem!.maxRange)
				}
			}
		}

		// Compute extended reach for self only (used by MapAction, MapPosition)
		if (this == Fight.self) {
			this.maxMPBuff = this.computeMaxMPBuff()
			if (this.maxMPBuff > 0) {
				this.extendedReachableCells = MapPath.getCachedReachableCells(
					this.cell,
					this.mp + this.maxMPBuff,
					this.cellsToIgnore
				)
			} else {
				this.extendedReachableCells = this.reachableCells
			}
			// Compute jump-extended reach for self (walk+buff+jump = max theoretical reach)
			if (this.jumpCD == 0 && this.jumpItem != null) {
				this.jumpExtendedReachableCells = MapPath.getJumpReachableCells(
					this.extendedReachableCells, this.mp + this.maxMPBuff, this.cellsToIgnore, <>
				)
			} else {
				this.jumpExtendedReachableCells = this.extendedReachableCells
			}

			// Compute max extended reach (full movement envelope including teleport)
			boolean canTeleport = this.teleportCD == 0 && this.teleportItem != null
			boolean canJump = this.jumpCD == 0 && this.jumpItem != null
			integer totalMP = this.mp + this.maxMPBuff

			if (canJump && canTeleport) {
				this.maxExtendedReachableCells = MapPath.getJumpTeleportReachableCells(
					this.extendedReachableCells, totalMP, this.cellsToIgnore, <>,
					this.teleportItem!.maxRange)
			} else if (canTeleport) {
				this.maxExtendedReachableCells = MapPath.getTeleportReachableCells(
					this.extendedReachableCells, totalMP, this.cellsToIgnore, <>,
					this.teleportItem!.maxRange)
			} else {
				this.maxExtendedReachableCells = this.jumpExtendedReachableCells
			}
		}
	}

	/*
	 * Calculate total potential MP buff from all self-cast items.
	 * Scans this entity's items for MP buff effects and sums all gains.
	 * MP buffs stack (Leather Boots + Motivation + Wings = total gain).
	 *
	 * TODO: AOE MP buffs (e.g. Precipitation) give +MP per target hit,
	 * but this only counts 1 target. Should estimate potential targets
	 * in range for a more accurate extendedReachableCells calculation.
	 */
	integer computeMaxMPBuff() {
		integer totalGain = 0
		integer tpBudget = this.tp
		real sncMultiplier = 1 + this.snc / 100.0

		for (Item item in this.items) {
			// Skip if not self-castable (minRange > 0 means can't target self)
			if (item.minRange > 0) continue
			// Skip if on cooldown
			if (item.haveCD && getCooldown(item.id) > 0) continue
			// Skip if can't afford (track TP budget across items)
			if (item.cost > tpBudget) continue

			for (ItemEffect effect in item.effects) {
				integer gain = 0
				if (effect.type == EFFECT_RAW_BUFF_MP) {
					gain = round(effect.avg)
				} else if (effect.type == EFFECT_BUFF_MP) {
					// Science-scaled buff
					gain = round(effect.avg * sncMultiplier)
				}
				if (gain > 0) {
					totalGain += gain
					tpBudget -= item.cost  // Deduct TP for this item
					break  // Move to next item (don't double-count effects from same item)
				}
			}
		}

		return totalGain
	}

	/*
	 * Retourne l'objet Item correspondant à l'arme dans les mains de l'entité
	 * @return une Item
	 */
	Item? getWeaponInHand(){
		return Items.getItem(getWeapon(this.id))
	}
	
	// Returns the most recent effect from an item on this entity (for !stackable checks)
	// Uses Consequences.getExistingItemEffect which is COW-aware
	EffectOverTime? getCurrentItemEffect(Item item, Consequences? consequences){
		if (consequences != null) {
			return consequences!.getExistingItemEffect(this, item)
		}
		return this.items_effectOverTime[item] ? this.items_effectOverTime[item]![0] : null
	}
	
	integer getCurrentMaxHP(Consequences? consequences){
		return consequences ? this.totalLife+consequences!.getAlteration(this, Stats.HPMAX) : this.totalLife 
	}
	integer getCurrentHP(Consequences? consequences){
		return consequences ? this.life+consequences!.getAlteration(this, Stats.HP) : this.life 
	}
	integer getCurrentHPMissing(Consequences? consequences){
		return this.getCurrentMaxHP(consequences) - this.getCurrentHP(consequences) 
	}
	integer getCurrentTP(Consequences? consequences){
		return consequences ? this.tp+consequences!.getAlteration(this, Stats.TP) : this.tp 
	}
	integer getCurrentMP(Consequences? consequences){
		return consequences ? this.mp+consequences!.getAlteration(this, Stats.MP) : this.mp 
	}
	integer getCurrentStr(Consequences? consequences){
		return consequences ? this.str+consequences!.getAlteration(this, Stats.STR) : this.str 
	}
	integer getCurrentMgc(Consequences? consequences){
		return consequences ? this.mgc+consequences!.getAlteration(this, Stats.MGC) : this.mgc 
	}
	integer getCurrentPwr(Consequences? consequences){
		return consequences ? this.pwr+consequences!.getAlteration(this, Stats.PWR) : this.pwr 
	}
	integer getCurrentWsd(Consequences? consequences){
		return consequences ? this.wsd+consequences!.getAlteration(this, Stats.WSD) : this.wsd 
	}
	integer getCurrentRst(Consequences? consequences){
		return consequences ? this.rst+consequences!.getAlteration(this, Stats.RST) : this.rst 
	}
	integer getCurrentAgi(Consequences? consequences){
		return consequences ? this.agi+consequences!.getAlteration(this, Stats.AGI) : this.agi 
	}
	integer getCurrentSnc(Consequences? consequences){
		return consequences ? this.snc+consequences!.getAlteration(this, Stats.SNC) : this.snc 
	}
	integer getCurrentAbs(Consequences? consequences){
		return consequences ? this.absShield+consequences!.getAlteration(this, Stats.ABSSHIELD) : this.absShield 
	}
	integer getCurrentRel(Consequences? consequences){
		return consequences ? this.relShield+consequences!.getAlteration(this, Stats.RELSHIELD) : this.relShield
	}
	integer getCurrentDmgReturn(Consequences? consequences){
		return consequences ? this.dmgReturn+consequences!.getAlteration(this, Stats.DMGRETURN) : this.dmgReturn
	}
	
	/*
	 * Actualise les informations de l'entité
	 * FIXME: UNUSED FUNCTION
	 */
	void refresh() {
		// TODO make a real full refresh based on consequences? might be used for bulb?
		// OR delete this shit ? full refresh by instantiating the entity again, and replacing it in Fight ?
		this.mp = getMP(this.id)!
		this.cell = Board.getCell(getCell(this.id))!
		this.reachableCells = MapPath.getCachedReachableCells(
			this.cell,
			this.mp,
			this.cellsToIgnore
		)
	}

	/*
	 * Format chaîne de caracteres utilisée pour des tests / debugs.
	 */
	string string() {
		return "<Entity "+this.name+">"
	}
}

// TODO
	//scoreLibe: scoreLibe
	//nbBulbs: count(bulbs)//todo check si ça vaut le coup de garder cette info..
	//bulbs: @bulbs
	//canJump: inArray(getChips(leek), CHIP_JUMP) && getCooldown(CHIP_JUMP, leek)<=1
