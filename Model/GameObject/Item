/*
 * Objet contenant les informations correspondante a une item
 * On en instancie un pour chacun des équipements du jeu
 */
class Item {
	integer id
	string name
	boolean isWeap
	boolean haveCD
	integer cdDuration = 0
	integer minRange
	integer maxRange
	integer launchType
	boolean needLOS
	integer cost
	integer area
	boolean isAOE
	boolean onCaster = false
	integer maxUse  // Max uses per round (from API)
	Array<ItemEffect> effects = []
	integer priority  // Execution order priority (lower = first)

	integer targetKey
	boolean targetEmptyCell = false
	boolean isSummon = false
	boolean isTactical = false
	boolean isOffensive = false  // Can deal damage/debuff to enemies (O(1) check)

	static integer ALL = 0
	static integer ALLLEEKS = 1
	static integer ALLBULBS = 2
	static integer ALLIES = 3
	static integer ALLIESLEEKS = 4
	static integer ALLIESBULBS = 5
	static integer ENEMIES = 6
	static integer ENEMIESLEEKS = 7
	static integer ENEMIESBULBS = 8
	static integer NONE = 9

	// Default priority for items not in PRIORITIES map
	static integer UNKNOWN_PRIORITY = 50

	// Priority groups (suggested consolidation for future reference):
	// -1: Antidote (before Liberation - full poison removal)
	// 0: Debuff removal (Liberation)
	// 1: Inversion (position swap before summons)
	// 2: Summons, resurrection (early, so they can receive buffs)
	// 3: Agility buffs (crits for subsequent attacks)
	// 4-5: TP/MP generation
	// 6-7: MP buffs
	// 8-10: Strength/Magic buffs (before damage)
	// 11-12: Resistance/Wisdom (before heals/armor)
	// 13: Armor reduction (before main damage)
	// 14: Armor application
	// 15-18: Damage, poison, debuffs
	// 19-20: Heals, damage reflection
	static Map<integer, integer> PRIORITIES = [
		CHIP_ANTIDOTE: -1,           // Before Liberation - full poison removal
		CHIP_MANUMISSION: -1,		 // hmmm avant ou après libe ? xD
		CHIP_LIBERATION: 0,          // Removes debuffs (after Antidote)
		CHIP_INVERSION: 1,           // Position swap (before summons)
		CHIP_LIGHTNING_BULB: 2,      // Summons early (so bulb can receive buffs)
		CHIP_WIZARD_BULB: 2,
		CHIP_FIRE_BULB: 2,
		CHIP_METALLIC_BULB: 2,
		CHIP_HEALER_BULB: 2,
		CHIP_ICED_BULB: 2,
		CHIP_ROCKY_BULB: 2,
		CHIP_PUNY_BULB: 2,
		CHIP_TACTICIAN_BULB: 2,
		CHIP_SAVANT_BULB: 2,
		CHIP_RESURRECTION: 2,        // Resurrection early (like summons)
		CHIP_REFLEXES: 3,            // Agility buffs (crits)
		CHIP_STRETCHING: 3,
		CHIP_WARM_UP: 3,
		CHIP_RAGE: 4,                // TP generation
		CHIP_MOTIVATION: 4,
		CHIP_COVETOUSNESS: 4,
		CHIP_ADRENALINE: 4,
		CHIP_WHIP: 5,
		CHIP_SEVEN_LEAGUE_BOOTS: 6,  // MP buffs
		CHIP_PRECIPITATION: 6,
		CHIP_ACCELERATION: 6,
		CHIP_LEATHER_BOOTS: 6,
		CHIP_WINGED_BOOTS: 7,
		CHIP_WIZARDRY: 8,
		CHIP_DOPING: 9,              // Strength (before damage)
		CHIP_PROTEIN: 9,
		CHIP_PRISM: 9,
		CHIP_FEROCITY: 10,
		CHIP_STEROID: 10,
		CHIP_SOLIDIFICATION: 11,     // Resistance (before armor)
		CHIP_BARK: 11,
		CHIP_COLLAR: 12,             // Wisdom (before heals)
		CHIP_KNOWLEDGE: 12,
		WEAPON_J_LASER: 13,          // Armor reduction (before main damage)
		WEAPON_SHOTGUN: 13,
		WEAPON_MYSTERIOUS_ELECTRISOR: 13,
		CHIP_CARAPACE: 14,           // Armor application
		CHIP_FORTRESS: 14,
		CHIP_ARMOR: 14,
		CHIP_RAMPART: 14,
		CHIP_SHIELD: 14,
		CHIP_WALL: 14,
		CHIP_HELMET: 14,
		CHIP_DOME: 14,
		CHIP_BURNING: 15,            // Burning (cleans metal before damage)
		CHIP_DEVIL_STRIKE: 16,       // Self-damage attacks
		WEAPON_NEUTRINO:16,			 // vuln before dmg
		CHIP_METEORITE: 17,          // Main damage
		CHIP_ICEBERG: 17,
		CHIP_ROCKFALL: 17,
		CHIP_LIGHTNING: 17,
		CHIP_STALACTITE: 17,
		CHIP_FLAME: 17,
		CHIP_ROCK: 17,
		CHIP_ICE: 17,
		CHIP_SPARK: 17,
		CHIP_PEBBLE: 17,
		CHIP_SHOCK: 17,
		WEAPON_AXE: 17,
		WEAPON_B_LASER: 17,
		WEAPON_BROADSWORD: 17,
		WEAPON_DESTROYER: 17,
		WEAPON_DOUBLE_GUN: 17,
		WEAPON_ELECTRISOR: 17,
		WEAPON_RHINO: 17,
		WEAPON_RIFLE: 17,
		WEAPON_GRENADE_LAUNCHER: 17,
		WEAPON_KATANA: 17,
		WEAPON_LASER: 17,
		WEAPON_MACHINE_GUN: 17,
		WEAPON_MAGNUM: 17,
		WEAPON_M_LASER: 17,
		WEAPON_PISTOL: 17,
		WEAPON_UNBRIDLED_GAZOR: 17,
		WEAPON_ILLICIT_GRENADE_LAUNCHER: 17,
		WEAPON_LIGHTNINGER: 17,
		WEAPON_BAZOOKA: 17,
		WEAPON_DARK_KATANA: 17,
		WEAPON_ENHANCED_LIGHTNINGER: 17,
		WEAPON_UNSTABLE_DESTROYER: 17,
		WEAPON_SWORD: 17,
		WEAPON_HEAVY_SWORD: 17,
		WEAPON_ODACHI: 17,
		WEAPON_EXCALIBUR: 17,
		WEAPON_SCYTHE: 17,
		CHIP_FLASH: 17,
		CHIP_PUNISHMENT: 17,
		CHIP_PLASMA: 17,
		WEAPON_FLAME_THROWER: 18,    // Poison (after direct damage)
		WEAPON_GAZOR: 18,
		WEAPON_REVOKED_M_LASER: 18,
		CHIP_SOPORIFIC: 18,          // Debuffs/poison (before heals)
		CHIP_BALL_AND_CHAIN: 18,
		CHIP_TRANQUILIZER: 18,
		CHIP_SLOW_DOWN: 18,
		CHIP_FRACTURE: 18,
		CHIP_CRUSHING: 18,
		CHIP_BRAINWASHING: 18,
		CHIP_PLAGUE: 18,
		CHIP_TOXIN: 18,
		CHIP_VENOM: 18,
		CHIP_COVID: 18,
		CHIP_ARSENIC: 18,
		WEAPON_QUANTUM_RIFLE: 19,	 // nova dmg after dmg
		CHIP_DESINTEGRATION: 19, 
		CHIP_ALTERATION: 19,         // Heals and buffs (after damage)
		CHIP_FERTILIZER: 19,
		CHIP_REMISSION: 19,
		CHIP_LOAM: 19,
		CHIP_ARMORING: 19,
		CHIP_REGENERATION: 19,
		CHIP_VACCINE: 19,
		CHIP_DRIP: 19,
		CHIP_CURE: 19,
		CHIP_BANDAGE: 19,
		WEAPON_EXPLORER_RIFLE: 19,
		CHIP_VAMPIRIZATION: 19, // maybe should be before dmg as it target enemies ?
		CHIP_ELEVATION: 19,
		CHIP_THERAPY: 19,
		CHIP_MUTATION: 19,
		CHIP_TRANSMUTATION: 19,
		CHIP_SERUM: 19,
		CHIP_MIRROR: 20,             // Damage reflection
		CHIP_THORN: 20,
		CHIP_BRAMBLE: 20,
		CHIP_JUMP: 22,
		CHIP_REPOTTING: 22,
		CHIP_GRAPPLE: 22,
		CHIP_BOXING_GLOVE: 22,
		CHIP_TELEPORTATION: 22,
		CHIP_RESURRECTION: 22,
		CHIP_APOCALYPSE: 23, // boss chips
		CHIP_KILL: 23,
		CHIP_DIVINE_PROTECTION: 23,
		415: 23, // CHIP_AWAKENING
		425: 23, // CHIP_EXASPERATION
		411: 23, // unknown shuriken
		412: 23, // unknown kemuridama
		413: 23, // unknown fire_ball
		414: 23, // unknown trebuchet
		416: 23, // unknown thunder
	]
			
	constructor(integer id) {
		this.id = id
		this.name = getWeaponName(id)+getChipName(id)

		// Lookup priority from static map, log unknown items
		if (Item.PRIORITIES[id] != null) {
			this.priority = Item.PRIORITIES[id]!
		} else {
			this.priority = Item.UNKNOWN_PRIORITY
			debugW("Unknown item priority: " + id + " (" + this.name + ")")
		}

		this.isWeap = isWeapon(id)
		if(this.isWeap){
			this.haveCD = false
			this.minRange = getWeaponMinRange(id)
			this.maxRange = getWeaponMaxRange(id)
			this.launchType = getWeaponLaunchType(id)!
			this.needLOS = weaponNeedLos(id)
			this.cost = getWeaponCost(id)
			this.area = getWeaponArea(id)!
			this.maxUse = getWeaponMaxUses(id)
			integer i = 0
			for(Array<real | integer> e in getWeaponEffects(id)!){
				push(this.effects, ItemEffect(e, this, i++))
			}
		} else {
			this.cdDuration = getChipCooldown(id)
			// Handle infinite cooldown (-1) - can only use once per fight
			if (this.cdDuration == -1) this.cdDuration = ScoringConfig.MAX_FIGHT_TURNS
			this.haveCD = this.cdDuration != 0
			this.minRange = getChipMinRange(id)!
			this.maxRange = getChipMaxRange(id)!
			this.launchType = getChipLaunchType(id)!
			this.needLOS = chipNeedLos(id)
			this.cost = getChipCost(id)!
			this.area = getChipArea(id)!
			this.maxUse = getChipMaxUses(id)!
			if (this.maxUse == -1) this.maxUse = this.haveCD ? 1 : 99
			integer i = 0
			for(Array<real | integer> e in getChipEffects(id)!){
				push(this.effects, ItemEffect(e, this, i++))
			}
		}

		// Detect summon and tactical chips
		for (ItemEffect e in this.effects) {
			if (e.type == EFFECT_SUMMON || e.type == EFFECT_RESURRECT) {
				this.isSummon = true
			}
			if (e.type == EFFECT_INVERT ||
				e.type == EFFECT_TELEPORT ||
				e.type == EFFECT_PUSH ||
				e.type == EFFECT_ATTRACT) {
				this.isTactical = true
			}
		}

		if(this.area == AREA_POINT || this.area == AREA_LASER_LINE) this.isAOE = false
		else this.isAOE = true
		// on cherche à trouver quels sont les cibles valides et intéressante de l'item
		// on set targetKey pour que targetSet pointe vers la fonction qui renvera uniquement les entités intéressante à cibler
		boolean allies = false, enemies = false, onBulbs = false, onLeeks = false;
		for(ItemEffect e in this.effects){
			if(!allies) allies = e.targetType.allies
			if(!enemies) enemies = e.targetType.enemies
			if(!onBulbs) onBulbs = e.targetType.onBulbs
			if(!onLeeks) onLeeks = e.targetType.onLeeks
			if(!this.onCaster) this.onCaster = e.targetType.onCaster
		}
		
		if(false){ // TODO FAIRE UNE PASSE SUR LES ITEMS POUR CHECK SI TOUT EST COMME JE LE SOUHAITE §
			// + coder les items chelous dans TargetType
			debug(this)
			debug("allies:"+allies)
			debug("enemies:"+enemies)
			debug("onBulbs:"+onBulbs)
			debug("onLeeks:"+onLeeks)
			pause()
		}
		
		// si c'est un lazer, je veux potentiellement tirer à travers tout le monde ^^
		if(this.area == AREA_LASER_LINE){
			allies = true
			enemies = true
			onBulbs = true
			onLeeks = true
		}
		
		if(allies && enemies){ // ALL
			if(onLeeks && onBulbs) this.targetKey = Item.ALL
			else if(onLeeks && !onBulbs) this.targetKey = Item.ALLLEEKS
			else if(!onLeeks && onBulbs) this.targetKey = Item.ALLBULBS
			else{
				debugW('strange targetKey in <Item> for '+this)
				this.targetKey = Item.NONE
			}
		} else if(allies && !enemies){ // only ALLIES
			if(onLeeks && onBulbs) this.targetKey = Item.ALLIES
			else if(onLeeks && !onBulbs) this.targetKey = Item.ALLIESLEEKS
			else if(!onLeeks && onBulbs) this.targetKey = Item.ALLIESBULBS
			else{
				debugW('strange targetKey in <Item> for '+this)
				this.targetKey = Item.NONE
			}

		} else if(!allies && enemies){ // only ENEMIES
			if(onLeeks && onBulbs) this.targetKey = Item.ENEMIES
			else if(onLeeks && !onBulbs) this.targetKey = Item.ENEMIESLEEKS
			else if(!onLeeks && onBulbs) this.targetKey = Item.ENEMIESBULBS
			else{
				debugW('strange targetKey in <Item> for '+this)
				this.targetKey = Item.NONE
			}
		} else { // none: cas des actions avec des items de déplacements teleport, ou des invocs
			this.targetKey = Item.NONE
			targetEmptyCell = true // TODO handle this param in IA
		}

		// Set isOffensive: can deal damage/debuff to enemies (used for O(1) filtering)
		this.isOffensive = enemies && !this.isSummon && !this.isTactical
	}
	
	Map<integer, Entity> targetSet(){
		if(this.targetKey==Item.ALL) return Fight.getAllAlive()
		if(this.targetKey==Item.ALLLEEKS) return Fight.getAllLeeksAlive()
		if(this.targetKey==Item.ALLBULBS) return Fight.getAllBulbsAlive()
		if(this.targetKey==Item.ALLIES) return Fight.getAlliesAlive()
		if(this.targetKey==Item.ALLIESLEEKS) return Fight.getAlliesLeeksAlive()
		if(this.targetKey==Item.ALLIESBULBS) return Fight.getAlliesBulbsAlive()
		if(this.targetKey==Item.ENEMIES) return Fight.getEnemiesAlive()
		if(this.targetKey==Item.ENEMIESLEEKS) return Fight.getEnemiesLeeksAlive()
		if(this.targetKey==Item.ENEMIESBULBS) return Fight.getEnemiesBulbsAlive()
		if(this.targetKey==Item.NONE) return [:]
	}
	
	/*
	 * tente d'utiliser l'item
	 * @param cell cellule de type Cell représentant l'endroit ou je veux utiliser l'Item avec id: (this.id)
	 */
	void useItemOnCell(Cell cell){
		if(this.isWeap){
			if(getWeapon(Fight.self.id)!=this.id) setWeapon(this.id)
			useWeaponOnCell(cell.id)
		} else useChipOnCell(this.id, cell.id)
	}

	/*
	 * Same as useItemOnCell but returns the result code
	 */
	integer useItemOnCellWithResult(Cell cell){
		if(this.isWeap){
			if(getWeapon(Fight.self.id)!=this.id) setWeapon(this.id)
			return useWeaponOnCell(cell.id)
		} else return useChipOnCell(this.id, cell.id)
	}
	
	/*
	 * tente d'utiliser l'item
	 * @param cell cellule de type Cell représentant l'endroit ou je veux utiliser l'Item avec id: (this.id)
	 */
	void useItem(Entity entity){
		if(this.isWeap){
			if(getWeapon(Fight.self.id)!=this.id) setWeapon(this.id)
			useWeapon(entity.id)
		} else useChip(this.id, entity.id)
	}
	
	/*
	 * Format chaîne de caracteres utilisée pour des tests / debugs.
	 */
	string() {
		return "<Item "+this.name+">"
	}
}