/*
 * BulbChipAction - Lightweight action for bulb combo simulation
 */
class BulbChipAction {
	Item item
	integer cost
	real damage
	integer maxUse

	constructor(Item item, integer cost, real damage, integer maxUse) {
		this.item = item
		this.cost = cost
		this.damage = damage
		this.maxUse = maxUse
	}
}

/*
 * BulbSimulator - Utility functions for bulb damage calculation
 */
class BulbSimulator {

	/*
	 * Calculate expected damage for a chip vs target
	 * Handles both direct damage (STR) and poison damage (MGC)
	 * Uses EffectCalc for formula consistency
	 */
	static real calcChipDamage(Item chip, BulbStats stats, Entity target) {
		real totalDmg = 0

		for (ItemEffect effect in chip.effects) {
			if (effect.type == EFFECT_DAMAGE) {
				// Direct damage: STR-based, bulbs have pwr=0, ratio=1.0, targetCount=1
				real raw = EffectCalc.rawDamage(effect.avg, stats.str, 0, 1.0, 1)
				real dmg = EffectCalc.applyShields(raw, target.relShield, target.absShield)
				totalDmg += dmg
			} else if (effect.type == EFFECT_POISON) {
				// Poison damage: MGC-based, duration from effect
				// Poison bypasses shields, total damage over duration
				integer dur = effect.duration > 0 ? effect.duration : 2
				real psn = EffectCalc.poisonDamage(effect.avg, stats.mgc, 0, 1.0, dur)
				totalDmg += psn
			}
		}

		return totalDmg
	}

	/*
	 * Calculate expected healing for a chip on ally
	 * Uses EffectCalc for formula consistency
	 */
	static real calcChipHeal(Item chip, BulbStats stats, Entity ally) {
		real totalHeal = 0

		for (ItemEffect effect in chip.effects) {
			if (effect.type == EFFECT_HEAL) {
				// Bulbs have ratio=1.0
				real heal = EffectCalc.healValue(effect.avg, stats.wsd, 1.0)
				if (heal > 0) totalHeal += heal
			}
		}

		return totalHeal
	}

	/*
	 * Calculate expected absolute shield value for a chip on ally
	 * Returns raw value, scoring should use Stats.ABSSHIELD coefficient
	 */
	static real calcChipAbsShield(Item chip, BulbStats stats, Entity ally) {
		real total = 0
		for (ItemEffect effect in chip.effects) {
			if (effect.type == EFFECT_ABSOLUTE_SHIELD) {
				real shield = EffectCalc.scaledShield(effect.avg, stats.rst, 1.0)
				if (shield > 0) total += shield
			}
		}
		return total
	}

	/*
	 * Calculate expected relative shield value for a chip on ally
	 * Returns raw percentage, scoring should use Stats.RELSHIELD coefficient
	 */
	static real calcChipRelShield(Item chip, BulbStats stats, Entity ally) {
		real total = 0
		for (ItemEffect effect in chip.effects) {
			if (effect.type == EFFECT_RELATIVE_SHIELD) {
				real shield = EffectCalc.scaledShield(effect.avg, stats.rst, 1.0)
				if (shield > 0) total += shield
			}
		}
		return total
	}

	/*
	 * Knapsack algorithm to find optimal chip damage within TP budget
	 * @param actions Array of BulbChipAction with (item, cost, damage, maxUse)
	 * @param maxTP   Available TP
	 * @return Maximum damage achievable
	 */
	static real knapsackDamage(Array<BulbChipAction> actions, integer maxTP) {
		if (count(actions) == 0 || maxTP <= 0) return 0

		// Expand actions respecting maxUse
		Array<BulbChipAction> expanded = []
		Map<Item, integer> useCounts = [:]

		// Sort by damage/cost (best efficiency first)
		actions = arraySort(actions, (BulbChipAction a, BulbChipAction b) -> real {
			return (b.damage / b.cost) - (a.damage / a.cost)
		}) as Array<BulbChipAction>

		for (BulbChipAction a in actions) {
			integer uses = useCounts[a.item] != null ? useCounts[a.item]! : 0
			if (uses >= a.maxUse) continue
			push(expanded, a)
			useCounts[a.item] = uses + 1
		}

		if (count(expanded) == 0) return 0

		// DP: dp[tp] = max damage using exactly tp
		Array<real> dp = []
		for (integer i = 0; i <= maxTP; i++) {
			push(dp, 0.0)
		}

		// 0/1 knapsack (each expanded action used at most once)
		for (BulbChipAction action in expanded) {
			// Process in reverse to avoid using same item twice
			for (integer tp = maxTP; tp >= action.cost; tp--) {
				real newDmg = dp[tp - action.cost] + action.damage
				if (newDmg > dp[tp]) {
					dp[tp] = newDmg
				}
			}
		}

		// Find best achievable damage
		real best = 0
		for (integer tp = 0; tp <= maxTP; tp++) {
			if (dp[tp] > best) best = dp[tp]
		}

		return best
	}
}
