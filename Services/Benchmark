class Benchmark{
	static Map<string, integer> _count_func = [:]
	static Map<string, integer> _cumul_func = [:]
	static Map<string, integer> _laststart_func = [:]
	static Array<string> _callStack = []
	static Map<string, string> _parent_func = [:]

	static string MARKER = "##MARKER##"
	static _turn = 0
	static _startOps = 0
	static _name = ""
	static _mctsIter = 0
	static _mctsNodes = 0
	static _mctsPos = 0
	static _mctsBest = 0
	// PTS stats
	static _ptsOpps = 0
	static _ptsActions = 0
	static _ptsBest = 0
	// Beam Search stats
	static _beamDepth = 0
	static _beamCandidates = 0
	static _beamPos = 0
	static _beamBest = 0
	static _beamOpsExpand = 0
	static _beamOpsSort = 0
	static _beamOpsPos = 0
	static _beamOpsTotal = 0
	static _beamBudgetLow = false
	// Algorithm comparison
	static _algoMode = ""
	static _algoWinner = ""
	// Calibration stats (CalibratedPTS)
	static _calBudget = ""
	static _calMpValue = 0
	static _calPoints = 0
	// MCTS cells tracking
	static Array<integer> _mctsSeeds = []      // Priority cells from PTS
	static Array<integer> _mctsExplored = []   // Cells actually explored
	static Array<integer> _mctsSkipped = []    // Cells skipped (budget)
	static _chosenDesc = ""
	static _chosenScore = 0
	static _chosenActions = 0
	static _selfLife = 0
	static _selfMaxLife = 0
	static _selfTP = 0
	static _selfMaxTP = 0
	static _selfMP = 0
	static _selfMaxMP = 0
	static _selfUsedRAM = 0
	static _selfMaxRAM = 0
	static _selfCell = 0
	static _enemies = 0
	static _allies = 0

	static _maxCombos = 5
	static Array<string> _comboDesc = []
	static Array<integer> _comboScore = []
	static Array<integer> _comboActions = []
	static Array<integer> _comboPosScore = []
	static Array<integer> _comboActScore = []

	// MCTS best combo (separate from top 5 to always show it)
	static _mctsComboDesc = ""
	static _mctsComboScore = 0
	static _mctsComboActions = 0
	static _mctsComboPosScore = 0
	static _mctsComboActScore = 0

	static Array<string> _logs = []
	static _maxLogs = 20

	// Cooldowns tracking: array of [itemName, currentCD, maxCD]
	static Array<Array> _cooldownsStart = []
	static Array<Array> _cooldownsEnd = []

	// === Profiling ===

	static void reset(){
		_count_func = [:]
		_cumul_func = [:]
		_laststart_func = [:]
		_parent_func = [:]
		_callStack = []
	}

	static void start(string name){
		if(count(_callStack) > 0) _parent_func[name] = _callStack[count(_callStack) - 1]
		push(_callStack, name)
		if(_count_func[name] == null) _count_func[name] = 0
		if(_cumul_func[name] == null) _cumul_func[name] = 0
		_laststart_func[name] = getOperations()
	}

	static void stop(string name){
		_cumul_func[name] += getOperations() - _laststart_func[name] - 5
		_count_func[name]++
		if(count(_callStack) > 0) pop(_callStack)
	}

	static string format(real num){
		num = num | 0
		if(num >= 1000000) return round(num / 1000000) + "M"
		if(num >= 1000) return round(num / 1000) + "k"
		return num + ""
	}

	// === Turn lifecycle ===

	static void initTurn(){
		_turn = getTurn()
		_startOps = getOperations()
		_name = getName()
		_mctsIter = 0
		_mctsNodes = 0
		_mctsPos = 0
		_mctsBest = 0
		_ptsOpps = 0
		_ptsActions = 0
		_ptsBest = 0
		_beamDepth = 0
		_beamCandidates = 0
		_beamPos = 0
		_beamBest = 0
		_beamOpsExpand = 0
		_beamOpsSort = 0
		_beamOpsPos = 0
		_beamOpsTotal = 0
		_beamBudgetLow = false
		_algoMode = ""
		_algoWinner = ""
		_calBudget = ""
		_calMpValue = 0
		_calPoints = 0
		_mctsSeeds = []
		_mctsExplored = []
		_mctsSkipped = []
		_chosenDesc = ""
		_chosenScore = 0
		_chosenActions = 0
		_comboDesc = []
		_comboScore = []
		_comboActions = []
		_comboPosScore = []
		_comboActScore = []
		_mctsComboDesc = ""
		_mctsComboScore = 0
		_mctsComboActions = 0
		_mctsComboPosScore = 0
		_mctsComboActScore = 0
		_logs = []
		_cooldownsStart = []
		_cooldownsEnd = []
		_selfLife = getLife()
		_selfMaxLife = getTotalLife(getEntity())
		_selfTP = getTP()
		_selfMaxTP = getTotalTP(getEntity())
		_selfMP = getMP()
		_selfMaxMP = getTotalMP(getEntity())
		_selfUsedRAM = getUsedRAM()
		_selfMaxRAM = getMaxRAM()
		_selfCell = getCell()
		_enemies = count(getAliveEnemies())
		_allies = count(getAliveAllies())
		reset()
	}

	static void updateContext(){
		_selfLife = getLife()
		_selfMaxLife = getTotalLife(getEntity())
		_selfTP = getTP()
		_selfMaxTP = getTotalTP(getEntity())
		_selfMP = getMP()
		_selfMaxMP = getTotalMP(getEntity())
		_selfUsedRAM = getUsedRAM()
		_selfMaxRAM = getMaxRAM()
		_selfCell = getCell()
		_enemies = count(getAliveEnemies())
		_allies = count(getAliveAllies())
	}

	// === Tracking ===

	static void setMCTS(integer iter, integer nodes, integer pos, real best){
		_mctsIter = iter
		_mctsNodes = nodes
		_mctsPos = pos
		_mctsBest = round(best)
	}

	static void setPTS(integer opps, integer actions, real best){
		_ptsOpps = opps
		_ptsActions = actions
		_ptsBest = round(best)
	}

	static void setBeam(integer depth, integer candidates, integer opsExpand, integer opsSort, integer opsPos, integer opsTotal, real best, boolean budgetLow){
		_beamDepth = depth
		_beamCandidates = candidates
		_beamOpsExpand = opsExpand
		_beamOpsSort = opsSort
		_beamOpsPos = opsPos
		_beamOpsTotal = opsTotal
		_beamBest = round(best)
		_beamBudgetLow = budgetLow
	}

	static void setAlgo(string mode, string winner){
		_algoMode = mode
		_algoWinner = winner
	}

	static void setCalibration(string bestBudget, real mpValue, integer points){
		_calBudget = bestBudget
		_calMpValue = round(mpValue)
		_calPoints = points
	}

	static void setMCTSCells(Array<Cell> seeds, Array<Cell> explored, Array<Cell> skipped){
		_mctsSeeds = []
		_mctsExplored = []
		_mctsSkipped = []
		for (Cell c in seeds) push(_mctsSeeds, c.id)
		for (Cell c in explored) push(_mctsExplored, c.id)
		for (Cell c in skipped) push(_mctsSkipped, c.id)
	}

	static void setChosen(real score, integer actions, string desc){
		_chosenScore = round(score)
		_chosenActions = actions
		_chosenDesc = desc
	}

	static void setMCTSCombo(real score, integer actions, string desc, real posScore, real actScore){
		_mctsComboScore = round(score)
		_mctsComboActions = actions
		_mctsComboDesc = desc
		_mctsComboPosScore = round(posScore)
		_mctsComboActScore = round(actScore)
	}

	static void addCombo(real score, integer actions, string desc, real posScore, real actScore){
		integer s = round(score)
		integer ps = round(posScore)
		integer acts = round(actScore)

		if (count(_comboScore) < _maxCombos) {
			// Room available, just add
			push(_comboScore, s)
			push(_comboDesc, desc)
			push(_comboActions, actions)
			push(_comboPosScore, ps)
			push(_comboActScore, acts)
		} else {
			// Find index of minimum score
			integer minIdx = 0
			integer minScore = _comboScore[0]
			for (integer i = 1; i < _maxCombos; i++) {
				if (_comboScore[i] < minScore) {
					minScore = _comboScore[i]
					minIdx = i
				}
			}
			// Replace if new score is better
			if (s > minScore) {
				_comboScore[minIdx] = s
				_comboDesc[minIdx] = desc
				_comboActions[minIdx] = actions
				_comboPosScore[minIdx] = ps
				_comboActScore[minIdx] = acts
			}
		}
	}

	// === Logging (stored, output at end) ===

	static void log(string msg){ if(count(_logs) < _maxLogs) push(_logs, msg) }
	static void logInfo(string msg){ if(count(_logs) < _maxLogs) push(_logs, msg) }
	static void logWarn(string msg){ if(count(_logs) < _maxLogs) push(_logs, "âš " + msg) }
	static void logError(string msg){ if(count(_logs) < _maxLogs) push(_logs, "âŒ" + msg) }
	static void logDebug(string msg){ if(count(_logs) < _maxLogs) push(_logs, "â€¦" + msg) }
	static void logMove(integer from, integer to){ if(count(_logs) < _maxLogs) push(_logs, "â†’" + from + ">" + to) }
	static void logBuff(string item){ if(count(_logs) < _maxLogs) push(_logs, "+" + item) }
	static void logAttack(string item, integer target, integer dmg){
		if(count(_logs) < _maxLogs) push(_logs, "âš”" + item + ">" + target + "=" + dmg)
	}
	static void logHeal(string item, integer amount){
		if(count(_logs) < _maxLogs) push(_logs, "â¤" + item + "+" + amount)
	}
	static void logKill(integer target){
		if(count(_logs) < _maxLogs) push(_logs, "ğŸ’€" + target)
	}

	// === Cooldowns tracking ===

	static void collectCooldownsStart(Array<Item> items, integer entityId) {
		_cooldownsStart = []
		for (Item item in items) {
			if (!item.haveCD) continue
			integer cd = getCooldown(item.id, entityId)
			push(_cooldownsStart, [item.name, cd, item.cdDuration])
		}
	}

	static void collectCooldownsEnd(Array<Item> items, integer entityId) {
		_cooldownsEnd = []
		for (Item item in items) {
			if (!item.haveCD) continue
			integer cd = getCooldown(item.id, entityId)
			push(_cooldownsEnd, [item.name, cd, item.cdDuration])
		}
	}

	// === Display: ONE debug() call ===

	// Category definitions for grouped display
	static Array<Array<string>> CATEGORIES = [
		["INIT", "init", "Map.init", "Items.init"],
		["REFRESH", "MapPath.refresh", "Fight.refresh", "Map.refresh", "Scoring.refresh", "MapDanger.refresh", "MapAllyHeal.refresh", "MapAllyDamage.refresh", "MapPosition.refresh", "MapAction.refresh", "MapOpportunity.refresh"],
		["PTS", "PTS.buildCombo", "CalibratedPTS.calibrate", "CalibratedPTS.buildWithBudget"],
		["MCTS", "MCTS.iter", "Hybrid.runMCTSFull", "Hybrid.runMCTSPrioritized", "Hybrid.getMCTSSeeded", "Hybrid.getMCTSGuided"],
		["BEAM", "BeamSearch.search", "Hybrid.runBeamFull", "Hybrid.runBeamPrioritized", "Hybrid.getBeamGuided"],
		["POSITION", "MP.evalPos", "MP.findBest"],
		["ACTION", "addAction"],
		["CONSEQUENCES", "Consequences", "Consequences.fromConseq"]
	]

	static string getCategoryForFunc(string name) {
		for (var cat in CATEGORIES) {
			for (var i = 1; i < count(cat); i++) {
				if (cat[i] == name) return cat[0]
			}
		}
		return "OTHER"
	}

	static void display(){
		var displayStart = getOperations()
		var totalOps = getOperations() - _startOps
		var maxOps = getMaxOperations()

		// Count total tracked functions
		var funcCount = 0
		for (string name : integer nbCall in _count_func) {
			if (nbCall > 0) funcCount++
		}

		var s = MARKER + "T" + _turn
		s += "|n:" + _name
		s += "|o:" + totalOps + "/" + maxOps
		s += "|hp:" + _selfLife + "/" + _selfMaxLife
		// Use current values (after actions) for TP/MP/RAM to show what's remaining
		s += "|tp:" + getTP() + "/" + getTotalTP(getEntity()) + "|mp:" + getMP() + "/" + getTotalMP(getEntity())
		s += "|ram:" + getUsedRAM() + "/" + getMaxRAM()
		s += "|c:" + _selfCell + "|e:" + _enemies + "|a:" + _allies
		s += "|m:" + _mctsIter + "," + _mctsNodes + "," + _mctsPos + "," + _mctsBest
		s += "|p:" + _ptsOpps + "," + _ptsActions + "," + _ptsBest
		s += "|b:" + _beamDepth + "," + _beamCandidates + "," + _beamOpsExpand + "," + _beamOpsSort + "," + _beamOpsPos + "," + _beamOpsTotal + "," + _beamBest + "," + (_beamBudgetLow ? 1 : 0)
		if(_algoMode != "") s += "|algo:" + _algoMode + "," + _algoWinner
		if(_calBudget != "") s += "|cal:" + _calBudget + "," + _calMpValue + "," + _calPoints
		s += "|fc:" + funcCount  // Function count for verification

		// MCTS cells: seeds, explored, skipped
		if (count(_mctsSeeds) > 0 || count(_mctsExplored) > 0) {
			s += "|cells:" + join(_mctsSeeds, ",") + ";" + join(_mctsExplored, ",") + ";" + join(_mctsSkipped, ",")
		}

		if(_chosenDesc != "") s += "|ch:" + _chosenScore + "," + _chosenActions + "," + _chosenDesc

		for(var i = 0; i < count(_comboScore); i++){
			s += "|cb:" + _comboScore[i] + "," + _comboActScore[i] + "," + _comboPosScore[i] + "," + _comboDesc[i]
		}

		// MCTS best combo (always shown separately)
		if(_mctsComboDesc != "") s += "|mcb:" + _mctsComboScore + "," + _mctsComboActScore + "," + _mctsComboPosScore + "," + _mctsComboDesc

		// Group functions by category
		Map<string, Array<Array>> catFuncs = [:]
		for (string name : integer nbCall in _count_func) {
			if (nbCall == 0) continue
			var cat = getCategoryForFunc(name)
			if (!catFuncs[cat]) catFuncs[cat] = []
			var pct = round(_cumul_func[name]! * 100 / totalOps)
			var parent = _parent_func[name] ? _parent_func[name]! : ""
			push(catFuncs[cat]!, [name, nbCall, _cumul_func[name]!, pct, parent])
		}

		// Output by category in defined order, then OTHER
		for (var cat in CATEGORIES) {
			var catName = cat[0] as string
			if (catFuncs[catName] && count(catFuncs[catName]!) > 0) {
				// Sort by total ops descending within category
				var funcs = arraySort(catFuncs[catName]!, (a, b) -> a[2] < b[2] ? 1 : -1) as Array<Array>
				s += "|cat:" + catName
				for (var m in funcs) {
					s += "|f:" + m[0] + "," + m[1] + "," + m[2] + "," + m[3] + "," + m[4]
				}
			}
		}

		// OTHER category last
		if (catFuncs["OTHER"] && count(catFuncs["OTHER"]!) > 0) {
			var funcs = arraySort(catFuncs["OTHER"]!, (a, b) -> a[2] < b[2] ? 1 : -1) as Array<Array>
			s += "|cat:OTHER"
			for (var m in funcs) {
				s += "|f:" + m[0] + "," + m[1] + "," + m[2] + "," + m[3] + "," + m[4]
			}
		}

		for(var i = 0; i < count(_logs); i++) s += "|l:" + _logs[i]

		// Cooldowns start of turn: cds:name,current,max;...
		if (count(_cooldownsStart) > 0) {
			var cdParts = []
			for (var cd in _cooldownsStart) {
				push(cdParts, cd[0] + "," + cd[1] + "," + cd[2])
			}
			s += "|cds:" + join(cdParts, ";")
		}

		// Cooldowns end of turn: cde:name,current,max;...
		if (count(_cooldownsEnd) > 0) {
			var cdParts = []
			for (var cd in _cooldownsEnd) {
				push(cdParts, cd[0] + "," + cd[1] + "," + cd[2])
			}
			s += "|cde:" + join(cdParts, ";")
		}

		// Display ops and final total
		var displayOps = getOperations() - displayStart
		s += "|dops:" + displayOps
		s += "|end:" + (getOperations() - _startOps)

		debug(s)
	}

	static void displayText(){
		var totalOps = getOperations() - _startOps
		var maxOps = getMaxOperations()
		var pctOps = round(totalOps * 100 / maxOps)

		debug("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
		debug("Turn " + _turn + " | " + _name + " | " + pctOps + "% ops")
		debug("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")

		// Context
		debug("HP: " + _selfLife + "/" + _selfMaxLife + " | TP: " + getTP() + "/" + getTotalTP(getEntity()) + " | MP: " + getMP() + "/" + getTotalMP(getEntity()))
		debug("Cell: " + _selfCell + " | Enemies: " + _enemies + " | Allies: " + _allies)

		// Algorithm results
		debug("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
		if (_algoMode != "") {
			debug("Algorithm: " + _algoMode + " â†’ " + _algoWinner + " wins")
		}
		debug("MCTS: " + _mctsIter + " iter, " + _mctsNodes + " nodes, " + _mctsPos + " pos â†’ score " + _mctsBest)
		if (_ptsOpps > 0) {
			debug("PTS:  " + _ptsOpps + " opps, " + _ptsActions + " actions â†’ score " + _ptsBest)
		}
		if (_beamDepth > 0) {
			debug("BEAM: d=" + _beamDepth + " cand=" + _beamCandidates + " expand=" + _beamOpsExpand + " sort=" + _beamOpsSort + " pos=" + _beamOpsPos + " total=" + _beamOpsTotal + " score=" + _beamBest + (_beamBudgetLow ? " [LOW]" : ""))
		}

		// Chosen combo
		if (_chosenDesc != "") {
			debug("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
			debug("â˜… Chosen: " + _chosenDesc)
			debug("  Score: " + _chosenScore + " | Actions: " + _chosenActions)
		}

		// Top combos
		if (count(_comboScore) > 0) {
			debug("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
			debug("Top Combos:")
			for (var i = 0; i < count(_comboScore); i++) {
				debug("  " + (i + 1) + ". " + _comboDesc[i] + " (score: " + _comboScore[i] + ")")
			}
		}

		// Profiler - group by category
		debug("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
		debug("Profiler (" + format(totalOps) + "/" + format(maxOps) + " ops):")

		Map<string, Array<Array>> catFuncs = [:]
		for (string name : integer nbCall in _count_func) {
			if (nbCall == 0) continue
			var cat = getCategoryForFunc(name)
			if (!catFuncs[cat]) catFuncs[cat] = []
			var pct = round(_cumul_func[name]! * 100 / totalOps)
			push(catFuncs[cat]!, [name, nbCall, _cumul_func[name]!, pct])
		}

		for (var cat in CATEGORIES) {
			var catName = cat[0] as string
			if (catFuncs[catName] && count(catFuncs[catName]!) > 0) {
				var catTotal = 0
				for (var m in catFuncs[catName]!) catTotal += m[2] as integer
				var catPct = round(catTotal * 100 / totalOps)
				debug("  [" + catName + "] " + catPct + "% (" + format(catTotal) + " ops)")
				var funcs = arraySort(catFuncs[catName]!, (a, b) -> a[2] < b[2] ? 1 : -1) as Array<Array>
				for (var m in funcs) {
					debug("    " + m[0] + ": " + m[1] + "x " + format(m[2]) + " (" + m[3] + "%)")
				}
			}
		}

		if (catFuncs["OTHER"] && count(catFuncs["OTHER"]!) > 0) {
			var catTotal = 0
			for (var m in catFuncs["OTHER"]!) catTotal += m[2] as integer
			var catPct = round(catTotal * 100 / totalOps)
			debug("  [OTHER] " + catPct + "% (" + format(catTotal) + " ops)")
			var funcs = arraySort(catFuncs["OTHER"]!, (a, b) -> a[2] < b[2] ? 1 : -1) as Array<Array>
			for (var m in funcs) {
				debug("    " + m[0] + ": " + m[1] + "x " + format(m[2]) + " (" + m[3] + "%)")
			}
		}

		// Logs
		if (count(_logs) > 0) {
			debug("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
			debug("Logs:")
			for (var log in _logs) debug("  " + log)
		}

		debug("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	}

	static void displayAll(){
		display()
		displayText()
	}
}
