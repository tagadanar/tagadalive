class TrackCooldown {
	public string itemName
	public integer curentCD
	public integer maxCD

	constructor(string itemName, integer curentCD, integer maxCD) {
		this.itemName = itemName 
		this.curentCD = curentCD
		this.maxCD = maxCD
	}
}

class TrackOperations {
	public string functionName
	public integer nbCall
	public integer totalOps
	public integer pct
	public string parent

	constructor(string functionName, integer nbCall, integer totalOps, integer pct, string parent = "") {
		this.functionName = functionName 
		this.nbCall = nbCall
		this.totalOps = totalOps
		this.pct = pct
		this.parent = parent
	}
}

class Benchmark{
	static Map<string, integer> _count_func = [:]
	static Map<string, integer> _cumul_func = [:]
	static Map<string, integer> _laststart_func = [:]
	static Array<string> _callStack = []
	static Map<string, string> _parent_func = [:]

	static string MARKER = "##MARKER##"
	static integer _turn = 0
	static integer _startOps = 0
	static string _name = ""
	static integer _mctsIter = 0
	static integer _mctsNodes = 0
	static integer _mctsPos = 0
	static integer _mctsBest = 0
	// Beam Search stats
	static integer _beamDepth = 0
	static integer _beamCandidates = 0
	static integer _beamPos = 0
	static integer _beamBest = 0
	static integer _beamOpsExpand = 0
	static integer _beamOpsSort = 0
	static integer _beamOpsPos = 0
	static integer _beamOpsTotal = 0
	static boolean _beamBudgetLow = false
	// Algorithm comparison
	static string _algoMode = ""
	static string _algoWinner = ""
	// MCTS cells tracking
	static Array<integer> _mctsSeeds = []      // Priority cells from PTS
	static Array<integer> _mctsExplored = []   // Cells actually explored
	static Array<integer> _mctsSkipped = []    // Cells skipped (budget)
	static string _chosenDesc = ""
	static integer _chosenScore = 0
	static integer _chosenActions = 0
	static integer _selfLife = 0
	static integer _selfMaxLife = 0
	static integer _selfTP = 0
	static integer _selfMaxTP = 0
	static integer _selfMP = 0
	static integer _selfMaxMP = 0
	static integer _selfUsedRAM = 0
	static integer _selfMaxRAM = 0
	static integer _selfCell = 0
	static integer _enemies = 0
	static integer _allies = 0

	static integer _maxCombos = 5
	static Array<string> _comboDesc = []
	static Array<integer> _comboScore = []
	static Array<integer> _comboActions = []
	static Array<integer> _comboPosScore = []
	static Array<integer> _comboActScore = []

	// MCTS best combo (separate from top 5 to always show it)
	static string _mctsComboDesc = ""
	static integer _mctsComboScore = 0
	static integer _mctsComboActions = 0
	static integer _mctsComboPosScore = 0
	static integer _mctsComboActScore = 0

	static Array<string> _logs = []
	static integer _maxLogs = 20

	// Cooldowns tracking: array of [itemName, currentCD, maxCD]
	static Array<Array> _cooldownsStart = []
	static Array<Array> _cooldownsEnd = []

	// === Profiling ===

	static void reset(){
		_count_func = [:]
		_cumul_func = [:]
		_laststart_func = [:]
		_parent_func = [:]
		_callStack = []
	}

	static void start(string name){
		if(count(_callStack) > 0) _parent_func[name] = _callStack[count(_callStack) - 1]
		push(_callStack, name)
		if(_count_func[name] == null) _count_func[name] = 0
		if(_cumul_func[name] == null) _cumul_func[name] = 0
		_laststart_func[name] = getOperations()
	}

	static void stop(string name){
		_cumul_func[name] += getOperations() - _laststart_func[name] - 5
		_count_func[name]++
		if(count(_callStack) > 0) pop(_callStack)
	}

	static string format(integer|real num){
		num = num | 0
		if(num >= 1000) return (round(num / 1000) | 0) + "k"
		return num + ""
	}

	// === Turn lifecycle ===

	static void initTurn(){
		_turn = getTurn()
		_startOps = getOperations()
		_name = getName()
		_mctsIter = 0
		_mctsNodes = 0
		_mctsPos = 0
		_mctsBest = 0
		_beamDepth = 0
		_beamCandidates = 0
		_beamPos = 0
		_beamBest = 0
		_beamOpsExpand = 0
		_beamOpsSort = 0
		_beamOpsPos = 0
		_beamOpsTotal = 0
		_beamBudgetLow = false
		_algoMode = ""
		_algoWinner = ""
		_mctsSeeds = []
		_mctsExplored = []
		_mctsSkipped = []
		_chosenDesc = ""
		_chosenScore = 0
		_chosenActions = 0
		_comboDesc = []
		_comboScore = []
		_comboActions = []
		_comboPosScore = []
		_comboActScore = []
		_mctsComboDesc = ""
		_mctsComboScore = 0
		_mctsComboActions = 0
		_mctsComboPosScore = 0
		_mctsComboActScore = 0
		_logs = []
		_cooldownsStart = []
		_cooldownsEnd = []
		_selfLife = getLife()
		_selfMaxLife = getTotalLife(getEntity())!
		_selfTP = getTP()
		_selfMaxTP = getTotalTP(getEntity())!
		_selfMP = getMP()
		_selfMaxMP = getTotalMP(getEntity())!
		_selfUsedRAM = getUsedRAM()
		_selfMaxRAM = getMaxRAM()
		_selfCell = getCell()!
		_enemies = count(getAliveEnemies())
		_allies = count(getAliveAllies())
		reset()
	}

	static void updateContext(){
		_selfLife = getLife()
		_selfMaxLife = getTotalLife(getEntity())!
		_selfTP = getTP()
		_selfMaxTP = getTotalTP(getEntity())!
		_selfMP = getMP()
		_selfMaxMP = getTotalMP(getEntity())!
		_selfUsedRAM = getUsedRAM()
		_selfMaxRAM = getMaxRAM()
		_selfCell = getCell()!
		_enemies = count(getAliveEnemies())
		_allies = count(getAliveAllies())
	}

	// === Tracking ===

	static void setMCTS(integer iter, integer nodes, integer pos, real best){
		_mctsIter = iter
		_mctsNodes = nodes
		_mctsPos = pos
		_mctsBest = round(best)
	}

	static void setBeam(integer depth, integer candidates, integer opsExpand, integer opsSort, integer opsPos, integer opsTotal, real best, boolean budgetLow){
		_beamDepth = depth
		_beamCandidates = candidates
		_beamOpsExpand = opsExpand
		_beamOpsSort = opsSort
		_beamOpsPos = opsPos
		_beamOpsTotal = opsTotal
		_beamBest = round(best)
		_beamBudgetLow = budgetLow
	}

	static void setAlgo(string mode, string winner){
		_algoMode = mode
		_algoWinner = winner
	}

	static void setMCTSCells(Array<Cell> seeds, Array<Cell> explored, Array<Cell> skipped){
		_mctsSeeds = []
		_mctsExplored = []
		_mctsSkipped = []
		for (Cell c in seeds) push(_mctsSeeds, c.id)
		for (Cell c in explored) push(_mctsExplored, c.id)
		for (Cell c in skipped) push(_mctsSkipped, c.id)
	}

	static void setChosen(real score, integer actions, string desc){
		_chosenScore = round(score)
		_chosenActions = actions
		_chosenDesc = desc
	}

	static void setMCTSCombo(real score, integer actions, string desc, real posScore, real actScore){
		_mctsComboScore = round(score)
		_mctsComboActions = actions
		_mctsComboDesc = desc
		_mctsComboPosScore = round(posScore)
		_mctsComboActScore = round(actScore)
	}

	static void addCombo(real score, integer actions, string desc, real posScore, real actScore){
		integer s = round(score)
		integer ps = round(posScore)
		integer acts = round(actScore)

		if (count(_comboScore) < _maxCombos) {
			// Room available, just add
			push(_comboScore, s)
			push(_comboDesc, desc)
			push(_comboActions, actions)
			push(_comboPosScore, ps)
			push(_comboActScore, acts)
		} else {
			// Find index of minimum score
			integer minIdx = 0
			integer minScore = _comboScore[0]
			for (integer i = 1; i < _maxCombos; i++) {
				if (_comboScore[i] < minScore) {
					minScore = _comboScore[i]
					minIdx = i
				}
			}
			// Replace if new score is better
			if (s > minScore) {
				_comboScore[minIdx] = s
				_comboDesc[minIdx] = desc
				_comboActions[minIdx] = actions
				_comboPosScore[minIdx] = ps
				_comboActScore[minIdx] = acts
			}
		}
	}

	// === Logging (stored, output at end) ===

	static void log(string msg){ if(count(_logs) < _maxLogs) push(_logs, msg) }
	static void logInfo(string msg){ if(count(_logs) < _maxLogs) push(_logs, msg) }
	static void logWarn(string msg){ if(count(_logs) < _maxLogs) push(_logs, "‚ö†" + msg) }
	static void logError(string msg){ if(count(_logs) < _maxLogs) push(_logs, "‚ùå" + msg) }
	static void logDebug(string msg){ if(count(_logs) < _maxLogs) push(_logs, "‚Ä¶" + msg) }
	static void logMove(integer from, integer to){ if(count(_logs) < _maxLogs) push(_logs, "‚Üí" + from + ">" + to) }
	static void logBuff(string item){ if(count(_logs) < _maxLogs) push(_logs, "+" + item) }
	static void logAttack(string item, integer target, integer dmg){
		if(count(_logs) < _maxLogs) push(_logs, "‚öî" + item + ">" + target + "=" + dmg)
	}
	static void logHeal(string item, integer amount){
		if(count(_logs) < _maxLogs) push(_logs, "‚ù§" + item + "+" + amount)
	}
	static void logKill(integer target){
		if(count(_logs) < _maxLogs) push(_logs, "üíÄ" + target)
	}

	// === Cooldowns tracking ===

	static void collectCooldownsStart(Array<Item> items, integer entityId) {
		_cooldownsStart = []
		for (Item item in items) {
			if (!item.haveCD) continue
			integer cd = getCooldown(item.id, entityId)!
			push(_cooldownsStart, [item.name, cd, item.cdDuration])
		}
	}

	static void collectCooldownsEnd(Array<Item> items, integer entityId) {
		_cooldownsEnd = []
		for (Item item in items) {
			if (!item.haveCD) continue
			integer cd = getCooldown(item.id, entityId)!
			push(_cooldownsEnd, [item.name, cd, item.cdDuration])
		}
	}

	// === Display: ONE debug() call ===

	// Category definitions for grouped display
	static Array<Array<string>> CATEGORIES = [
		["INIT", "init", "Map.init", "Items.init"],
		["REFRESH", "MapPath.refresh", "Fight.refresh", "Map.refresh", "Scoring.refresh", "MapDanger.refresh", "MapAllyHeal.refresh", "MapAllyDamage.refresh", "MapPosition.refresh", "MapAction.refresh"],
		["MCTS", "MCTS.iter", "Hybrid.runMCTSFull"],
		["BEAM", "BeamSearch.search", "Hybrid.runBeamFull"],
		["POSITION", "MP.evalPos", "MP.findBest"],
		["ACTION", "addAction"],
		["CONSEQUENCES", "Consequences", "Consequences.fromConseq"]
	]

	static string getCategoryForFunc(string name) {
		for (var cat in CATEGORIES) {
			for (var i = 1; i < count(cat); i++) {
				if (cat[i] == name) return cat[0]
			}
		}
		return "OTHER"
	}

	static void display(){
		var displayStart = getOperations()
		var totalOps = getOperations() - _startOps
		var maxOps = getMaxOperations()

		// Count total tracked functions
		var funcCount = 0
		for (string name : integer nbCall in _count_func) {
			if (nbCall > 0) funcCount++
		}

		var s = MARKER + "T" + _turn
		s += "|n:" + _name
		s += "|o:" + totalOps + "/" + maxOps
		s += "|hp:" + _selfLife + "/" + _selfMaxLife
		// Use current values (after actions) for TP/MP/RAM to show what's remaining
		s += "|tp:" + getTP() + "/" + getTotalTP(getEntity()) + "|mp:" + getMP() + "/" + getTotalMP(getEntity())
		s += "|ram:" + getUsedRAM() + "/" + getMaxRAM()
		s += "|c:" + _selfCell + "|e:" + _enemies + "|a:" + _allies
		s += "|m:" + _mctsIter + "," + _mctsNodes + "," + _mctsPos + "," + _mctsBest
		s += "|b:" + _beamDepth + "," + _beamCandidates + "," + _beamOpsExpand + "," + _beamOpsSort + "," + _beamOpsPos + "," + _beamOpsTotal + "," + _beamBest + "," + (_beamBudgetLow ? 1 : 0)
		if(_algoMode != "") s += "|algo:" + _algoMode + "," + _algoWinner
		s += "|fc:" + funcCount  // Function count for verification

		// MCTS cells: seeds, explored, skipped
		if (count(_mctsSeeds) > 0 || count(_mctsExplored) > 0) {
			s += "|cells:" + join(_mctsSeeds, ",") + ";" + join(_mctsExplored, ",") + ";" + join(_mctsSkipped, ",")
		}

		if(_chosenDesc != "") s += "|ch:" + _chosenScore + "," + _chosenActions + "," + _chosenDesc

		for(var i = 0; i < count(_comboScore); i++){
			s += "|cb:" + _comboScore[i] + "," + _comboActScore[i] + "," + _comboPosScore[i] + "," + _comboDesc[i]
		}

		// MCTS best combo (always shown separately)
		if(_mctsComboDesc != "") s += "|mcb:" + _mctsComboScore + "," + _mctsComboActScore + "," + _mctsComboPosScore + "," + _mctsComboDesc

		// Group functions by category
		Map<string, Array<TrackOperations>> catFuncs = [:]
		for (string name : integer nbCall in _count_func) {
			if (nbCall == 0) continue
			string cat = getCategoryForFunc(name)
			if (!catFuncs[cat]) catFuncs[cat] = []
			integer pct = round(_cumul_func[name]! * 100 / totalOps)
			string parent = _parent_func[name] ? _parent_func[name]! : ""
			push(catFuncs[cat]!, new TrackOperations(name, nbCall, _cumul_func[name]!, pct, parent))
		}

		// Output by category in defined order, then OTHER
		for (Array<string> cat in CATEGORIES) {
			string catName = cat[0]
			if (catFuncs[catName] && count(catFuncs[catName]!) > 0) {
				// Sort by total ops descending within category
				Array<TrackOperations> funcs = arraySort(catFuncs[catName]!, (TrackOperations a, TrackOperations b) => integer { return b.totalOps - a.totalOps; }) as Array<TrackOperations>
				s += "|cat:" + catName
				for (TrackOperations m in funcs) {
					s += "|f:" + m.functionName + "," + m.nbCall + "," + m.totalOps + "," + m.pct + "," + m.parent
				}
			}
		}

		// OTHER category last
		if (catFuncs["OTHER"] && count(catFuncs["OTHER"]!) > 0) {
			Array<TrackOperations> funcs = arraySort(catFuncs["OTHER"]!, (TrackOperations a, TrackOperations b) => integer { return b.totalOps - a.totalOps; }) as Array<TrackOperations>
			s += "|cat:OTHER"
			for (TrackOperations m in funcs) {
				s += "|f:" + m.functionName + "," + m.nbCall + "," + m.totalOps + "," + m.pct + "," + m.parent
			}
		}

		for(var i = 0; i < count(_logs); i++) s += "|l:" + _logs[i]

		// Cooldowns start of turn: cds:name,current,max;...
		if (count(_cooldownsStart) > 0) {
			var cdParts = []
			for (var cd in _cooldownsStart) {
				push(cdParts, cd[0] + "," + cd[1] + "," + cd[2])
			}
			s += "|cds:" + join(cdParts, ";")
		}

		// Cooldowns end of turn: cde:name,current,max;...
		if (count(_cooldownsEnd) > 0) {
			var cdParts = []
			for (var cd in _cooldownsEnd) {
				push(cdParts, cd[0] + "," + cd[1] + "," + cd[2])
			}
			s += "|cde:" + join(cdParts, ";")
		}

		// Display ops and final total
		integer displayOps = getOperations() - displayStart
		s += "|dops:" + displayOps
		s += "|end:" + (getOperations() - _startOps)

		debug(s)
	}

	static void displayText(){
		integer totalOps = getOperations() - _startOps
		integer maxOps = getMaxOperations()
		integer pctOps = round(totalOps * 100 / maxOps)

		debug("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
		debug("Turn " + _turn + " | " + _name + " | " + pctOps + "% ops")
		debug("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")

		// Context
		debug("HP: " + _selfLife + "/" + _selfMaxLife + " | TP: " + getTP() + "/" + getTotalTP(getEntity()) + " | MP: " + getMP() + "/" + getTotalMP(getEntity()))
		debug("Cell: " + _selfCell + " | Enemies: " + _enemies + " | Allies: " + _allies)

		// Algorithm results
		debug("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
		if (_algoMode != "") {
			debug("Algorithm: " + _algoMode + " ‚Üí " + _algoWinner + " wins")
		}
		if (_mctsIter > 0) {
			debug("MCTS: " + _mctsIter + " iter, " + _mctsNodes + " nodes, " + _mctsPos + " pos ‚Üí score " + _mctsBest)
		}
		if (_beamDepth > 0) {
			debug("BEAM: d=" + _beamDepth + " cand=" + _beamCandidates + " expand=" + _beamOpsExpand + " sort=" + _beamOpsSort + " pos=" + _beamOpsPos + " total=" + _beamOpsTotal + " score=" + _beamBest + (_beamBudgetLow ? " [LOW]" : ""))
		}

		// Chosen combo
		if (_chosenDesc != "") {
			debug("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
			debug("‚òÖ Chosen: " + _chosenDesc)
			debug("  Score: " + _chosenScore + " | Actions: " + _chosenActions)
		}

		// Top combos
		if (count(_comboScore) > 0) {
			debug("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
			debug("Top Combos:")
			for (var i = 0; i < count(_comboScore); i++) {
				debug("  " + (i + 1) + ". " + _comboDesc[i] + " (score: " + _comboScore[i] + ")")
			}
		}

		// Profiler - group by category
		debug("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
		debug("Profiler (" + format(totalOps) + "/" + format(maxOps) + " ops):")

		Map<string, Array<TrackOperations>> catFuncs = [:]
		for (string name : integer nbCall in _count_func) {
			if (nbCall == 0) continue
			var cat = getCategoryForFunc(name)
			if (!catFuncs[cat]) catFuncs[cat] = []
			var pct = round(_cumul_func[name]! * 100 / totalOps)
			push(catFuncs[cat]!, new TrackOperations(name, nbCall, _cumul_func[name]!, pct))
		}

		for (Array<string> cat in CATEGORIES) {
			string catName = cat[0]
			if (catFuncs[catName] && count(catFuncs[catName]!) > 0) {
				integer catTotal = 0
				for (var m in catFuncs[catName]!) catTotal += m.totalOps
				integer catPct = round(catTotal * 100 / totalOps)
				debug("  [" + catName + "] " + catPct + "% (" + format(catTotal) + " ops)")
				Array<TrackOperations> funcs = arraySort(catFuncs[catName]!, (TrackOperations a, TrackOperations b) => integer { return b.totalOps - a.totalOps; }) as Array<TrackOperations>
				for (TrackOperations m in funcs) {
					debug("    " + m.functionName + ": " + m.nbCall + "x " + format(m.totalOps) + " (" + m.pct + "%)")
				}
			}
		}

		if (catFuncs["OTHER"] && count(catFuncs["OTHER"]!) > 0) {
			integer catTotal = 0
			for (var m in catFuncs["OTHER"]!) catTotal += m.totalOps
			integer catPct = round(catTotal * 100 / totalOps)
			debug("  [OTHER] " + catPct + "% (" + format(catTotal) + " ops)")
			Array<TrackOperations> funcs = arraySort(catFuncs["OTHER"]!, (TrackOperations a, TrackOperations b) => integer { return b.totalOps - a.totalOps; }) as Array<TrackOperations>
			for (TrackOperations m in funcs) {
				debug("    " + m.functionName + ": " + m.nbCall + "x " + format(m.totalOps) + " (" + m.pct + "%)")
			}
		}

		// Logs
		if (count(_logs) > 0) {
			debug("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
			debug("Logs:")
			for (var log in _logs) debug("  " + log)
		}

		debug("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
	}

	static void displayAll(){
		display()
		displayText()
	}
}
