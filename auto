// ════════════════════════════════════════════════════════════════════════════
// AUTO - Include aggregator for TagadAI combat system
// ════════════════════════════════════════════════════════════════════════════
// INCLUDE ORDER MATTERS! Dependencies flow top-to-bottom.
// Do not reorder without understanding the dependency chain.
// ════════════════════════════════════════════════════════════════════════════

// ────────────────────────────────────────────────────────────────────────────
// FOUNDATION: API compatibility and game objects
// ────────────────────────────────────────────────────────────────────────────
include('Services/GameAPI')

include('Model/GameObject/Cell')
include('Model/GameObject/Entity')
include('Model/GameObject/EntityEffect')
include('Model/GameObject/TargetType')
include('Model/GameObject/ItemEffect')
include('Model/GameObject/Item')

include('Model/Const/Stats')

// ────────────────────────────────────────────────────────────────────────────
// CONTROLLERS: Game state management
// ────────────────────────────────────────────────────────────────────────────
include('Controlers/Fight')
include('Controlers/Board')
include('Controlers/Items')

// ────────────────────────────────────────────────────────────────────────────
// SUMMONS: Bulb models and simulation (needed before MapSummon)
// ────────────────────────────────────────────────────────────────────────────
include('Model/Summons/Buff')
include('Model/Summons/BulbStats')
include('Model/Summons/BulbProfile')
include('Model/Summons/BulbSimulator')
include('Model/Summons/SummonCandidate')
include('Model/Summons/PendingBulb')
include('Model/Summons/SummonPlan')

// ────────────────────────────────────────────────────────────────────────────
// SERVICES: Utilities (no dependencies, needed early)
// ────────────────────────────────────────────────────────────────────────────
include('Services/Sort')
include('Services/Benchmark')

// ────────────────────────────────────────────────────────────────────────────
// MAPS: Spatial indexing, pathfinding, danger assessment, targeting
// ────────────────────────────────────────────────────────────────────────────
include('Controlers/Maps/MapPath')
include('Controlers/Maps/MapDanger')
include('Controlers/Maps/MapAllySupport')
include('Controlers/Maps/MapAllyDamage')
include('Controlers/Maps/MapPosition')
include('Controlers/Targets')
include('Controlers/Maps/MapAction')
include('Controlers/Maps/MapSummon')
include('Controlers/Maps/MapCellScore')   // Cell-centric action aggregation (uses MapAction, Sort)

// ────────────────────────────────────────────────────────────────────────────
// COMBO SYSTEM: Action modeling and consequence simulation
// ────────────────────────────────────────────────────────────────────────────
//include('Model/Combos/Jump')
include('Model/Combos/Danger')
include('Model/Combos/HealPotential')
include('Model/Combos/AllyDamagePotential')
include('Model/Combos/Position')
include('Model/Combos/Damages')
include('Model/Combos/EffectCalc')       // Pure calculation helpers (no dependencies beyond Stats)
include('Model/Combos/EffectOverTime')
include('Model/Combos/Action')
include('Model/Combos/Consequences')
include('Model/Combos/Combo')

// EffectHandlers: Single source of truth for effect logic (duck-typed context)
// Must be AFTER EffectCalc, BEFORE effect files that use it.
include('Model/Combos/Effects/EffectHandlers')

// CRITICAL: Effects must be included AFTER Consequences, EffectCalc, AND EffectHandlers!
// Each effect file calls Consequences.registerHandlers() and uses EffectCalc/EffectHandlers.
include('Model/Combos/Effects/DamageEffects')
include('Model/Combos/Effects/HealEffects')
include('Model/Combos/Effects/ShieldEffects')
include('Model/Combos/Effects/BuffEffects')
include('Model/Combos/Effects/DebuffEffects')
include('Model/Combos/Effects/UtilityEffects')
include('Model/Combos/Effects/MovementEffects')
include('Model/Combos/Effects/PassiveEffects')

// ────────────────────────────────────────────────────────────────────────────
// SCORING SYSTEM: Coefficient calculation and action evaluation
// Order: Config → EntityCoefs → BattleState → Modifiers → Scoring facade
// Must be AFTER Consequences (Scoring uses Consequences? parameter type)
// ────────────────────────────────────────────────────────────────────────────
include('AI/ScoringConfig')
include('AI/EntityCoefs')
include('AI/BattleState')
include('AI/ScoringModifiers')
include('AI/Scoring')

// ────────────────────────────────────────────────────────────────────────────
// EFFECT CACHE: Caches EffectSnapshots for action pool creation
// EffectSnapshot must be AFTER Scoring (addAlteration uses Scoring.getDynamicCoef)
// ────────────────────────────────────────────────────────────────────────────
include('Model/Combos/EffectSnapshot')   // Inline scoring in addAlteration() needs Scoring
include('Controlers/EffectCache')
include('Model/Combos/Effects/SnapshotEffects')

// ────────────────────────────────────────────────────────────────────────────
// ALGORITHMS: Search strategies for combo building
// ────────────────────────────────────────────────────────────────────────────
include('AI/Algorithms/MCTS')
include('AI/Algorithms/BeamSearch')
include('AI/Algorithms/Hybrid')
include('AI/Algorithms/ActionKnapsack')
include('AI/Algorithms/ComboBuilder')     // Unified combo construction (uses ActionKnapsack)
include('AI/Algorithms/ComboExplorer')    // Multi-phase exploration (uses ComboBuilder)

// ────────────────────────────────────────────────────────────────────────────
// AI DISPATCHER: Entry point for algorithm selection
// ────────────────────────────────────────────────────────────────────────────
include('AI/AI')


// ════════════════════════════════════════════════════════════════════════════
// INIT: Per-turn initialization sequence
// ════════════════════════════════════════════════════════════════════════════

function init() {
	Benchmark.initTurn()
	Benchmark.start('init')
	if(getTurn()==1) {
		Benchmark.start('Map.init')
		Board.init()
		Benchmark.stop('Map.init')

		Benchmark.start('Items.init')
		Items.init()
		Benchmark.stop('Items.init')
	}
	Benchmark.start('MapPath.refresh')
	MapPath.refresh()
	Benchmark.stop('MapPath.refresh')

	Benchmark.start('Fight.refresh')
	Fight.refresh()
	Benchmark.stop('Fight.refresh')
	Benchmark.updateContext()

	Benchmark.start('Map.refresh')
	Board.refresh()  // Note: Board.refresh() internally calls Fight.refreshEntities()
	Benchmark.stop('Map.refresh')

	Benchmark.start('Scoring.refresh')
	Scoring.refresh()
	Benchmark.stop('Scoring.refresh')

	// MapDanger.refresh() now orchestrates both enemy danger AND ally heal maps
	// using interleaved round-robin with shared 40% operation budget
	Benchmark.start('MapDanger.refresh')
	MapDanger.refresh()
	Benchmark.stop('MapDanger.refresh')

	// IMPORTANT: computeAllAllyDanger() is separate from BattleState.refresh() because:
	// 1. It depends on MapDanger being refreshed first (uses danger maps)
	// 2. BattleState.refresh() is called inside Scoring.refresh() (before MapDanger)
	// If you call Scoring.refresh() alone, you must also call this afterward.
	BattleState.computeAllAllyDanger()

	/*Benchmark.start('MapAllyDamage.refresh')
	MapAllyDamage.refresh()
	Benchmark.stop('MapAllyDamage.refresh')*/

	Benchmark.start('MapPosition.refresh')
	MapPosition.refresh()
	Benchmark.stop('MapPosition.refresh')

	// MapSummon: compute best summon cells for available bulb chips (BEFORE MapAction)
	Benchmark.start('MapSummon.refresh')
	MapSummon.refresh()
	Benchmark.stop('MapSummon.refresh')

	Benchmark.start('MapAction.refresh')
	MapAction.refresh()
	Benchmark.stop('MapAction.refresh')

	Benchmark.stop('init')

	// Debug ally maps (uncomment to test)
	/*MapAllySupport.debugAllySupportItems()
	MapAllySupport.showSupportAll()
	MapAllyDamage.debugAllyWeapons()
	MapAllyDamage.showDamageAll()*/
}
